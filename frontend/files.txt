--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\app.config.ts ---

// src/app/app.config.ts
import { APP_INITIALIZER, ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { providePrimeNG } from 'primeng/config';
import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
import Aura from "@primeng/themes/aura";
import { routes } from './app.routes';
import { HTTP_INTERCEPTORS, provideHttpClient, withInterceptorsFromDi } from '@angular/common/http';
import { AuthInterceptor } from './interceptors/auth.interceptor';
import { MarkdownService, SECURITY_CONTEXT } from 'ngx-markdown';
import { provideTranslateService, TranslateService } from '@ngx-translate/core';
import { provideTranslateHttpLoader } from '@ngx-translate/http-loader';
import { MessageService } from 'primeng/api';
import { AppConfig, ConfigService } from './shared/config/config.service';
import { SupabaseService } from './shared/db/supabase.service';
import { environment } from '../environments/environment.prod';
import { LanguageService } from './shared/utils/language.service';
import { BillingService } from './shared/billing/billing.service';
import { PaymentService } from './shared/billing/payment.service';
import { UsageService } from './shared/billing/usage.service';
import { AnalyticsService } from './shared/analytics.service';

export function initializeApp(configService: ConfigService, supabaseService: SupabaseService): () => Promise<void> {
  return async () => {
    try {
      const config = await configService.loadConfig();
      
      if (!config.supabaseUrl || !config.supabaseKey) {
        console.warn('Supabase config missing, using mock mode');
        await supabaseService.initialize(config);
        return;
      }
      
      await supabaseService.initialize(config);
    } catch (error) {
      console.error('Failed to initialize app:', error);
      const fallbackConfig = {
        supabaseUrl: '',
        supabaseKey: '',
        togetherApiKey: '',
        hhClientId: '',
        hhClientSecret: '',
        superJobClientId: '',
        superJobClientSecret: '',
        habrClientId: '',
        habrClientSecret: '',
        yookassaShopId: '',
        yookassaSecretKey: '',
        demoMode: false,
        analytics: {
          googleAnalyticsId: '',
          yandexMetrikaId: '',
          microsoftClarityId: '',
          hotjarId: '',
        }

      };
      await supabaseService.initialize(fallbackConfig);
    }
  };
}

export function initializeTranslation(
  translate: TranslateService, 
  languageService: LanguageService
) {
  return () => {
    const defaultLang = languageService.getLanguage();
    translate.setDefaultLang('en');
    translate.use(defaultLang);
  };
}

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(withInterceptorsFromDi()),
    {
      provide: APP_INITIALIZER,
      useFactory: initializeApp,
      deps: [ConfigService, SupabaseService],
      multi: true
    },
    {
      provide: APP_INITIALIZER,
      useFactory: initializeTranslation,
      deps: [TranslateService, LanguageService],
      multi: true
    },
    { 
      provide: HTTP_INTERCEPTORS, 
      useClass: AuthInterceptor, 
      multi: true,
    },
    provideAnimationsAsync(),
    providePrimeNG(
      {
        theme: {
          preset: Aura
        }
      }
    ),
    provideZoneChangeDetection({ eventCoalescing: true }),
    MarkdownService,
    MessageService,
    { provide: SECURITY_CONTEXT, useValue: 0 },
    provideTranslateService({
      loader: provideTranslateHttpLoader({
        prefix: '/locale/messages.',
        suffix: '.json'
      })
    }),
    provideRouter(routes),
    provideHttpClient(withInterceptorsFromDi()),
    {
      provide: APP_INITIALIZER,
      useFactory: initializeApp,
      deps: [ConfigService, SupabaseService],
      multi: true
    },
    {
      provide: APP_INITIALIZER,
      useFactory: initializeTranslation,
      deps: [TranslateService, LanguageService],
      multi: true
    },
    { 
      provide: HTTP_INTERCEPTORS, 
      useClass: AuthInterceptor, 
      multi: true,
    },
    provideAnimationsAsync(),
    providePrimeNG(
      {
        theme: {
          preset: Aura
        }
      }
    ),
    provideZoneChangeDetection({ eventCoalescing: true }),
    MarkdownService,
    MessageService,
    { provide: SECURITY_CONTEXT, useValue: 0 },
    provideTranslateService({
      loader: provideTranslateHttpLoader({
        prefix: '/locale/messages.',
        suffix: '.json'
      })
    })
  ]
};

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\app.html ---

<app-personal-data-consent></app-personal-data-consent>
<app-cookies-consent></app-cookies-consent>

<p-menubar [model]="items">
  @if(supabase.currentUser) {
  <ng-template pTemplate="end">
    <div class="user-info">
      <app-notification-bell></app-notification-bell>

      <div class="ai-config-button">
        <button 
          pButton 
          [icon]="aiGuard.checkAIConfigured() ? 'pi pi-android' : 'pi pi-android'" 
          class="p-button-text ai-trigger"
          (click)="showAIConfigModal = true"
          [pTooltip]="getAIStatusTooltip()" 
          tooltipPosition="left">
          <div class="ai-status-indicator" 
               [class.connected]="aiGuard.checkAIConfigured()"></div>
        </button>
      </div>

      <div class="language-selector">
        <button 
          pButton 
          icon="pi pi-globe" 
          class="p-button-text language-trigger"
          (click)="toggleLanguageDropdown()"
          [pTooltip]="'LANGUAGE.SELECT' | translate"
          tooltipPosition="left">
        </button>

        <div class="language-dropdown" [class.show]="showLanguageDropdown">
          <div class="dropdown-header">
            <span>{{ 'LANGUAGE.CHOOSE' | translate }}</span>
          </div>
          <div class="language-list">
            @for(lang of availableLanguages; track lang.code) {
              <div 
                class="language-item" 
                [class.active]="currentLang === lang.code"
                (click)="changeLanguage(lang.code)"
                [pTooltip]="lang.countryCode"
                tooltipPosition="left">
                <i [class]="lang.flag" class="flag-icon"></i>
                <span class="language-name">{{ lang.name }}</span>
              </div>
            }
          </div>
        </div>
      </div>

      <p-avatar [image]="userAvatar" size="normal" shape="circle" styleClass="mr-2"></p-avatar>
      <span class="mr-3">{{ userName }}</span>
      <button 
        pButton 
        icon="pi pi-sign-out" 
        class="p-button-rounded p-button-text" 
        (click)="signOut()"
        [pTooltip]="'TOOLTIP.SIGNOUT_BUTTON' | translate" 
        tooltipPosition="left">
      </button>
    </div>
  </ng-template>
  }
</p-menubar>

<router-outlet />
<app-error-toast></app-error-toast>

<p-dialog 
  header="{{ 'AI_CONFIG.MODAL_TITLE' | translate }}" 
  [(visible)]="showAIConfigModal" 
  [modal]="true"
  [style]="{ width: '70vw', maxWidth: '900px' }">
  
  <app-ai-config-modal 
    (closed)="showAIConfigModal = false">
  </app-ai-config-modal>
</p-dialog>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\app.routes.ts ---

import { Routes } from '@angular/router';
import { AuthGuard } from './shared/guards/auth.guard';
import { LoggedInGuard } from './shared/guards/logged-in.guard';
import { CoverLetterGenerateComponent } from './components/Generation/cover-letter-generate/cover-letter-generate.component';
import { InterviewPrepComponent } from './components/Generation/interview-prep/interview-prep.component';
import { ResumeGenerationComponent } from './components/Generation/resume-generation/resume-generation.component';
import { VacancySearchComponent } from './components/Helpers/vacancy-search/vacancy-search.component';
import { LoginComponent } from './components/Pages/auth/login/login.component';
import { HomeComponent } from './components/Pages/home/home.component';
import { NotFoundComponent } from './components/Pages/not-found/not-found.component';
import { JobPlatformsComponent } from './components/Platforms/job-platforms/job-platforms.component';
import { PricingPlansComponent } from './components/Billing/pricing-plans/pricing-plans.component';
import { SubscriptionManagementComponent } from './components/Billing/subscription-management/subscription-management.component';
import { PaymentSuccessComponent } from './components/Billing/payment-success/payment-success.component';
import { RequisitesPageComponent } from './components/Pages/requisites-page/requisites-page.component';
import { TermsOfServiceComponent } from './components/Pages/terms-of-service/terms-of-service.component';
import { PrivacyPolicyComponent } from './components/Pages/privacy-policy/privacy-policy.component';
import { PublicOfferComponent } from './components/Pages/public-offer/public-offer.component';
import { NotificationSettingsComponent } from './components/Notifications/notification-settings/notification-settings.component';

export const routes: Routes = [
  {
    path: '',
    component: HomeComponent
  },
  {
    path: 'login',
    component: LoginComponent,
    canActivate: [LoggedInGuard]
  },
  {
    path: 'profile',
    loadChildren: () => import('./components/Pages/profile/profile-module').then(m => m.ProfileModule),
    canActivate: [AuthGuard]
  },
  {
    path: '',
    loadChildren: () => import('./components/Pages/about/about-module').then(m => m.AboutModule),
  },
  {
    path: 'interview-prep',
    component: InterviewPrepComponent,
    canActivate: [AuthGuard]
  },
  {
    path: 'vacancy-search',
    component: VacancySearchComponent,
    canActivate: [AuthGuard]
  },
  {
    path: 'resume-generation',
    component: ResumeGenerationComponent,
    canActivate: [AuthGuard]
  },
  {
    path: 'cover-letter/generate',
    component: CoverLetterGenerateComponent,
    canActivate: [AuthGuard]
  },
  { 
    path: 'auth/callback', 
    component: JobPlatformsComponent,
    canActivate: [AuthGuard]
  },
  { 
    path: 'auth/superjob-callback', 
    component: JobPlatformsComponent,
    canActivate: [AuthGuard]
  },
  { 
    path: 'auth/habr-callback', 
    component: JobPlatformsComponent,
    canActivate: [AuthGuard]
  },
  // Билллинг маршруты
  {
    path: 'billing/pricing',
    component: PricingPlansComponent,
    canActivate: [AuthGuard]
  },
  {
    path: 'billing/subscription',
    component: SubscriptionManagementComponent,
    canActivate: [AuthGuard]
  },
  {
    path: 'payment/success',
    component: PaymentSuccessComponent,
    canActivate: [AuthGuard]
  },
  {
    path: 'requisites-page',
    component: RequisitesPageComponent,
  },
  {
    path: 'terms-of-service',
    component: TermsOfServiceComponent
  },
  {
    path: 'privacy-policy', 
    component: PrivacyPolicyComponent
  },
  {
    path: 'public-offer',
    component: PublicOfferComponent
  },
  {
    path: 'notifications/settings',
    component: NotificationSettingsComponent,
    canActivate: [AuthGuard]
  },
  { 
    path: '**', 
    component: NotFoundComponent 
  }
];

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\app.spec.ts ---

import { TestBed } from '@angular/core/testing';
import { App } from './app';

describe('App', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [App],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(App);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(App);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, resume');
  });
});


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\app.ts ---

import { Component, inject, Inject, Injector, OnInit, PLATFORM_ID, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NavigationEnd, NavigationError, NavigationStart, Router, RouterModule, RouterOutlet } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { MarkdownModule } from 'ngx-markdown';
import { MenuItem } from 'primeng/api';
import { MenubarModule } from 'primeng/menubar';
import { SupabaseService } from './shared/db/supabase.service';
import { AvatarModule } from 'primeng/avatar';
import { TranslateService, TranslatePipe } from "@ngx-translate/core";
import { TooltipModule } from 'primeng/tooltip';
import { filter, take } from 'rxjs';
import { AppStateService } from './shared/state/app-state.service';
import { LanguageService } from './shared/utils/language.service';
import { SelectModule } from "primeng/select";
import { FormsModule } from '@angular/forms';
import { PopoverModule } from 'primeng/popover';
import { HostListener } from '@angular/core';
import { ErrorToastComponent } from "./components/Helpers/error-toast/error-toast.component";
import { ErrorHandlerService } from './shared/error-handler.service';
import { DialogModule } from "primeng/dialog";
import { AiConfigModalComponent } from "./components/Pages/ai-config-modal/ai-config-modal.component";
import { AIGuardService } from './shared/ai/ai-guard.service';
import { PersonalDataConsentComponent } from "./components/Pages/personal-data-consent/personal-data-consent.component";
import { CookiesConsentComponent } from "./components/Pages/cookies-consent/cookies-consent.component";
import { AnalyticsService } from './shared/analytics.service';
import { NotificationBellComponent } from './components/Notifications/notification-bell/notification-bell.component';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    CommonModule,
    ButtonModule,
    FormsModule,
    RouterModule,
    MarkdownModule,
    MenubarModule,
    ButtonModule,
    AvatarModule,
    TooltipModule,
    TranslatePipe,
    SelectModule,
    PopoverModule,
    AiConfigModalComponent,
    DialogModule,
    ErrorToastComponent,
    PersonalDataConsentComponent,
    CookiesConsentComponent,
    NotificationBellComponent
],
  templateUrl: './app.html',
  styleUrl: './app.scss'
})
export class App implements OnInit {
  @ViewChild(ErrorToastComponent) errorToast!: ErrorToastComponent;
  private translate = inject(TranslateService);
  private appStateService = inject(AppStateService);
  protected title = 'resume';
  items: MenuItem[] = [];
  private languageService = inject(LanguageService);
  currentLang: string = 'en';
  availableLanguages: any[] = [];
  showLanguageDropdown: boolean = false;
  showAIConfigModal = false;
  currentAIProvider: string = 'Не настроен';

  constructor(
    public supabase: SupabaseService,
    private analyticsService: AnalyticsService,
    private router: Router,
    @Inject(PLATFORM_ID) private platformId: Object,
    private errorHandler: ErrorHandlerService,
    public aiGuard: AIGuardService,
    private injector: Injector
  ) {
    this.setupNavigationHandling();
    this.setupErrorHandling();
  }

  private setupErrorHandling(): void {
    this.router.events.subscribe(event => {
      if (event instanceof NavigationError) {
        console.error('Navigation Error:', event.error);
      }
    });
  }

  @HostListener('document:click', ['$event'])
  onDocumentClick(event: MouseEvent): void {
    const target = event.target as HTMLElement;
    const languageSelector = document.querySelector('.language-selector');
    
    if (languageSelector && !languageSelector.contains(target)) {
      this.showLanguageDropdown = false;
    }
  }
  
  ngOnInit(): void {
    this.initializeLanguages();
    this.currentLang = this.translate.currentLang || this.languageService.getLanguage();
    
    // Подписываемся на изменения текущего AI провайдера
    this.aiGuard.getCurrentProviderNameObservable().subscribe(provider => {
      this.currentAIProvider = provider;
    });
    
    this.restoreAppState();
    
    this.translate.onLangChange.subscribe(() => {
      this.items = this.buildMenu();
      this.currentLang = this.translate.currentLang;
    });
    
    this.supabase.initialized$.pipe(
      filter(initialized => initialized),
      take(1)
    ).subscribe(() => {
      this.items = this.buildMenu();
      this.restoreNavigation();
    });
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe((event: NavigationEnd) => {
      this.analyticsService.trackPageView(
        this.getPageTitle(event.url),
        event.url
      );
    });
  }

  private getPageTitle(url: string): string {
    const routes: {[key: string]: string} = {
      '/': 'Главная',
      '/resume-generation': 'Генерация резюме',
      '/cover-letter/generate': 'Сопроводительное письмо',
      '/interview-prep': 'Подготовка к собеседованию',
      '/vacancy-search': 'Поиск вакансий',
      '/billing/pricing': 'Тарифы',
      '/profile/view': 'Профиль'
    };
    return routes[url] || 'Rezulution';
  }
  
  getAIStatusTooltip(): string {
    if (this.currentAIProvider === 'Не настроен') {
      return this.translate.instant('AI_CONFIG.NOT_CONFIGURED_TOOLTIP');
    }
    return this.translate.instant('AI_CONFIG.CURRENT_PROVIDER_TOOLTIP', { 
      provider: this.currentAIProvider 
    });
  }

  getAIIconColor(): string {
    return this.aiGuard.checkAIConfigured() ? 'var(--green-500)' : 'var(--red-500)';
  }

  // Остальные методы без изменений...
  private initializeLanguages(): void {
    this.availableLanguages = [
      {
        code: 'en',
        name: 'English',
        flag: 'pi pi-flag-fill',
        countryCode: 'US',
        countryName: 'United States',
        tooltip: 'EN - English'
      },
      {
        code: 'ru', 
        name: 'Русский',
        flag: 'pi pi-flag-fill',
        countryCode: 'RU',
        countryName: 'Russia',
        tooltip: 'RU - Русский'
      },
    ];
  }

  toggleLanguageDropdown(): void {
    this.showLanguageDropdown = !this.showLanguageDropdown;
  }

  changeLanguage(lang: string): void {
    this.translate.use(lang);
    this.languageService.setLanguage(lang);
    this.currentLang = lang;
    this.showLanguageDropdown = false;
  }

  getCurrentLanguage(): any {
    return this.availableLanguages.find(lang => lang.code === this.currentLang);
  }

  private setupNavigationHandling(): void {
    this.router.events.subscribe(event => {
      if (event instanceof NavigationStart) {
        this.saveAppState();
      }
    });
  }

  private saveAppState(): void {
    const state = {
      menuItems: this.items,
      user: this.supabase.currentUser ? {
        id: this.supabase.currentUser.id,
        email: this.supabase.currentUser.email
      } : null
    };
    
    this.appStateService.saveState(state);
  }

  private restoreAppState(): void {
    const savedState = this.appStateService.getState();
    if (savedState) {
      this.items = savedState.menuItems || [];
    }
  }

  private restoreNavigation(): void {
    const savedState = this.appStateService.getState();
    const lastUrl = this.appStateService.getLastUrl();
    
    if (savedState.user && lastUrl && this.router.url === '/') {
      const allowedRoutes = [
        '/resume-generation',
        '/cover-letter',
        '/interview-prep', 
        '/vacancy-search',
        '/job-platforms',
        '/about'
      ];
      
      if (lastUrl && allowedRoutes.some(route => lastUrl.startsWith(route))) {
        setTimeout(() => {
          this.router.navigateByUrl(lastUrl, { replaceUrl: true });
        }, 100);
      }
    }
  }

  private buildMenu(): MenuItem[] {
    return [
      {
        label: this.translate.instant('MAIN_MENU.PROFILE.name'),
        items: [
          { 
            label: this.translate.instant('MAIN_MENU.PROFILE.VIEW'), 
            routerLink: '/profile/view'
          },
          { 
            label: this.translate.instant('MAIN_MENU.PROFILE.EDIT'), 
            routerLink: '/profile/edit'
          },
          {
            label: this.translate.instant('BILLING.MANAGE_SUBSCRIPTION'),
            routerLink: '/billing/subscription',
          }
        ]
      },
      {
        label: this.translate.instant('MAIN_MENU.RESUME.name'),
        items: [
          { 
            label: this.translate.instant('MAIN_MENU.RESUME.GENERATE_RESUME'), 
            routerLink: '/resume-generation'
          },
          { 
            label: this.translate.instant('MAIN_MENU.PROFILE.GENERATE_COVER_LETTER'), 
            routerLink: '/cover-letter/generate'
          }
        ]
      },
      {
        label: this.translate.instant('MAIN_MENU.JOB_PLATFORMS.name'),
        routerLink: '/auth/callback'
      },
      {
        label: this.translate.instant('MAIN_MENU.VACANCY_SEARCH.name'),
        routerLink: '/vacancy-search'
      },
      {
        label: this.translate.instant('MAIN_MENU.INTERVIEW.name'),
        routerLink: '/interview-prep'
      },
      {
        label: this.translate.instant('MAIN_MENU.ABOUT.name'),
        routerLink: '/about'
      },
      {
        label: this.translate.instant('BILLING.TARIFS'),
        routerLink: '/billing/pricing',
      },
      // {
      //   label: 'Избранное',
      //   icon: 'pi pi-heart',
      //   routerLink: '/vacancy-search',
      //   queryParams: { section: 'favorites' }
      // }
    ];
  }

  get userAvatar(): string {
    return this.supabase.currentUser?.user_metadata?.['avatar_url'] || 'default_avatar.jpg';
  }

  get userName(): string {
    return this.supabase.currentUser?.user_metadata?.['full_name'] || this.supabase.currentUser?.email || '';
  }
  
  async signOut() {
    this.appStateService.clearState();
    await this.supabase.signOut();
    this.items = [];
  }

  ngAfterViewInit() {
    console.log('Registering ErrorToastComponent...');
    this.errorHandler.registerErrorToast(this.errorToast);
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\person-schema.ts ---

import { z } from 'zod';

// Валидаторы на основе вашего JSON Schema
const phoneSchema = z.string().regex(/^\+[0-9]{11}$/).optional();
const emailSchema = z.string().email();
const languageLevelSchema = z.string().regex(/^[A-C][1-2]$/);
const dateSchema = z.string().regex(/^\d{4}-\d{2}-\d{2}$/); // YYYY-MM-DD

const contactSchema = z.object({
  phone: phoneSchema,
  email: emailSchema,
}).catchall(z.string().url().optional().or(z.literal('')));

const locationSchema = z.object({
  country: z.string().optional(),
  city: z.string(),
  relocation: z.boolean(),
  remote: z.boolean(),
  business_trips: z.boolean(),
});

const languageSchema = z.object({
  language: z.string(),
  level: languageLevelSchema,
});

const skillSchema = z.object({
  area: z.string(),
  name: z.string(),
  level: z.number().int().min(1).max(10),
  date: dateSchema, // Строка в формате YYYY-MM-DD
});

const educationSchema = z.object({
  institution: z.string(),
  degree: z.string(),
  specialty: z.string(),
  year: z.number().int(),
});

const achievementSchema = z.object({
  name: z.string(),
  initial_value: z.number(),
  final_value: z.number(),
  uom: z.enum(['day', 'percent']).optional(),
  type: z.enum(['increased', 'decreased']).optional(),
});

const experienceSchema = z.object({
  company: z.string(),
  position: z.string(),
  startDate: dateSchema, // Используем startDate вместо from-date
  endDate: dateSchema.optional().nullable(), // Используем endDate вместо to-date
  tasks: z.array(z.string()),
  stack: z.array(z.string()),
  achievements: z.array(achievementSchema),
});

const personSchema = z.object({
  person: z.object({
    name: z.string(),
    gender: z.enum(['male', 'female', 'unknown']),
    desiredPositions: z.array(z.string()).optional(),
    contact: contactSchema,
    location: locationSchema,
    languages: z.array(languageSchema),
    skills: z.array(skillSchema),
    education: z.array(educationSchema),
    hobby: z.array(z.string()).optional(),
    literature: z.array(z.string()).optional(),
    experience: z.array(experienceSchema),
  }),
});

type Contact = z.infer<typeof contactSchema>;
type Location = z.infer<typeof locationSchema>;
type Language = z.infer<typeof languageSchema>;
type Skill = z.infer<typeof skillSchema>;
type Education = z.infer<typeof educationSchema>;
type Achievement = z.infer<typeof achievementSchema>;
type Experience = z.infer<typeof experienceSchema>;
type Person = z.infer<typeof personSchema>['person'];
type PersonSchema = z.infer<typeof personSchema>;

export {
  personSchema,
  contactSchema,
  locationSchema,
  languageSchema,
  skillSchema,
  educationSchema,
  experienceSchema,
  achievementSchema,
  type Person,
  type PersonSchema,
  type Contact,
  type Location,
  type Language,
  type Skill,
  type Education,
  type Experience,
  type Achievement,
};

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\vacancy-schema.ts ---

import { z } from 'zod';

const employerSchema = z.object({
  id: z.string().optional(),
  name: z.string(),
  url: z.string().url().optional(),
  logo_urls: z.object({
    original: z.string().url().optional(),
  }).optional(),
});

const skillSchema = z.object({
  name: z.string(),
});

const salarySchema = z.object({
  from: z.number().nullable().optional(),
  to: z.number().nullable().optional(),
  currency: z.string().optional(),
  gross: z.boolean().optional(),
});

const addressSchema = z.object({
  city: z.string().optional(),
  street: z.string().optional(),
  building: z.string().optional(),
  lat: z.number().optional(),
  lng: z.number().optional(),
  description: z.string().optional(),
});

const professionalRoleSchema = z.object({
  id: z.string(),
  name: z.string(),
});

const vacancySchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  key_skills: z.array(skillSchema),
  employer: employerSchema,
  salary: salarySchema.optional().nullable(),
  address: addressSchema.optional().nullable(),
  area: z.object({
    id: z.string().optional(),
    name: z.string().optional()
  }).optional(),
  experience: z.object({
    id: z.string().optional(),
    name: z.string().optional()
  }).optional(),
  employment: z.object({
    id: z.string().optional(),
    name: z.string().optional()
  }).optional(),
  schedule: z.object({
    id: z.string().optional(),
    name: z.string().optional()
  }).optional(),
  professional_roles: z.array(professionalRoleSchema).optional(),
  published_at: z.string().datetime().optional(),
  alternate_url: z.string().url().optional(),
  snippet: z.object({
    requirement: z.string().optional(),
    responsibility: z.string().optional()
  }).optional(),
  platform: z.string().optional()
});

type Employer = z.infer<typeof employerSchema>;
type Skill = z.infer<typeof skillSchema>;
type Salary = z.infer<typeof salarySchema>;
type Address = z.infer<typeof addressSchema>;
type ProfessionalRole = z.infer<typeof professionalRoleSchema>;
type Vacancy = z.infer<typeof vacancySchema>;

export {
  employerSchema,
  skillSchema,
  salarySchema,
  addressSchema,
  professionalRoleSchema,
  vacancySchema,
  type Employer,
  type Skill,
  type Salary,
  type Address,
  type ProfessionalRole,
  type Vacancy,
};

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Billing\payment-success\payment-success.component.html ---

<div class="payment-success-container">
    <div class="payment-content">
      <div *ngIf="isLoading" class="loading">
        <p-progressSpinner></p-progressSpinner>
        <p>{{ 'BILLING.PROCESSING_PAYMENT' | translate }}</p>
      </div>
  
      <div *ngIf="!isLoading && isSuccess" class="success-content">
        <div class="success-icon">
          <i class="pi pi-check-circle"></i>
        </div>
        
        <h1>{{ 'BILLING.PAYMENT_SUCCESS_TITLE' | translate }}</h1>
        
        <p class="success-message" [innerHTML]="'BILLING.PAYMENT_SUCCESS_MESSAGE' | translate: { planName: planName }">
        </p>
  
        <div class="success-actions">
          <button pButton 
                  [label]="'BILLING.GO_TO_PROFILE' | translate"
                  icon="pi pi-user"
                  (click)="goToDashboard()"
                  class="p-button-primary">
          </button>
          
          <button pButton 
                  [label]="'BILLING.GO_TO_SUBSCRIPTION' | translate"
                  icon="pi pi-cog"
                  (click)="goToSubscription()"
                  class="p-button-outlined">
          </button>
        </div>
      </div>
  
      <div *ngIf="!isLoading && !isSuccess" class="error-content">
        <div class="error-icon">
          <i class="pi pi-times-circle"></i>
        </div>
        
        <h1>{{ 'BILLING.PAYMENT_ERROR_TITLE' | translate }}</h1>
        
        <p class="error-message">
          {{ 'BILLING.PAYMENT_ERROR_MESSAGE' | translate }}
        </p>
  
        <div class="error-actions">
          <button pButton 
                  [label]="'BILLING.GO_TO_PLANS' | translate"
                  icon="pi pi-arrow-left"
                  (click)="goToSubscription()"
                  class="p-button-primary">
          </button>
        </div>
      </div>
    </div>
  </div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Billing\payment-success\payment-success.component.ts ---

import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { MessageService } from 'primeng/api';
import { PaymentService } from '../../../shared/billing/payment.service';
import { BillingService } from '../../../shared/billing/billing.service';
import { TranslatePipe } from '@ngx-translate/core';

@Component({
  selector: 'app-payment-success',
  templateUrl: './payment-success.component.html',
  styleUrls: ['./payment-success.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    ButtonModule,
    CardModule,
    ProgressSpinnerModule,
    TranslatePipe
  ]
})
export class PaymentSuccessComponent implements OnInit {
  isLoading = true;
  isSuccess = false;
  planName = '';

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private paymentService: PaymentService,
    private billingService: BillingService,
    private messageService: MessageService
  ) {}

  async ngOnInit() {
    const paymentId = this.route.snapshot.queryParamMap.get('paymentId');
    const planId = this.route.snapshot.queryParamMap.get('planId');

    if (paymentId && planId) {
      await this.handlePaymentSuccess(paymentId, planId);
    } else {
      this.isSuccess = false;
      this.isLoading = false;
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка',
        detail: 'Неверные параметры платежа'
      });
    }
  }

  async handlePaymentSuccess(paymentId: string, planId: string) {
    try {
      // Для бесплатного тарифа
      if (paymentId.startsWith('free_activation_')) {
        await this.paymentService.handlePaymentSuccess(paymentId, planId);
        const plan = this.billingService.getPlan(planId);
        this.planName = plan.name;
        this.isSuccess = true;
        
        this.messageService.add({
          severity: 'success',
          summary: 'Тариф активирован!',
          detail: `Тариф "${plan.name}" успешно активирован`
        });
        return;
      }

      // Проверяем статус платежа для платных тарифов
      const status = await this.paymentService.checkPaymentStatus(paymentId);
      
      if (status.status === 'succeeded') {
        await this.paymentService.handlePaymentSuccess(paymentId, planId);
        const plan = this.billingService.getPlan(planId);
        this.planName = plan.name;
        this.isSuccess = true;
        
        this.messageService.add({
          severity: 'success',
          summary: 'Оплата успешна!',
          detail: `Тариф "${plan.name}" успешно активирован`
        });
      } else {
        this.isSuccess = false;
        this.messageService.add({
          severity: 'warn',
          summary: 'Платеж обрабатывается',
          detail: 'Ваш платеж находится в обработке. Тариф будет активирован после подтверждения.'
        });
      }
    } catch (error: any) {
      this.isSuccess = false;
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка',
        detail: error.message || 'Произошла ошибка при обработке платежа'
      });
    } finally {
      this.isLoading = false;
    }
  }

  goToDashboard() {
    this.router.navigate(['/profile/view']);
  }

  goToSubscription() {
    this.router.navigate(['/billing/subscription']);
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Billing\pricing-plans\pricing-plans.component.html ---

<div class="pricing-container">
    <div class="pricing-header">
      <h1>{{ 'BILLING.PRICING_TITLE' | translate }}</h1>
      <p>{{ 'BILLING.PRICING_SUBTITLE' | translate }}</p>
    </div>
  
    <div class="pricing-cards">
      <p-card *ngFor="let plan of plans" 
              [class]="plan.popular ? 'popular-plan' : ''"
              [header]="plan.name">
        
        <div class="plan-price">
          <span class="price-amount">{{ plan.price === 0 ? 'Бесплатно' : (plan.price + ' ₽') }}</span>
          <span *ngIf="plan.price > 0" class="price-period">/месяц</span>
        </div>
  
        <p class="plan-description">{{ plan.description }}</p>
  
        <ul class="plan-features">
          <li *ngFor="let feature of plan.features">{{ feature }}</li>
        </ul>
  
        <button pButton 
                [label]="getButtonLabel(plan)"
                [class]="getButtonClass(plan)"
                [loading]="isLoading"
                (click)="selectPlan(plan)">
        </button>
  
        <div *ngIf="plan.popular" class="popular-badge">
          {{ 'BILLING.POPULAR_CHOICE' | translate }}
        </div>
      </p-card>
    </div>
  
    <p-dialog [(visible)]="showPaymentDialog" 
              [modal]="true" 
              [style]="{ width: '500px' }"
              (onHide)="closeDialog()">
      
      <ng-template pTemplate="header">
        <span class="text-xl font-bold">Оплата тарифа {{ selectedPlan?.name }}</span>
      </ng-template>
  
      <div *ngIf="selectedPlan">
        <p>Вы выбрали тариф <strong>{{ selectedPlan.name }}</strong></p>
        <p>Стоимость: <strong>{{ selectedPlan.price }} ₽</strong></p>
        <p>После оплаты тариф будет активирован автоматически.</p>
      </div>
  
      <ng-template pTemplate="footer">
        <button pButton 
                label="Отмена" 
                class="p-button-text"
                (click)="closeDialog()"></button>
        <button pButton 
                label="Перейти к оплате" 
                [loading]="isLoading"
                (click)="processPayment()"></button>
      </ng-template>
    </p-dialog>
</div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Billing\pricing-plans\pricing-plans.component.ts ---

import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { DialogModule } from 'primeng/dialog';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { MessageService } from 'primeng/api';
import { TranslatePipe, TranslateService } from '@ngx-translate/core';
import { TariffPlan } from '../../../shared/billing/billing.models';
import { BillingService } from '../../../shared/billing/billing.service';
import { PaymentService } from '../../../shared/billing/payment.service';
import { SupabaseService } from '../../../shared/db/supabase.service';
import { ConfigService } from '../../../shared/config/config.service';
import { Tag } from "primeng/tag";
import { FormsModule } from '@angular/forms';
import { AnalyticsService } from '../../../shared/analytics.service';

@Component({
  selector: 'app-pricing-plans',
  templateUrl: './pricing-plans.component.html',
  styleUrls: ['./pricing-plans.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    ButtonModule,
    FormsModule,
    CardModule,
    DialogModule,
    ProgressSpinnerModule,
    TranslatePipe
]
})
export class PricingPlansComponent implements OnInit {
  plans: TariffPlan[] = [];
  selectedPlan: TariffPlan | null = null;
  showPaymentDialog = false;
  isLoading = false;
  currentPlanId = 'free';

  constructor(
    private billingService: BillingService,
    private paymentService: PaymentService,
    private configService: ConfigService,
    private supabase: SupabaseService,
    private messageService: MessageService,
    private router: Router,
    private translate: TranslateService,
    private analyticsService: AnalyticsService
  ) {}

  ngOnInit() {
    this.plans = this.billingService.getPlans();
    this.loadCurrentSubscription();
  }

  async loadCurrentSubscription() {
    try {
      const subscription = await this.billingService.getUserSubscription();
      this.currentPlanId = subscription.planId;
    } catch (error) {
      console.error('Error loading subscription:', error);
    }
  }

  selectPlan(plan: TariffPlan) {
    this.analyticsService.trackEvent('select_plan', {
      plan_name: plan.name,
      plan_price: plan.price,
      plan_id: plan.id
    });
    if (plan.id === this.currentPlanId) {
      this.messageService.add({
        severity: 'info',
        summary: 'Это ваш текущий тариф',
        detail: `Вы уже используете тариф "${plan.name}"`
      });
      return;
    }

    if (plan.price === 0) {
      this.activateFreePlan(plan);
    } else {
      this.selectedPlan = plan;
      this.showPaymentDialog = true;
    }
  }

  async activateFreePlan(plan: TariffPlan) {
    this.isLoading = true;
    try {
      await this.billingService.activateFreePlan();
      this.currentPlanId = plan.id;
      this.messageService.add({
        severity: 'success',
        summary: 'Тариф активирован',
        detail: `Тариф "${plan.name}" успешно активирован`
      });
      this.router.navigate(['/profile/view']);
    } catch (error: any) {
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка',
        detail: error.message || 'Не удалось активировать тариф'
      });
    } finally {
      this.isLoading = false;
    }
  }

  async processPayment() {
    if (!this.selectedPlan) return;

    this.analyticsService.trackEcommerceEvent('purchase', {
      transaction_id: `order_${Date.now()}`,
      value: this.selectedPlan.price,
      currency: 'RUB',
      items: [{
        id: this.selectedPlan.id,
        name: this.selectedPlan.name,
        price: this.selectedPlan.price
      }]
    });

    this.isLoading = true;
    try {
      const result = await this.paymentService.createPayment(this.selectedPlan.id);
      
      if (result.success && result.paymentUrl) {
        window.location.href = result.paymentUrl;
      } else {
        this.messageService.add({
          severity: 'error',
          summary: 'Ошибка оплаты',
          detail: result.error || 'Не удалось создать платеж'
        });
      }
    } catch (error: any) {
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка',
        detail: error.message || 'Произошла ошибка при обработке платежа'
      });
    } finally {
      this.isLoading = false;
      this.showPaymentDialog = false;
    }
  }


  getButtonClass(plan: TariffPlan): string {
    if (plan.id === this.currentPlanId) {
      return 'p-button-outlined';
    }
    return plan.popular ? 'p-button-primary' : 'p-button-outlined';
  }

  closeDialog() {
    this.showPaymentDialog = false;
    this.selectedPlan = null;
  }

  getPaymentInfoText(): string {
    return this.translate.instant('BILLING.PAYMENT_INFO');
  }
  
  getButtonLabel(plan: any): string {
    if (this.isLoading) {
      return '';
    }
    if (plan.id === this.currentPlanId) {
      return this.translate.instant('BILLING.CURRENT_PLAN_BADGE');
    }
    if (plan.price === 0) {
      return this.translate.instant('BILLING.ACTIVATE_FREE');
    }
    return this.translate.instant('BILLING.SELECT_PLAN');
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Billing\subscription-management\subscription-management.component.html ---

<div class="subscription-management">
    <div class="header">
      <h2>{{ 'BILLING.SUBSCRIPTION_MANAGEMENT' | translate }}</h2>
      <p>{{ 'BILLING.SUBSCRIPTION_INFO' | translate }}</p>
    </div>
  
    <div *ngIf="isLoading" class="loading">
      <p-progressSpinner></p-progressSpinner>
      <p>{{ 'BILLING.LOADING_SUBSCRIPTION' | translate }}</p>
    </div>
  
    <div *ngIf="!isLoading && currentSubscription && currentPlan" class="content">
      <!-- Текущий план -->
      <p-card [header]="'BILLING.CURRENT_PLAN' | translate" class="plan-card">
        <div class="plan-info">
          <div class="plan-details">
            <h3>{{ currentPlan.name }}</h3>
            <p class="plan-description">{{ currentPlan.description }}</p>
            
            <div class="plan-period" *ngIf="!isTrial()">
              <span>{{ 'BILLING.VALID_UNTIL' | translate }} {{ currentSubscription.currentPeriodEnd | date:'dd.MM.yyyy' }}</span>
              <span class="days-remaining">{{ 'BILLING.DAYS_REMAINING' | translate: { days: getDaysRemaining() } }}</span>
            </div>
  
            <div class="plan-period" *ngIf="isTrial()">
              <span>{{ 'BILLING.FREE' | translate }}</span>
              <span class="trial-info">{{ 'BILLING.TRIAL_INFO' | translate }}</span>
            </div>
          </div>
  
          <div class="plan-actions">
            <button pButton 
                    [label]="'BILLING.UPGRADE_PLAN' | translate"
                    icon="pi pi-arrow-right"
                    (click)="upgradePlan()"
                    class="p-button-outlined">
            </button>
          </div>
        </div>
      </p-card>
  
      <!-- Использование -->
      <p-card [header]="'BILLING.USAGE_TODAY' | translate" class="usage-card">
        <div class="usage-stats">
          <div *ngFor="let stat of usageStats" class="usage-item">
            <div class="usage-header">
              <span class="usage-feature">{{ stat.feature }}</span>
              <span class="usage-count">
                {{ stat.used }}{{ stat.limit === -1 ? '' : '/' + stat.limit }}
              </span>
            </div>
            
            <p-progressBar 
              *ngIf="stat.limit !== -1"
              [value]="getProgressPercentage(stat.used, stat.limit)"
              [showValue]="false"
              [styleClass]="'usage-progress ' + getProgressSeverity(stat.used, stat.limit)">
            </p-progressBar>
  
            <div class="usage-limit" *ngIf="stat.limit === -1">
              <i class="pi pi-infinity"></i>
              <span>{{ 'BILLING.UNLIMITED_ACCESS' | translate }}</span>
            </div>
  
            <div class="usage-remaining" *ngIf="stat.limit !== -1">
              {{ 'BILLING.REMAINING' | translate }}: {{ stat.remaining }} {{ 'OF' | translate }} {{ stat.limit }}
            </div>
          </div>
        </div>
      </p-card>
  
      <p-card [header]="'BILLING.PLAN_FEATURES' | translate" class="features-card">
        <ul class="features-list">
          <li *ngFor="let feature of currentPlan.features" class="feature-item">
            <i class="pi pi-check"></i>
            <span>{{ feature }}</span>
          </li>
        </ul>
      </p-card>
    </div>
  </div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Billing\subscription-management\subscription-management.component.ts ---

import { Component, OnInit, Inject, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { ProgressBarModule } from 'primeng/progressbar';
import { MessageService } from 'primeng/api';
import { TranslatePipe } from '@ngx-translate/core';
import { BillingService } from '../../../shared/billing/billing.service';
import { UsageService } from '../../../shared/billing/usage.service';
import { TariffPlan, UserSubscription } from '../../../shared/billing/billing.models';
import { ProgressSpinner } from "primeng/progressspinner";

@Component({
  selector: 'app-subscription-management',
  templateUrl: './subscription-management.component.html',
  styleUrls: ['./subscription-management.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    ButtonModule,
    CardModule,
    ProgressBarModule,
    ProgressSpinner,
    TranslatePipe
  ]
})
export class SubscriptionManagementComponent implements OnInit, OnDestroy {
  currentSubscription: UserSubscription | null = null;
  currentPlan: TariffPlan | null = null;
  usageStats: any[] = [];
  isLoading = true;

  constructor(
    private billingService: BillingService,
    private usageService: UsageService,
    private messageService: MessageService,
    private router: Router
  ) {
    console.log('SubscriptionManagementComponent constructor');
  }

  async ngOnInit() {
    console.log('SubscriptionManagementComponent ngOnInit');
    try {
      await this.loadSubscriptionData();
    } catch (error) {
      console.error('Error in ngOnInit:', error);
      this.isLoading = false;
    }
  }

  async loadSubscriptionData() {
    try {
      console.log('Loading subscription data...');
      
      this.currentSubscription = await this.billingService.getUserSubscription();
      console.log('Current subscription:', this.currentSubscription);
      
      this.currentPlan = this.billingService.getCurrentPlan();
      console.log('Current plan:', this.currentPlan);
      
      this.usageStats = await this.usageService.getUsageStats();
      console.log('Usage stats:', this.usageStats);
      
    } catch (error) {
      console.error('Error loading subscription data:', error);
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка',
        detail: 'Не удалось загрузить данные подписки'
      });
    } finally {
      this.isLoading = false;
    }
  }

  getProgressPercentage(used: number, limit: number): number {
    if (limit === -1) return 0;
    if (used >= limit) return 100;
    return (used / limit) * 100;
  }

  getProgressSeverity(used: number, limit: number): string {
    if (limit === -1) return 'success';
    const percentage = (used / limit) * 100;
    if (percentage >= 90) return 'danger';
    if (percentage >= 70) return 'warn';
    return 'success';
  }

  upgradePlan() {
    this.router.navigate(['/billing/pricing']);
  }

  getDaysRemaining(): number {
    if (!this.currentSubscription) return 0;
    const end = new Date(this.currentSubscription.currentPeriodEnd);
    const now = new Date();
    const diff = end.getTime() - now.getTime();
    return Math.ceil(diff / (1000 * 60 * 60 * 24));
  }

  isTrial(): boolean {
    return this.currentPlan?.id === 'free';
  }

  ngOnDestroy() {
    console.log('SubscriptionManagementComponent destroyed');
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Generation\cover-letter-generate\cover-letter-generate.component.html ---

<div class="cover-letter-container">
  <p-card [header]="'COVER_LETTER.TITLE' | translate">
    <form [formGroup]="coverLetterForm" (ngSubmit)="generateCoverLetter()">
      <div class="field">
        <label>{{ 'COVER_LETTER.SELECT_RESUME' | translate }}</label>
        
        <div class="resume-selection">
          <button pButton 
                  type="button"
                  [label]="'RESUME_SELECTOR.TITLE' | translate"
                  icon="pi pi-briefcase"
                  (click)="openResumeSelector()"
                  class="p-button-outlined">
          </button>

          <div *ngIf="selectedResumeFromSelector" class="selected-resume-info">
            <div class="resume-details">
              <i [class]="getPlatformIcon(selectedResumeFromSelector.platform)"></i>
              <span class="resume-title">{{ selectedResumeFromSelector.title }}</span>
              <span class="resume-platform">({{ getPlatformLabelForSelector(selectedResumeFromSelector.platform) }})</span>
            </div>
            <button pButton 
                    icon="pi pi-times" 
                    class="p-button-text p-button-danger"
                    (click)="selectedResumeFromSelector = null; resumeContent = ''">
            </button>
          </div>
        </div>
      </div>

      <div class="field">
        <label for="vacancy_id">{{ 'COVER_LETTER.VACANCY_ID' | translate }} *</label>
        <div class="vacancy-selection">
          <button pButton 
                  type="button"
                  [label]="'VACANCY_SELECTOR.TITLE' | translate"
                  icon="pi pi-briefcase"
                  (click)="openVacancySelector()"
                  class="p-button-outlined">
          </button>
      
          <div *ngIf="selectedVacancyFromSelector" class="selected-vacancy-info">
            <div class="vacancy-details">
              <i [class]="getPlatformIcon(selectedVacancyFromSelector.platform)"></i>
              <span class="vacancy-title">{{ selectedVacancyFromSelector.name }}</span>
              <span class="vacancy-platform">({{ getPlatformLabelForSelector(selectedVacancyFromSelector.platform) }})</span>
              <span class="vacancy-company">{{ selectedVacancyFromSelector.employer?.name }}</span>
            </div>
            <button pButton 
                    icon="pi pi-times" 
                    class="p-button-text p-button-danger"
                    (click)="clearSelectedVacancy()">
            </button>
          </div>
        </div>
      </div>

      <div class="field">
        <label for="style">{{ 'COVER_LETTER.STYLE' | translate }}</label>
        <p-select 
          id="style"
          [options]="styleOptions" 
          formControlName="style"
          [placeholder]="'COVER_LETTER.STYLE_PLACEHOLDER' | translate">
        </p-select>
      </div>

      <div class="field">
        <label for="tone">{{ 'COVER_LETTER.TONE' | translate }}</label>
        <p-select 
          id="tone"
          [options]="toneOptions" 
          formControlName="tone"
          [placeholder]="'COVER_LETTER.TONE_PLACEHOLDER' | translate">
        </p-select>
      </div>

      <div class="form-actions">
        <button 
          pButton 
          type="submit" 
          [label]="'COVER_LETTER.GENERATE' | translate" 
          icon="pi pi-file-edit"
          [disabled]="isLoading || coverLetterForm.invalid">
        </button>

        <button 
          pButton 
          type="button" 
          [label]="'BUTTON.SETTINGS' | translate" 
          icon="pi pi-cog"
          class="p-button-secondary"
          (click)="showTemplateDialog = true">
        </button>
      </div>
    </form>

    <div *ngIf="generatedLetter" class="result-section">
      <h3>{{ 'COVER_LETTER.GENERATED_LETTER' | translate }}</h3>
      
      <div class="letter-meta">
        <span>{{ 'COVER_LETTER.STYLE' | translate }}: {{ getStyleLabel(generatedLetter.style) }}</span>
        <span>{{ 'COVER_LETTER.TONE' | translate }}: {{ getToneLabel(generatedLetter.tone) }}</span>
        <span>{{ 'GENERATED_AT' | translate }}: {{ generatedLetter.generated_at | date:'medium' }}</span>
      </div>

      <div class="letter-content">
        <textarea 
          pInputTextarea 
          [rows]="15" 
          [(ngModel)]="generatedLetter.content"
          [ngModelOptions]="{standalone: true}"
          style="width: 100%">
        </textarea>
      </div>

      <div class="letter-actions">
          <button 
              pButton 
              [label]="'BUTTON.SEND_TO_JOB_PLATFORMS' | translate" 
              icon="pi pi-send"
              [disabled]="isSending"
              (click)="sendToHH()">
              <p-progressSpinner *ngIf="isSending" 
                              [style]="{'width': '20px', 'height': '20px'}" 
                              strokeWidth="4"
                              styleClass="absolute">
              </p-progressSpinner>
          </button>

        <button 
          pButton 
          [label]="'BUTTON.EDIT' | translate" 
          icon="pi pi-pencil"
          class="p-button-secondary"
          (click)="editLetter()">
        </button>

        <button 
          pButton 
          [label]="'BUTTON.SAVE_TEMPLATE' | translate" 
          icon="pi pi-save"
          class="p-button-help"
          (click)="saveAsTemplate()">
        </button>

        <button 
          pButton 
          [label]="'BUTTON.COPY' | translate" 
          icon="pi pi-copy"
          class="p-button-info"
          (click)="copyToClipboard()">
        </button>
      </div>
    </div>

    <div *ngIf="isLoading" class="loading-section">
      <p-progressSpinner></p-progressSpinner>
      <p>{{ 'COVER_LETTER.GENERATING' | translate }}</p>
    </div>
  </p-card>

  <p-dialog 
    [header]="'COVER_LETTER.EDIT_DIALOG_TITLE' | translate" 
    [(visible)]="showTemplateDialog" 
    [modal]="true"
    [style]="{ width: '70vw' }">
    
    <div *ngIf="generatedLetter">
      <textarea 
        pInputTextarea 
        [rows]="15" 
        [(ngModel)]="generatedLetter.content"
        style="width: 100%">
      </textarea>
    </div>

    <ng-template pTemplate="footer">
      <button 
        pButton 
        [label]="'BUTTON.SAVE_CHANGES' | translate" 
        icon="pi pi-check"
        (click)="showTemplateDialog = false">
      </button>
      <button 
        pButton 
        [label]="'BUTTON.CANCEL' | translate" 
        icon="pi pi-times"
        class="p-button-secondary"
        (click)="showTemplateDialog = false">
      </button>
    </ng-template>
  </p-dialog>

  <app-resume-selector
    [(showSelector)]="showResumeSelector"
    (resumeSelected)="onResumeSelected($event)">
  </app-resume-selector>

  <p-dialog 
    header="{{ 'AI_CONFIG.MODAL_TITLE' | translate }}" 
    [(visible)]="showAIConfigModal" 
    [modal]="true"
    [style]="{ width: '70vw', maxWidth: '900px' }">
    
    <app-ai-config-modal 
      (closed)="showAIConfigModal = false">
    </app-ai-config-modal>
  </p-dialog>
</div>

<app-vacancy-selector
  [(showSelector)]="showVacancySelector"
  (vacancySelected)="onVacancySelected($event)">
</app-vacancy-selector>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Generation\cover-letter-generate\cover-letter-generate.component.ts ---

import { CommonModule } from '@angular/common';
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { TranslatePipe, TranslateService } from '@ngx-translate/core';
import { MessageService } from 'primeng/api';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { DialogModule } from 'primeng/dialog';
import { FileUploadModule } from 'primeng/fileupload';
import { InputTextModule } from 'primeng/inputtext';
import { ProgressBarModule } from 'primeng/progressbar';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { SelectModule } from 'primeng/select';
import { TextareaModule } from 'primeng/textarea';
import { TooltipModule } from 'primeng/tooltip';
import { Subscription } from 'rxjs';
import { AIGuardService } from '../../../shared/ai/ai-guard.service';
import { CoverLetterService } from '../../../shared/cover-letter/cover-letter.service';
import { SupabaseService } from '../../../shared/db/supabase.service';
import { ErrorHandlerService } from '../../../shared/error-handler.service';
import { HHAuthService } from '../../../shared/job-platforms/hh/hh-auth.service';
import { ProfileService } from '../../../shared/profile/profile.service';
import { VacancyService } from '../../../shared/vacancy/vacancy.service';
import { ResumeSelectorComponent, Resume } from '../../Helpers/resume-selector/resume-selector.component';
import { AiConfigModalComponent } from "../../Pages/ai-config-modal/ai-config-modal.component";
import { VacancySelectorComponent } from "../../Helpers/vacancy-selector/vacancy-selector.component";

@Component({
  selector: 'app-cover-letter-generate',
  templateUrl: './cover-letter-generate.component.html',
  styleUrls: ['./cover-letter-generate.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    ButtonModule,
    InputTextModule,
    FileUploadModule,
    SelectModule,
    CardModule,
    ProgressSpinnerModule,
    ProgressBarModule,
    TranslatePipe,
    DialogModule,
    TextareaModule,
    TooltipModule,
    ResumeSelectorComponent,
    AiConfigModalComponent,
    VacancySelectorComponent
],
  providers: [MessageService]
})
export class CoverLetterGenerateComponent implements OnInit {
  coverLetterForm: FormGroup;
  generatedLetter: any = null;
  isLoading = false;
  isSending = false;
  userProfile: any = null;
  showTemplateDialog = false;
  selectedTemplate: any = null;
  userResumes: any[] = [];
  selectedResume: any = null;
  uploadedResumeFile: File | null = null;
  resumeContent: string = '';
  vacancyUrl: string = '';
  currentVacancy: any = null;
  styleOptions: any[] = [];
  toneOptions: any[] = [];
  private langSubscription!: Subscription;
  showAIConfigModal = false;
  showResumeSelector = false;
  selectedResumeFromSelector: Resume | null = null;
  showVacancySelector = false;
  selectedVacancyFromSelector: any = null;

  constructor(
    private fb: FormBuilder,
    private coverLetterService: CoverLetterService,
    private supabase: SupabaseService,
    private profileService: ProfileService,
    private hhAuthService: HHAuthService,
    private messageService: MessageService,
    private vacancyService: VacancyService,
    private translate: TranslateService,
    public aiGuard: AIGuardService,
    private errorHandler: ErrorHandlerService
  ) {
    this.coverLetterForm = this.fb.group({
      resume_id: [''],
      vacancy_id: ['', Validators.required],
      style: ['formal'],
      tone: ['professional'],
      selected_resume: [null],
      resume_file: [null]
    });
  }
  
  private updateTranslatedOptions(): void {
    this.styleOptions = [
      { label: this.translate.instant('COVER_LETTER.STYLES.FORMAL'), value: 'formal' },
      { label: this.translate.instant('COVER_LETTER.STYLES.CREATIVE'), value: 'creative' },
      { label: this.translate.instant('COVER_LETTER.STYLES.TECHNICAL'), value: 'technical' }
    ];

    this.toneOptions = [
      { label: this.translate.instant('COVER_LETTER.TONES.PROFESSIONAL'), value: 'professional' },
      { label: this.translate.instant('COVER_LETTER.TONES.ENTHUSIASTIC'), value: 'enthusiastic' },
      { label: this.translate.instant('COVER_LETTER.TONES.CONSERVATIVE'), value: 'conservative' }
    ];
  }
  
  ngOnInit(): void {
    this.updateTranslatedOptions();
    this.loadUserProfile();
    this.loadUserResumes();
    this.langSubscription = this.translate.onLangChange.subscribe(() => {
      this.updateTranslatedOptions();
    });
  }
  
  closeTemplateDialog(): void {
    this.showTemplateDialog = false;
  }
  
  async loadVacancyForLetter(): Promise<void> {
      if (!this.vacancyUrl) return;
      
      this.isLoading = true;
      try {
        this.currentVacancy = await this.vacancyService.getVacancyWithCache(this.vacancyUrl);
        
        if (this.currentVacancy) {
          this.coverLetterForm.patchValue({
            vacancy_id: this.currentVacancy.id
          });
        }
      } catch (error) {
        this.errorHandler.showError('Ошибка загрузки вакансии', 'CoverLetterGenerateComponent');
      } finally {
        this.isLoading = false;
      }
  }
  
  async loadVacancyInfo(): Promise<void> {
    if (!this.vacancyUrl) return;
    
    this.isLoading = true;
    try {
      this.currentVacancy = await this.vacancyService.getVacancyWithCache(this.vacancyUrl);
      
      if (this.currentVacancy) {
        this.coverLetterForm.patchValue({
          vacancy_id: this.currentVacancy.id
        });
        
        this.messageService.add({
          severity: 'success',
          summary: 'Информация о вакансии загружена'
        });
      }
    } catch (error: any) {
      this.errorHandler.showError('Ошибка загрузки вакансии', 'CoverLetterGenerateComponent');
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка загрузки вакансии',
        detail: error.message
      });
    } finally {
      this.isLoading = false;
    }
  }

  onFileClear(): void {
    this.uploadedResumeFile = null;
    this.resumeContent = '';
  }
  
  private loadUserResumes(): void {
    const hhToken = localStorage.getItem('hh_access_token');
    if (hhToken && this.hhAuthService.isTokenValid()) {
      this.hhAuthService.getUserResumes().then(resumes => {
        this.userResumes = resumes;
      }).catch(error => {
        console.error('Error loading resumes:', error);
        this.messageService.add({
          severity: 'warn',
          summary: 'Не удалось загрузить резюме из HH.ru'
        });
      });
    }
  }
  
  sendToHH(): void {
    if (!this.generatedLetter || !this.userProfile) {
      return;
    }
  
    this.isSending = true;
    const vacancyId = this.coverLetterForm.get('vacancy_id')?.value;
    const resumeId = this.coverLetterForm.get('resume_id')?.value;
    const hhToken = localStorage.getItem('hh_access_token');
  
    if (!hhToken) {
      this.messageService.add({
        severity: 'error',
        summary: 'Требуется авторизация в HH.ru'
      });
      this.isSending = false;
      return;
    }
  
    this.coverLetterService.sendToHH(
      this.generatedLetter.content,
      vacancyId,
      resumeId,
      hhToken
    ).subscribe({
      next: () => {
        this.isSending = false;
        this.messageService.add({
          severity: 'success',
          summary: 'Письмо отправлено на HH.ru!'
        });
      },
      error: (error: Error) => {
        console.error('Error sending to HH:', error);
        this.isSending = false;
        this.messageService.add({
          severity: 'error',
          summary: 'Ошибка отправки на HH.ru',
          detail: error.message
        });
      }
    });
  }
  
  private loadUserProfile(): void {
    this.profileService.loadProfile().subscribe({
      next: (profile) => {
        this.userProfile = profile;
        if (profile) {
          this.coverLetterForm.patchValue({
            resume_id: this.supabase.currentUser?.id || ''
          });
        }
      },
      error: (error) => {
        console.error('Error loading profile:', error);
        this.messageService.add({
          severity: 'error',
          summary: 'Ошибка загрузки профиля'
        });
      }
    });
  }

  getVacancyPlatform(vacancy: any): string {
    if (vacancy.platform) {
      return vacancy.platform;
    }
    if (vacancy.alternate_url?.includes('hh.ru')) return 'hh.ru';
    if (vacancy.alternate_url?.includes('superjob.ru')) return 'superjob.ru';
    return 'unknown';
  }
  
  getPlatformLabel(platform: string): string {
    const platformLabels: { [key: string]: string } = {
      'hh.ru': 'HH.ru',
      'superjob.ru': 'SuperJob'
    };
    return platformLabels[platform] || platform;
  }

  editLetter(): void {
    this.showTemplateDialog = true;
  }

  saveAsTemplate(): void {
    if (!this.generatedLetter) {
      return;
    }

    const template = {
      id: 'template-' + Date.now(),
      name: `Шаблон от ${new Date().toLocaleDateString()}`,
      content: this.generatedLetter.content,
      is_default: false
    };

    this.coverLetterService.saveTemplate(template).subscribe({
      next: () => {
        this.messageService.add({
          severity: 'success',
          summary: 'Шаблон сохранен!'
        });
        this.showTemplateDialog = false;
      },
      error: (error: Error) => {
        console.error('Error saving template:', error);
        this.messageService.add({
          severity: 'error',
          summary: 'Ошибка сохранения шаблона'
        });
      }
    });
  }

  copyToClipboard(): void {
    if (!this.generatedLetter) {
      return;
    }

    navigator.clipboard.writeText(this.generatedLetter.content).then(() => {
      this.messageService.add({
        severity: 'success',
        summary: 'Текст скопирован в буфер обмена!'
      });
    }).catch((err: Error) => {
      console.error('Failed to copy:', err);
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка копирования'
      });
    });
  }

  private markFormGroupTouched(): void {
    Object.keys(this.coverLetterForm.controls).forEach(key => {
      const control = this.coverLetterForm.get(key);
      if (control) {
        control.markAsTouched();
      }
    });
  }

  getStyleLabel(value: string): string {
    const option = this.styleOptions.find(opt => opt.value === value);
    return option ? option.label : value;
  }

  getToneLabel(value: string): string {
    const option = this.toneOptions.find(opt => opt.value === value);
    return option ? option.label : value;
  }
  
  ngOnDestroy(): void {
    if (this.langSubscription) {
      this.langSubscription.unsubscribe();
    }
  }

  onResumeSelected(resume: Resume): void {
    this.selectedResumeFromSelector = resume;
    
    if (resume.platform === 'file' && resume.content) {
      this.resumeContent = resume.content;
      this.messageService.add({
        severity: 'success',
        summary: 'Резюме загружено из файла'
      });
    } else if (resume.platform === 'hh' || resume.platform === 'superjob') {
      this.selectedResume = resume;
      this.coverLetterForm.patchValue({
        selected_resume: resume
      });
    }
  }

  openResumeSelector(): void {
    this.showResumeSelector = true;
  }

  onVacancySelected(vacancy: any): void {
    this.selectedVacancyFromSelector = vacancy;
    
    if (vacancy.id) {
      this.coverLetterForm.patchValue({
        vacancy_id: vacancy.id
      });
    }
    
    this.currentVacancy = vacancy;
    
    this.messageService.add({
      severity: 'success',
      summary: 'Вакансия выбрана',
      detail: `${vacancy.name} - ${vacancy.employer?.name}`
    });
  }

  openVacancySelector(): void {
    this.showVacancySelector = true;
  }

  clearSelectedVacancy(): void {
    this.selectedVacancyFromSelector = null;
    this.currentVacancy = null;
    this.coverLetterForm.patchValue({
      vacancy_id: ''
    });
  }

  getPlatformIcon(platform: string): string {
    const icons: { [key: string]: string } = {
      'hh.ru': 'pi pi-briefcase',
      'superjob.ru': 'pi pi-briefcase', 
      'file': 'pi pi-file'
    };
    return icons[platform] || 'pi pi-question-circle';
  }

  getPlatformLabelForSelector(platform: string): string {
    const labels: { [key: string]: string } = {
      'hh.ru': 'HH.ru',
      'superjob.ru': 'SuperJob',
      'file': 'Файл'
    };
    return labels[platform] || platform;
  }

  generateCoverLetter(): void {
    const aiCheck = this.aiGuard.ensureAIConfigured();
    if (!aiCheck.configured) {
      this.errorHandler.showAIError(aiCheck.message || 'AI не настроен', 'CoverLetterGenerateComponent');
      this.showAIConfigModal = true;
      return;
    }
    
    if (this.coverLetterForm.invalid) {
      this.markFormGroupTouched();
      return;
    }

    this.isLoading = true;
    this.generatedLetter = null;

    const request = {
      ...this.coverLetterForm.value,
      selected_resume: this.selectedResume,
      resume_content: this.resumeContent,
      vacancy_data: this.currentVacancy || null
    };

    console.log('🚀 Starting letter generation for vacancy:', this.coverLetterForm.get('vacancy_id')?.value);

    this.coverLetterService.generateCoverLetter(request).subscribe({
      next: (response) => {
        console.log('✅ Letter generated successfully');
        this.generatedLetter = response;
        this.isLoading = false;
      },
      error: (error) => {
        this.errorHandler.showError('Ошибка генерации письма', 'CoverLetterGenerateComponent');
        this.isLoading = false;
        this.messageService.add({
          severity: 'error',
          summary: 'Ошибка генерации',
          detail: error.message
        });
      }
    });
  }
  onFileSelect(file: File | File[]): void {
    if (file instanceof File) {
      this.uploadedResumeFile = file;
      this.readResumeFile(file);
    } else if (Array.isArray(file) && file.length > 0) {
      this.uploadedResumeFile = file[0];
      this.readResumeFile(file[0]);
    }
  }
  
  private readResumeFile(file: File): void {
    const reader = new FileReader();
    reader.onload = (e) => {
      this.resumeContent = e.target?.result as string;
      this.messageService.add({
        severity: 'success',
        summary: 'Файл резюме загружен'
      });
    };
    reader.readAsText(file);
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Generation\interview-prep\interview-prep.component.html ---

<div class="interview-prep-container">
  <p-card [header]="'INTERVIEW_PREP.TITLE' | translate">
    <form [formGroup]="interviewForm">
      <!-- Резюме -->
      <div class="section">
        <h3>1. {{ 'INTERVIEW_PREP.RESUME_SECTION' | translate }}</h3>
        
        <div class="resume-selection-header">
          <button pButton 
                  type="button"
                  [label]="'RESUME_SELECTOR.TITLE' | translate"
                  icon="pi pi-briefcase"
                  (click)="openResumeSelector()"
                  class="p-button-outlined p-button-sm">
          </button>
        </div>

        <div *ngIf="selectedResumeForInterview" class="selected-resume-info">
          <div class="resume-details">
            <h5>{{ selectedResumeForInterview.title }}</h5>
            <p><strong>Платформа:</strong> {{ getPlatformLabel(selectedResumeForInterview.platform) }}</p>
          </div>
          <button pButton 
                  icon="pi pi-times" 
                  class="p-button-text p-button-danger"
                  (click)="clearSelectedResume()">
          </button>
        </div>
      </div>

      <!-- Вакансия -->
      <div class="section">
        <h3>2. {{ 'INTERVIEW_PREP.VACANCY_SECTION' | translate }}</h3>
        
        <div class="vacancy-selection-header">
          <button pButton 
                  type="button"
                  [label]="'VACANCY_SELECTOR.TITLE' | translate"
                  icon="pi pi-briefcase"
                  (click)="openVacancySelector()"
                  class="p-button-outlined p-button-sm">
          </button>
        </div>

        <div *ngIf="selectedVacancyForInterview" class="selected-vacancy-info">
          <div class="vacancy-details">
            <h5>{{ selectedVacancyForInterview.name }}</h5>
            <p><strong>Компания:</strong> {{ selectedVacancyForInterview.employer?.name }}</p>
            <p><strong>Платформа:</strong> {{ getPlatformLabel(selectedVacancyForInterview.platform) }}</p>
            <p *ngIf="selectedVacancyForInterview.salary">
              <strong>Зарплата:</strong> {{ getSalaryText(selectedVacancyForInterview) }}
            </p>
          </div>
          <button pButton 
                  icon="pi pi-times" 
                  class="p-button-text p-button-danger"
                  (click)="clearSelectedVacancy()">
          </button>
        </div>
      </div>
      
      <!-- Информация о компании -->
      <div class="section">
        <h3>3. {{ 'INTERVIEW_PREP.COMPANY_SECTION' | translate }}</h3>
        <div class="file-upload">
          <app-translated-file-input 
            (fileSelected)="onFileSelect($event, 'company')"
            [fieldName]="'interview-resume'"
            [accept]="'.txt, .pdf, .doc, .docx, .rtf, .md, .yaml, .yml, .json'">
          </app-translated-file-input>
          
          <div class="file-info" *ngIf="companyFile">
            <span>{{ companyFile.name }}</span>
            <button pButton icon="pi pi-times" class="p-button-text p-button-danger"
                    (click)="removeFile('company')">
            </button>
          </div>

          <div *ngIf="!companyFile">
            <small>{{ 'INTERVIEW_PREP.OR_TEXT' | translate }}</small>
            <textarea pInputTextarea [rows]="3" [placeholder]="'INTERVIEW_PREP.COMPANY_SECTION' | translate"
                     formControlName="customCompany">
            </textarea>
          </div>
        </div>
      </div>

      <!-- Персональный контекст -->
      <div class="section">
        <h3>4. {{ 'INTERVIEW_PREP.PERSONAL_CONTEXT_SECTION' | translate }}</h3>
        <div class="file-upload">
          <app-translated-file-input 
            (fileSelected)="onFileSelect($event, 'personalContext')"
            [fieldName]="'interview-resume'"
            [accept]="'.txt, .pdf, .doc, .docx, .rtf, .md, .yaml, .yml, .json'">
          </app-translated-file-input>
          <div class="file-info" *ngIf="personalContextFile">
            <span>{{ personalContextFile.name }}</span>
            <button pButton icon="pi pi-times" class="p-button-text p-button-danger"
                    (click)="removeFile('personalContext')">
            </button>
          </div>

          <div *ngIf="!personalContextFile">
            <small>{{ 'INTERVIEW_PREP.OR_TEXT' | translate }}</small>
            <textarea pInputTextarea [rows]="3" [placeholder]="'INTERVIEW_PREP.PERSONAL_CONTEXT_SECTION' | translate"
                     formControlName="customPersonalContext">
            </textarea>
          </div>
        </div>
      </div>

      <!-- Сопроводительное письмо -->
      <div class="section">
        <h3>5. {{ 'INTERVIEW_PREP.COVER_LETTER_SECTION' | translate }}</h3>
        <div class="file-upload">
          <app-translated-file-input 
            (fileSelected)="onFileSelect($event, 'coverLetter')"
            [fieldName]="'interview-resume'"
            [accept]="'.txt, .pdf, .doc, .docx, .rtf, .md, .yaml, .yml, .json'">
          </app-translated-file-input>
          
          <div class="file-info" *ngIf="coverLetterFile">
            <span>{{ coverLetterFile.name }}</span>
            <button pButton icon="pi pi-times" class="p-button-text p-button-danger"
                    (click)="removeFile('coverLetter')">
            </button>
          </div>

          <div *ngIf="!coverLetterFile">
            <small>{{ 'INTERVIEW_PREP.OR_TEXT' | translate }}</small>
            <textarea pInputTextarea [rows]="3" [placeholder]="'INTERVIEW_PREP.COVER_LETTER_SECTION' | translate"
                     formControlName="customCoverLetter">
            </textarea>
          </div>
        </div>
      </div>

      <!-- Внутренний контекст -->
      <div class="section">
        <h3>6. {{ 'INTERVIEW_PREP.INTERNAL_CONTEXT_SECTION' | translate }}</h3>
        <div class="file-upload">
          <app-translated-file-input 
            (fileSelected)="onFileSelect($event, 'internalContext')"
            [fieldName]="'interview-resume'"
            [accept]="'.txt, .pdf, .doc, .docx, .rtf, .md, .yaml, .yml, .json'">
          </app-translated-file-input>
          
          <div class="file-info" *ngIf="internalContextFile">
            <span>{{ internalContextFile.name }}</span>
            <button pButton icon="pi pi-times" class="p-button-text p-button-danger"
                    (click)="removeFile('internalContext')">
            </button>
          </div>

          <div *ngIf="!internalContextFile">
            <small>{{ 'INTERVIEW_PREP.OR_TEXT' | translate }}</small>
            <textarea pInputTextarea [rows]="3" [placeholder]="'INTERVIEW_PREP.INTERNAL_CONTEXT_SECTION' | translate"
                     formControlName="customInternalContext">
            </textarea>
          </div>
        </div>
      </div>

      <!-- Кнопка генерации -->
      <div class="actions">
        <button pButton 
                [label]="'INTERVIEW_PREP.GENERATE_PLAN' | translate" 
                icon="pi pi-brain"
                (click)="generateInterviewPlan()"
                [disabled]="isLoading">
          <p-progressSpinner *ngIf="isLoading" 
                           [style]="{'width': '20px', 'height': '20px'}" 
                           strokeWidth="4">
          </p-progressSpinner>
        </button>
      </div>

    </form>
  </p-card>

  <!-- Диалог с результатом -->
  <p-dialog [header]="'INTERVIEW_PREP.PLAN_TITLE' | translate" 
           [(visible)]="showPlanDialog" 
           [modal]="true"
           [style]="{ width: '90vw', height: '80vh' }"
           [maximizable]="true">
    
    <div class="plan-content">
      <markdown [data]="generatedPlan"></markdown>
    </div>

    <ng-template pTemplate="footer">
      <button pButton [label]="'INTERVIEW_PREP.DOWNLOAD_PLAN' | translate" icon="pi pi-download"
              (click)="downloadPlan()"></button>
      <button pButton [label]="'INTERVIEW_PREP.COPY_PLAN' | translate" icon="pi pi-copy"
              class="p-button-secondary"
              (click)="copyToClipboard()"></button>
      <button pButton [label]="'CLOSE' | translate" 
              class="p-button-secondary"
              (click)="closePlanDialog()"></button>
    </ng-template>
  </p-dialog>
  
  <!-- Компонент выбора резюме -->
  <app-resume-selector
    [(showSelector)]="showResumeSelector"
    (resumeSelected)="onResumeSelected($event)">
  </app-resume-selector>
  
  <p-dialog 
    header="{{ 'AI_CONFIG.MODAL_TITLE' | translate }}" 
    [(visible)]="showAIConfigModal" 
    [modal]="true"
    [style]="{ width: '70vw', maxWidth: '900px' }">
    
    <app-ai-config-modal 
      (closed)="showAIConfigModal = false">
    </app-ai-config-modal>
  </p-dialog>
</div>

<app-vacancy-selector
[(showSelector)]="showVacancySelector"
(vacancySelected)="onVacancySelected($event)">
</app-vacancy-selector>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Generation\interview-prep\interview-prep.component.ts ---

import { Component, NgModule, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, FormsModule } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { MessageService } from 'primeng/api';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { FileUploadModule } from 'primeng/fileupload';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { TextareaModule } from 'primeng/textarea';
import { DialogModule } from 'primeng/dialog';
import { CheckboxModule } from 'primeng/checkbox';
import { MarkdownModule } from 'ngx-markdown';
import * as yaml from 'js-yaml';
import { TranslatePipe } from '@ngx-translate/core';
import { ConfigService } from '../../../shared/config/config.service';
import { HHVacancyService } from '../../../shared/job-platforms/hh/hh-vacancy.service';
import { ProfileService } from '../../../shared/profile/profile.service';
import { FileProcessorService } from '../../../shared/utils/file-processor.service';
import { TranslatedFileInputComponent } from '../../Helpers/translated-file-input/translated-file-input.component';
import { ErrorToastComponent } from '../../Helpers/error-toast/error-toast.component';
import { ErrorHandlerService } from '../../../shared/error-handler.service';
import { AIGuardService } from '../../../shared/ai/ai-guard.service';
import { AiConfigModalComponent } from "../../Pages/ai-config-modal/ai-config-modal.component";
import { ResumeSelectorComponent, Resume } from '../../Helpers/resume-selector/resume-selector.component';
import { VacancySelectorComponent } from "../../Helpers/vacancy-selector/vacancy-selector.component";
import { UsageService } from '../../../shared/billing/usage.service';

interface PromptConfig {
  system_prompt: string;
  user_prompt_template: string;
  blocks: {
    [key: string]: string;
  };
}

@Component({
  selector: 'app-interview-prep',
  templateUrl: './interview-prep.component.html',
  styleUrls: ['./interview-prep.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    ButtonModule,
    CardModule,
    FileUploadModule,
    ProgressSpinnerModule,
    TextareaModule,
    DialogModule,
    TranslatePipe,
    CheckboxModule,
    MarkdownModule,
    FormsModule,
    TranslatedFileInputComponent,
    AiConfigModalComponent,
    ResumeSelectorComponent,
    VacancySelectorComponent
]
})
export class InterviewPrepComponent implements OnInit {
  interviewForm: FormGroup;
  isLoading = false;
  generatedPlan: string = '';
  showPlanDialog = false;
  userProfile: any = null;
  
  resumeFile: File | null = null;
  vacancyFile: File | null = null;
  companyFile: File | null = null;
  personalContextFile: File | null = null;
  coverLetterFile: File | null = null;
  internalContextFile: File | null = null;
  
  resumeContent: string = '';
  vacancyContent: string = '';
  companyContent: string = '';
  personalContextContent: string = '';
  coverLetterContent: string = '';
  internalContextContent: string = '';

  promptConfig: PromptConfig | null = null;
  vacancyUrl: string = '';
  currentVacancy: any = null;
  showAIConfigModal = false;
  showVacancySelector = false;
  selectedVacancyForInterview: any = null;
  showResumeSelector = false;
  selectedResumeForInterview: Resume | null = null;

  constructor(
    private fb: FormBuilder,
    private http: HttpClient,
    private profileService: ProfileService,
    private fileProcessor: FileProcessorService,
    private configService: ConfigService,
    private messageService: MessageService,
    private vacancyService: HHVacancyService,
    public aiGuard: AIGuardService,
    private errorHandler: ErrorHandlerService,
    private usageService: UsageService
  ) {
    this.interviewForm = this.fb.group({
      customResume: [''],
      customVacancy: [''],
      customCompany: [''],
      customPersonalContext: [''],
      customCoverLetter: [''],
      customInternalContext: ['']
    });
  }

  async ngOnInit(): Promise<void> {
    this.loadUserProfile();
    await this.loadPromptConfig();
  }

  private async loadPromptConfig(): Promise<void> {
    try {
      const promptContent = await this.http.get('/assets/prompts/interview-prompt.yaml', { 
        responseType: 'text' 
      }).toPromise();
      
      if (promptContent) {
        const parsedConfig = yaml.load(promptContent);
        if (parsedConfig && typeof parsedConfig === 'object') {
          this.promptConfig = parsedConfig as PromptConfig;
          return;
        }
      }
      
      this.promptConfig = {
        system_prompt: 'Ты профессиональный карьерный коуч и эксперт по подготовке к собеседованиям.',
        user_prompt_template: 'Сгенерируй детальный план подготовки на основе данных: Резюме: {resume}, Вакансия: {vacancy}, Компания: {company}, Контекст: {context}, Письмо: {coverLetter}, Внутренний контекст: {internalContext}',
        blocks: {
          analysis: 'Стратегический анализ',
          questions: 'Подготовка ответов',
          strategy: 'Стратегия поведения',
          checklist: 'Чек-листы'
        }
      };
      
    } catch (error) {
      console.error('Error loading prompt config:', error);
      this.promptConfig = {
        system_prompt: 'Ты профессиональный карьерный коуч и эксперт по подготовке к собеседованиям.',
        user_prompt_template: 'Сгенерируй детальный план подготовки на основе данных: Резюме: {resume}, Вакансия: {vacancy}, Компания: {company}, Контекст: {context}, Письмо: {coverLetter}, Внутренний контекст: {internalContext}',
        blocks: {
          analysis: 'Стратегический анализ',
          questions: 'Подготовка ответов',
          strategy: 'Стратегия поведения',
          checklist: 'Чек-листы'
        }
      };
    }
  }
  
  closePlanDialog(): void {
    this.showPlanDialog = false;
  }
  
  private loadUserProfile(): void {
    this.profileService.loadProfile().subscribe({
      next: (profile) => {
        this.userProfile = profile;
      },
      error: (error) => {
        console.error('Error loading profile:', error);
      }
    });
  }
  
  async generateInterviewPlan(): Promise<void> {
    const limitCheck = await this.usageService.checkLimit('interviewPlans');
    if (!limitCheck.allowed) {
      const errorMsg = `Достигнут дневной лимит генерации планов собеседований. Доступно: ${limitCheck.remaining} из ${limitCheck.limit}. Обновите тариф для увеличения лимитов.`;
      this.messageService.add({
        severity: 'warn',
        summary: 'Лимит исчерпан',
        detail: errorMsg,
        life: 5000
      });
      return;
    }

    const aiCheck = this.aiGuard.ensureAIConfigured();
    if (!aiCheck.configured) {
      this.errorHandler.showAIError(aiCheck.message || 'AI не настроен', 'ResumeGenerationComponent');
      this.showAIConfigModal = true;
      return;
    }

    if (this.isLoading) return;

    this.isLoading = true;
    this.generatedPlan = '';

    try {
      const promptData = await this.preparePromptData();
      const plan = await this.generateWithAI(promptData);
      
      await this.usageService.incrementUsage('interviewPlans');
      
      this.generatedPlan = plan;
      this.showPlanDialog = true;
      
    } catch (error) {
      this.errorHandler.showError('Ошибка генерации плана собеседования', 'InterviewPrepComponent');
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка генерации плана',
        detail: 'Попробуйте еще раз'
      });
    } finally {
      this.isLoading = false;
    }
  }

  private async processStructuredResumeFile(content: string, fileType: string): Promise<any> {
    try {
      let parsedData: any;
      
      if (fileType.includes('json') || content.trim().startsWith('{')) {
        parsedData = JSON.parse(content);
      } else {
        parsedData = yaml.load(content) as unknown;
      }
  
      if (parsedData && typeof parsedData === 'object') {
        if ('person' in parsedData && parsedData.person && typeof parsedData.person === 'object') {
          return parsedData.person;
        }
        return parsedData;
      }
      
      throw new Error('Invalid file structure');
      
    } catch (error) {
      console.error('Error parsing structured resume file:', error);
      throw new Error('Не удалось распарсить файл резюме');
    }
  }
  
  async loadVacancyInfo(): Promise<void> {
    if (!this.vacancyUrl) return;
    
    this.isLoading = true;
    try {
      this.currentVacancy = await this.vacancyService.getVacancyWithCache(this.vacancyUrl);
      
      if (this.currentVacancy) {
        this.messageService.add({
          severity: 'success',
          summary: 'Информация о вакансии загружена'
        });
      }
    } catch (error: any) {
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка загрузки вакансии',
        detail: error.message
      });
    } finally {
      this.isLoading = false;
    }
  }
  
  removeFile(field: string): void {
    switch (field) {
      case 'resume':
        this.resumeFile = null;
        this.resumeContent = '';
        break;
      case 'vacancy':
        this.vacancyFile = null;
        this.vacancyContent = '';
        break;
      case 'company':
        this.companyFile = null;
        this.companyContent = '';
        break;
      case 'personalContext':
        this.personalContextFile = null;
        this.personalContextContent = '';
        break;
      case 'coverLetter':
        this.coverLetterFile = null;
        this.coverLetterContent = '';
        break;
      case 'internalContext':
        this.internalContextFile = null;
        this.internalContextContent = '';
        break;
    }
  }

  private async preparePromptData(): Promise<string> {
    let resumeText = '';
    let vacancyText = '';
    let companyText = '';
    let personalContextText = '';
    let coverLetterText = '';
    let internalContextText = '';

    if (this.selectedVacancyForInterview) {
      vacancyText = `
      ИНФОРМАЦИЯ О ВАКАНСИИ:
      - Должность: ${this.selectedVacancyForInterview.name}
      - Компания: ${this.selectedVacancyForInterview.employer?.name}
      - Требования: ${this.vacancyService.extractRequirements(this.selectedVacancyForInterview)}
      - Ключевые навыки: ${this.vacancyService.extractKeySkills(this.selectedVacancyForInterview).join(', ')}
      - Описание: ${this.selectedVacancyForInterview.description?.substring(0, 500)}...
      `;
    } else if (this.vacancyContent) {
      vacancyText = this.vacancyContent;
    } else {
      vacancyText = this.interviewForm.get('customVacancy')?.value || '';
    }

    const vacancyContext = this.currentVacancy ? `
    ИНФОРМАЦИЯ О ВАКАНСИИ:
    - Должность: ${this.currentVacancy.name}
    - Компания: ${this.currentVacancy.employer?.name}
    - Требования: ${this.vacancyService.extractRequirements(this.currentVacancy)}
    - Ключевые навыки: ${this.vacancyService.extractKeySkills(this.currentVacancy).join(', ')}
    ` : '';

    if (this.resumeContent) {
      resumeText = this.resumeContent;
    } else {
      resumeText = this.interviewForm.get('customResume')?.value || '';
    }
  
    if (this.vacancyContent) {
      vacancyText = this.vacancyContent;
    } else {
      vacancyText = this.interviewForm.get('customVacancy')?.value || '';
    }
  
    if (this.companyContent) {
      companyText = this.companyContent;
    } else {
      companyText = this.interviewForm.get('customCompany')?.value || '';
    }
  
    if (this.personalContextContent) {
      personalContextText = this.personalContextContent;
    } else {
      personalContextText = this.interviewForm.get('customPersonalContext')?.value || '';
    }
  
    if (this.coverLetterContent) {
      coverLetterText = this.coverLetterContent;
    } else {
      coverLetterText = this.interviewForm.get('customCoverLetter')?.value || '';
    }
  
    if (this.internalContextContent) {
      internalContextText = this.internalContextContent;
    } else {
      internalContextText = this.interviewForm.get('customInternalContext')?.value || '';
    }
  
    if (this.promptConfig?.user_prompt_template) {
      return this.promptConfig.user_prompt_template
        .replace(/{resume}/g, resumeText)
        .replace(/{vacancy}/g, vacancyText)
        .replace(/{company}/g, companyText)
        .replace(/{context}/g, personalContextText)
        .replace(/{coverLetter}/g, coverLetterText)
        .replace(/{internalContext}/g, internalContextText);
    }
  
    return `
      Информация о вакансии: ${vacancyContext}
      Резюме: ${resumeText}
      Вакансия: ${vacancyText}
      Компания: ${companyText}
      Контекст: ${personalContextText}
      Сопроводительное письмо: ${coverLetterText}
      Внутренний контекст: ${internalContextText}
    `;
  }

  private async generateWithAI(promptText: string): Promise<string> {
    const config = this.configService.getConfig();
    
    if (!config.togetherApiKey) {
      throw new Error('Together API key not configured');
    }
  
    const prompt = `${this.promptConfig?.system_prompt}
  
  Задание: ${promptText}`;
  
    const request = {
      model: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free',
      prompt: prompt,
      max_tokens: 4000,
      temperature: 0.7,
      top_p: 0.7,
      top_k: 50,
      repetition_penalty: 1.1,
      stop: ['<|im_end|>', '<|im_start|>'],
      stream: false
    };
  
    try {
      const response = await this.http.post<any>('https://api.together.xyz/v1/completions', request, {
        headers: {
          'Authorization': `Bearer ${config.togetherApiKey}`,
          'Content-Type': 'application/json'
        }
      }).toPromise();
  
      if (!response.choices?.[0]?.text) {
        throw new Error('Invalid response from AI');
      }
  
      return this.cleanGeneratedText(response.choices[0].text);
    } catch (error) {
      console.error('AI generation error:', error);
      return this.createFallbackPlan();
    }
  }

  private cleanGeneratedText(text: string): string {
    if (!text) return this.createFallbackPlan();
    
    let cleaned = text
    return cleaned || this.createFallbackPlan();
  }

  private createFallbackPlan(): string {
    return `Генерация не произошла`;
  }

  downloadPlan(): void {
    const blob = new Blob([this.generatedPlan], { type: 'text/markdown' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `interview-prep-plan-${new Date().toISOString().split('T')[0]}.md`;
    a.click();
    window.URL.revokeObjectURL(url);
  }

  copyToClipboard(): void {
    navigator.clipboard.writeText(this.generatedPlan).then(() => {
      this.messageService.add({
        severity: 'success',
        summary: 'Текст скопирован в буфер'
      });
    });
  }

  // Новые методы для работы с селектором резюме
  onResumeSelected(resume: Resume): void {
    this.selectedResumeForInterview = resume;
    
    if (resume.platform === 'file' && resume.content) {
      // Автоматически заполняем поле резюме
      this.interviewForm.patchValue({
        customResume: resume.content
      });
      this.messageService.add({
        severity: 'success',
        summary: 'Резюме загружено'
      });
    }
  }

  openResumeSelector(): void {
    this.showResumeSelector = true;
  }

  clearSelectedResume(): void {
    this.selectedResumeForInterview = null;
  }

  onVacancySelected(vacancy: any): void {
    this.selectedVacancyForInterview = vacancy;
    this.currentVacancy = vacancy;
    
    this.messageService.add({
      severity: 'success',
      summary: 'Вакансия выбрана для подготовки',
      detail: vacancy.name
    });
  }

  openVacancySelector(): void {
    this.showVacancySelector = true;
  }

  clearSelectedVacancy(): void {
    this.selectedVacancyForInterview = null;
    this.currentVacancy = null;
  }

  getPlatformLabel(platform: string): string {
    const labels: { [key: string]: string } = {
      'hh.ru': 'HH.ru',
      'superjob.ru': 'SuperJob',
      'file': 'Файл'
    };
    return labels[platform] || platform;
  }

  getSalaryText(vacancy: any): string {
    if (!vacancy.salary) return 'Не указана';
    const salary = vacancy.salary;
    let text = '';
    if (salary.from) text += `от ${salary.from} `;
    if (salary.to) text += `до ${salary.to} `;
    if (salary.currency) text += salary.currency;
    return text.trim();
  }

  async onFileSelect(event: any, field: string): Promise<void> {
    const file = event instanceof File ? event : (Array.isArray(event) ? event[0] : null);
    if (!file) return;
  
    try {
      let content = await this.fileProcessor.extractTextFromFile(file);
      
      if (field === 'resume' && (file.name.endsWith('.json') || file.name.endsWith('.yaml') || file.name.endsWith('.yml'))) {
        try {
          const profileData = await this.processStructuredResumeFile(content, file.type);
          content = this.profileService.exportToTxt(profileData);
        } catch (error) {
          console.warn('Failed to parse structured resume file, using raw content:', error);
        }
      }
      
      switch (field) {
        case 'resume':
          this.resumeFile = file;
          this.resumeContent = content;
          break;
        case 'vacancy':
          this.vacancyFile = file;
          this.vacancyContent = content;
          break;
        case 'company':
          this.companyFile = file;
          this.companyContent = content;
          break;
        case 'personalContext':
          this.personalContextFile = file;
          this.personalContextContent = content;
          break;
        case 'coverLetter':
          this.coverLetterFile = file;
          this.coverLetterContent = content;
          break;
        case 'internalContext':
          this.internalContextFile = file;
          this.internalContextContent = content;
          break;
      }
  
      this.messageService.add({
        severity: 'success',
        summary: 'Файл загружен',
        detail: `${file.name} успешно обработан`
      });
    } catch (error) {
      this.errorHandler.showError('Ошибка обработки файла', 'InterviewPrepComponent');
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка обработки файла'
      });
    }
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Generation\resume-generation\resume-generation.component.html ---

<div class="resume-container">
  <h2>{{ 'RESUME_GENERATION.HEADER' | translate }}</h2>

  <!-- Выбор вакансии -->
  <div class="vacancy-section">
    <h3>{{ 'VACANCY.VACANCY_INFO' | translate }}</h3>
    
    <div class="vacancy-selection">
      <button pButton 
              type="button"
              [label]="'VACANCY_SELECTOR.TITLE' | translate"
              icon="pi pi-briefcase"
              (click)="openVacancySelector()"
              class="p-button-outlined">
      </button>

      <!-- Информация о выбранной вакансии -->
      <div *ngIf="selectedVacancy" class="selected-vacancy-info">
        <div class="vacancy-details">
          <i [class]="getPlatformIcon(selectedVacancy.platform)"></i>
          <span class="vacancy-title">{{ selectedVacancy.name }}</span>
          <span class="vacancy-platform">({{ getPlatformLabel(selectedVacancy.platform) }})</span>
          <span class="vacancy-company">{{ selectedVacancy.employer?.name }}</span>
        </div>
        <button pButton 
                icon="pi pi-times" 
                class="p-button-text p-button-danger"
                (click)="clearSelectedVacancy()">
        </button>
      </div>
    </div>
  </div>

  <!-- Поле для сопроводительного письма -->
  <div class="cover-letter-section">
    <h3>{{ 'RESUME_GENERATION.COVER_LETTER_OPTIONAL' | translate }}</h3>
    <div class="input-field">
      <label>{{ 'RESUME_GENERATION.COVER_LETTER' | translate }}</label>
      <textarea 
        pInputTextarea 
        [(ngModel)]="coverLetterContent" 
        [ngModelOptions]="{standalone: true}"
        [rows]="5" 
        [placeholder]="'RESUME_GENERATION.COVER_LETTER_PLACEHOLDER' | translate"
        style="width: 100%">
      </textarea>
    </div>
    
    <div class="file-upload-field">
      <app-translated-file-input
        [accept]="'.txt,.pdf,.doc,.docx,.rtf'"
        [fieldName]="'resume-generation-cover-letter'"
        (fileSelected)="onCoverLetterFileSelect($event)"
        [showFileTypes]="true">
      </app-translated-file-input>
      
      @if (coverLetterFile) {
        <div class="file-info">
          <span>{{ coverLetterFile.name }}</span>
          <button pButton icon="pi pi-times" class="p-button-text p-button-danger" 
                  (click)="removeCoverLetterFile()">
          </button>
        </div>
      }
    </div>
    <small>{{ 'RESUME_GENERATION.COVER_LETTER_HINT' | translate }}</small>
  </div>

  <!-- Кнопка генерации -->
  <div class="generate-button-container">
    <button pButton 
            (click)="generateResume()" 
            [disabled]="isLoading" 
            class="generate-btn"
            icon="pi pi-file">
      @if (isLoading) {
        {{ 'BUTTON.RESUME_GENERATION_IN_PROCESS' | translate }}
      } @else {
        {{ 'BUTTON.GENERATE_RESUME' | translate }}
      }
    </button>
  </div>

  <!-- Действия с результатом -->
  @if (generatedResume) {
    <div class="result-actions">
      <button pButton 
              (click)="saveResume()" 
              [disabled]="isLoading" 
              class="save-btn"
              icon="pi pi-save">
        {{ 'BUTTON.SAVE' | translate }}
      </button>

      <button pButton 
              (click)="deleteResume()" 
              [disabled]="isLoading" 
              class="delete-btn"
              icon="pi pi-trash">
        {{ 'BUTTON.DELETE' | translate }}
      </button>

      <button pButton 
              (click)="openHHAuthModal()" 
              [disabled]="isLoading" 
              class="publish-btn"
              icon="pi pi-send">
        {{ 'BUTTON.PUBLISH_TO_JOB_PLATFORMS' | translate }}
      </button>
    </div>
  }

  @if (error) {
    <div class="error">{{ error }}</div>
  }

  @if (generatedResume) {
    <div class="resume-content">
      <markdown [data]="generatedResume"></markdown>
    </div>
  }

  <p-dialog 
    header="Публикация на HH.ru" 
    [(visible)]="hhAuthModalVisible" 
    [modal]="true"
    [style]="{ width: '50vw' }"
    [closable]="!isPublishing">
    
    @if (isPublishing) {
      <div class="publishing-status">
        <p-progressSpinner></p-progressSpinner>
        <p>{{ 'RESUME_GENERATION.PUBLISHING' | translate }}</p>
      </div>
    }
    
    @if (publishStatus === 'success' && hhResumeUrl) {
      <div class="publish-success">
        <p>{{ 'RESUME_GENERATION.PUBLISH_SUCCESS' | translate }}</p>
        <a [href]="hhResumeUrl" target="_blank">{{ 'RESUME_GENERATION.VIEW_ON_PLATFORMS' | translate }}</a>
      </div>
    }
    
    @if (publishStatus === 'error') {
      <div class="publish-error">
        <p>{{ 'RESUME_GENERATION.PUBLISH_ERROR' | translate }}</p>
        <p>{{ 'RESUME_GENERATION.PUBLISH_ERROR_DETAIL' | translate }}</p>
      </div>
    }
    
    <ng-template pTemplate="footer">
      @if (publishStatus === 'idle') {
        <button pButton 
          label="Опубликовать" 
          (click)="publishToHH()"
          [disabled]="isPublishing"></button>
      }
      <button pButton 
        label="Закрыть" 
        class="p-button-secondary" 
        (click)="hhAuthModalVisible = false"
        [disabled]="isPublishing"></button>
    </ng-template>
  </p-dialog>
</div>

<app-vacancy-selector
  [(showSelector)]="showVacancySelector"
  (vacancySelected)="onVacancySelected($event)">
</app-vacancy-selector>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Generation\resume-generation\resume-generation.component.ts ---

import { Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MarkdownComponent } from 'ngx-markdown';
import { TranslatePipe } from '@ngx-translate/core';
import { MessageService } from 'primeng/api';
import { ButtonModule } from 'primeng/button';
import { DialogModule } from 'primeng/dialog';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { Router } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { InputTextModule } from 'primeng/inputtext';
import { HHAuthService } from '../../../shared/job-platforms/hh/hh-auth.service';
import { HHVacancyService } from '../../../shared/job-platforms/hh/hh-vacancy.service';
import { ProfileService } from '../../../shared/profile/profile.service';
import { ResumeGenerationService } from '../../../shared/resume/resume-generation.service';
import { FileProcessorService } from '../../../shared/utils/file-processor.service';
import { TranslatedFileInputComponent } from '../../Helpers/translated-file-input/translated-file-input.component';
import { ErrorHandlerService } from '../../../shared/error-handler.service';
import { AIGuardService } from '../../../shared/ai/ai-guard.service';
import { VacancySelectorComponent } from '../../Helpers/vacancy-selector/vacancy-selector.component';
import { AnalyticsService } from '../../../shared/analytics.service';

@Component({
  selector: 'app-resume-generation',
  standalone: true,
  imports: [
    CommonModule,
    MarkdownComponent,
    TranslatePipe,
    FormsModule,
    ButtonModule,
    DialogModule,
    ProgressSpinnerModule,
    FormsModule,
    InputTextModule,
    TranslatedFileInputComponent,
    VacancySelectorComponent
],
  templateUrl: './resume-generation.component.html',
  styleUrls: ['./resume-generation.component.scss']
})
export class ResumeGenerationComponent {
  private router = inject(Router);
  private profileService = inject(ProfileService);
  private messageService = inject(MessageService);
  private fileProcessor = inject(FileProcessorService);
  
  vacancyUrl: string = '';
  selectedVacancy: any = null;
  generatedResume: string | null = null;
  coverLetterContent: string = '';
  coverLetterFile: File | null = null;
  isLoading = false;
  error: string | null = null;
  hhAuthModalVisible = false;
  isPublishing = false;
  publishStatus: 'idle' | 'success' | 'error' = 'idle';
  hhResumeUrl: string | null = null;
  showAIConfigModal = false;
  showVacancySelector = false;
  
  constructor(
    private resumeService: ResumeGenerationService,
    private hhAuthService: HHAuthService,
    private vacancyService: HHVacancyService,
    public aiGuard: AIGuardService,
    private errorHandler: ErrorHandlerService,
    private analyticsService: AnalyticsService
  ) {
    this.generatedResume = this.resumeService.getResume();
    const savedCoverLetter = this.resumeService.getCoverLetter();
    if (savedCoverLetter) {
      this.coverLetterContent = savedCoverLetter;
    }
  }

  // Новые методы для работы с селектором вакансий
  onVacancySelected(vacancy: any): void {
    this.selectedVacancy = vacancy;
    this.resumeService.currentVacancy = vacancy;
    
    this.messageService.add({
      severity: 'success',
      summary: 'Вакансия выбрана',
      detail: `${vacancy.name} - ${vacancy.employer?.name}`
    });
  }

  openVacancySelector(): void {
    this.showVacancySelector = true;
  }

  clearSelectedVacancy(): void {
    this.selectedVacancy = null;
    this.resumeService.currentVacancy = null;
  }

  getPlatformIcon(platform: string): string {
    const icons: { [key: string]: string } = {
      'hh.ru': 'pi pi-briefcase',
      'superjob.ru': 'pi pi-briefcase'
    };
    return icons[platform] || 'pi pi-question-circle';
  }

  getPlatformLabel(platform: string): string {
    const labels: { [key: string]: string } = {
      'hh.ru': 'HH.ru',
      'superjob.ru': 'SuperJob'
    };
    return labels[platform] || platform;
  }

  removeCoverLetterFile(): void {
    this.coverLetterFile = null;
    this.coverLetterContent = '';
  }

  async loadVacancyInfo(): Promise<void> {
    if (!this.vacancyUrl) return;
    
    this.isLoading = true;
    try {
      this.selectedVacancy = await this.vacancyService.getVacancyWithCache(this.vacancyUrl);
      
      if (this.selectedVacancy) {
        this.messageService.add({
          severity: 'success',
          summary: 'Информация о вакансии загружена'
        });
      }
    } catch (error: any) {
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка загрузки вакансии',
        detail: error.message
      });
    } finally {
      this.isLoading = false;
    }
  }

  generateResume() {
    
    const aiCheck = this.aiGuard.ensureAIConfigured();
    if (!aiCheck.configured) {
      this.errorHandler.showAIError(aiCheck.message || 'AI не настроен', 'ResumeGenerationComponent');
      this.showAIConfigModal = true;
      return;
    }

    this.isLoading = true;
    this.error = null;
    this.analyticsService.trackEvent('generate_resume', {
      has_vacancy: !!this.selectedVacancy,
      vacancy_source: this.selectedVacancy?.platform
    });
    this.generateResumeWithContext();
  }

  private generateResumeWithContext(): void {
    const coverLetter = this.coverLetterContent || undefined;

    this.resumeService.generateResume(coverLetter).subscribe({
      next: (resume) => {
        this.generatedResume = resume;
        this.isLoading = false;
        if (this.coverLetterContent) {
          this.resumeService.saveCoverLetter(this.coverLetterContent);
        }
        this.messageService.add({
          severity: 'success',
          summary: 'Резюме сгенерировано успешно!'
        });
      },
      error: (error) => {
        this.error = 'Не удалось сгенерировать резюме: ' + error.message;
        this.isLoading = false;
        this.messageService.add({
          severity: 'error',
          summary: 'Ошибка генерации резюме',
          detail: error.message
        });
      }
    });
  }

  saveResume() {
    if (this.generatedResume) {
      this.resumeService.saveResume(this.generatedResume);
      if (this.coverLetterContent) {
        this.resumeService.saveCoverLetter(this.coverLetterContent);
      }
      this.messageService.add({
        severity: 'success',
        summary: 'Резюме сохранено'
      });
    }
  }

  deleteResume() {
    this.resumeService.deleteResume();
    this.resumeService.deleteCoverLetter();
    this.generatedResume = null;
    this.coverLetterContent = '';
    this.coverLetterFile = null;
    this.selectedVacancy = null;
    this.messageService.add({
      severity: 'info',
      summary: 'Резюме удалено'
    });
  }

  openHHAuthModal() {
    this.hhAuthModalVisible = true;
    this.publishStatus = 'idle';
    this.hhResumeUrl = null;
  }

  async connectToHH() {
    const hhToken = localStorage.getItem('hh_access_token');
    if (!hhToken) {
      this.messageService.add({
        severity: 'warn',
        summary: 'Сначала подключите аккаунт HH.ru'
      });
      return null;
    }
    return hhToken;
  }

  async publishToHH() {
    if (!this.generatedResume) {
      this.messageService.add({
        severity: 'error',
        summary: 'Сначала сгенерируйте резюме'
      });
      return;
    }

    this.isPublishing = true;
    this.publishStatus = 'idle';

    try {
      const hhToken = await this.connectToHH();
      if (!hhToken) return;

      const resumeData = await this.prepareHHResumeData();
      if (!resumeData) return;
      
      const resumeId = await this.hhAuthService.publishResume(hhToken, resumeData);
      this.hhResumeUrl = `https://hh.ru/resume/${resumeId}`;
      this.publishStatus = 'success';
      
      this.messageService.add({
        severity: 'success',
        summary: 'Резюме опубликовано на HH.ru',
        detail: `Ссылка: ${this.hhResumeUrl}`
      });
    } catch (error: any) {
      this.errorHandler.showError('Ошибка публикации резюме', 'ResumeGenerationComponent');
      this.publishStatus = 'error';
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка публикации',
        detail: error.message || 'Не удалось опубликовать резюме'
      });
    } finally {
      this.isPublishing = false;
    }
  }

  private async prepareHHResumeData(): Promise<any> {
    const profile = await this.profileService.loadProfile().toPromise();
    if (!profile) {
      this.router.navigate(['/profile/edit']);
      this.messageService.add({
        severity: 'warn',
        summary: 'Заполните профиль перед публикацией'
      });
      return null;
    }

    const requiredFields = [
      { field: profile.name, error: 'Укажите имя' },
      { field: profile.contact.email, error: 'Укажите email' },
      { field: profile.experience?.length > 0, error: 'Добавьте опыт работы' },
      { field: profile.education?.length > 0, error: 'Добавьте образование' }
    ];

    const missingField = requiredFields.find(f => !f.field);
    if (missingField) {
      this.router.navigate(['/profile/edit'], {
        state: { highlightMissing: true }
      });
      this.messageService.add({
        severity: 'error',
        summary: missingField.error
      });
      return null;
    }

    const aboutText = await this.generateResumeSection(`
      Напиши профессиональное описание для раздела "О себе" используя:
      Навыки: ${profile.skills.map(s => s.name).join(', ')}
      Опыт: ${profile.experience.length} ${this.pluralize(profile.experience.length, ['год', 'года', 'лет'])}
      Образование: ${profile.education.map(e => e.specialty).join(', ')}
    `);

    const experienceTexts = await Promise.all(
      profile.experience.map((exp: any) => 
        this.generateResumeSection(`
          Опиши профессиональный опыт для резюме:
          Должность: ${exp.position}
          Компания: ${exp.company}
          Период: ${exp.startDate} - ${exp.endDate || 'по настоящее время'}
          Обязанности: ${exp.tasks.join('; ')}
          Достижения: ${exp.achievements.map((a: any) => a.name).join('; ')}
          Технологии: ${exp.stack.join(', ')}
        `)
      )
    );

    return {
      title: `${profile.desiredPositions?.[0] || 'Специалист'} ${profile.name}`,
      first_name: profile.name.split(' ')[0],
      last_name: profile.name.split(' ')[1] || '',
      middle_name: profile.name.split(' ')[2] || '',
      contacts: this.formatContacts(profile.contact),
      salary: {
        amount: 200000,
        currency: 'RUR'
      },
      experience: profile.experience.map((exp: any, i: number) => ({
        position: exp.position,
        company: exp.company,
        start: exp.startDate,
        end: exp.endDate || null,
        description: experienceTexts[i],
        achievements: exp.achievements.map((a: any) => a.name)
      })),
      education: profile.education.map((edu: any) => ({
        year: edu.year,
        name: edu.institution,
        result: `${edu.degree}, ${edu.specialty}`,
        type: 'higher'
      })),
      skill_set: [
        ...profile.skills.map((s: any) => s.name),
        ...profile.languages.map((l: any) => `${l.language} (${l.level})`)
      ],
      about: aboutText,
      skills: this.formatSkills(profile.skills),
      hidden_fields: ['resume_access'],
      resume_locale: 'RU'
    };
  }
  closeHHAuthModal(): void {
    this.hhAuthModalVisible = false;
  }
  private generateResumeSection(prompt: string): Promise<string> {
    return new Promise((resolve) => {
      this.resumeService.generateResumeSection(prompt).subscribe({
        next: (text) => resolve(text),
        error: () => resolve(this.createFallbackText(prompt))
      });
    });
  }
  
  private createFallbackText(prompt: string): string {
    if (prompt.includes('О себе') || prompt.includes('описание')) {
      return 'Опытный специалист с сильными профессиональными навыками и стремлением к развитию.';
    }
    if (prompt.includes('опыт') || prompt.includes('работа')) {
      return 'Ответственный сотрудник с доказанным опытом достижения результатов.';
    }
    return 'Профессионал с качественным опытом работы.';
  }

  private formatContacts(contact: any): any[] {
    return [
      { type: 'email', value: contact.email, preferred: true },
      contact.phone ? { type: 'cell', value: contact.phone } : null,
      contact['linkedin'] ? { type: 'skype', value: contact['linkedin'] } : null
    ].filter(Boolean);
  }

  private formatSkills(skills: any[]): string {
    return skills
      .sort((a: any, b: any) => b.level - a.level)
      .map((s: any) => `${s.name} - ${s.level}/10`)
      .join('\n');
  }

  private pluralize(count: number, forms: string[]): string {
    const cases = [2, 0, 1, 1, 1, 2];
    return forms[
      count % 100 > 4 && count % 100 < 20 ? 2 : cases[Math.min(count % 10, 5)]
    ];
  }

  async onCoverLetterFileSelect(file: File | File[]): Promise<void> {
    try {
      const selectedFile = file instanceof File ? file : (Array.isArray(file) ? file[0] : null);
      
      if (selectedFile) {
        this.coverLetterFile = selectedFile;
        const content = await this.fileProcessor.extractTextFromFile(selectedFile);
        this.coverLetterContent = content;
        this.messageService.add({
          severity: 'success',
          summary: 'Файл сопроводительного письма загружен'
        });
      }
    } catch (error) {
      this.messageService.add({
        severity: 'error',
        summary: 'Ошибка загрузки файла'
      });
    }
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\about\about-module.ts ---

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AboutRoutingModule } from './about-routing-module';
import { About } from './about/about';
import { ButtonModule } from "primeng/button";
import { TranslatePipe } from '@ngx-translate/core';


@NgModule({
  declarations: [
    About
  ],
  imports: [
    CommonModule,
    AboutRoutingModule,
    ButtonModule,
    TranslatePipe
]
})
export class AboutModule { }


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\about\about-routing-module.ts ---

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { About } from './about/about';

const routes: Routes = [
  {
    path: "about",
    component: About
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class AboutRoutingModule { }


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\about\about\about.html ---

<div class="about-container">
  <div class="about-header">
    <h1>{{ 'ABOUT.TITLE' | translate }}</h1>
    <p class="about-subtitle">{{ 'ABOUT.SUBTITLE' | translate }}</p>
  </div>

  <div class="about-content">
    <div class="features-section">
      <h2>{{ 'ABOUT.FEATURES_TITLE' | translate }}</h2>
      
      <div class="features-grid">
        <div class="feature-card">
          <div class="feature-icon">
            <i class="pi pi-file"></i>
          </div>
          <h3>{{ 'ABOUT.FEATURES.AI_RESUME' | translate }}</h3>
          <p>{{ 'ABOUT.FEATURES.AI_RESUME_DESC' | translate }}</p>
        </div>

        <div class="feature-card">
          <div class="feature-icon">
            <i class="pi pi-envelope"></i>
          </div>
          <h3>{{ 'ABOUT.FEATURES.COVER_LETTERS' | translate }}</h3>
          <p>{{ 'ABOUT.FEATURES.COVER_LETTERS_DESC' | translate }}</p>
        </div>

        <div class="feature-card">
          <div class="feature-icon">
            <i class="pi pi-briefcase"></i>
          </div>
          <h3>{{ 'ABOUT.FEATURES.JOB_PLATFORMS_INTEGRATION' | translate }}</h3>
          <p>{{ 'ABOUT.FEATURES.JOB_PLATFORMS_INTEGRATION_DESC' | translate }}</p>
        </div>

        <div class="feature-card">
          <div class="feature-icon">
            <i class="pi pi-download"></i>
          </div>
          <h3>{{ 'ABOUT.FEATURES.EXPORT' | translate }}</h3>
          <p>{{ 'ABOUT.FEATURES.EXPORT_DESC' | translate }}</p>
        </div>
      </div>
    </div>

    <div class="cta-section">
      <h2>{{ 'ABOUT.CTA_TITLE' | translate }}</h2>
      <p>{{ 'ABOUT.CTA_DESCRIPTION' | translate }}</p>
      
      <div class="action-buttons">
        <button pButton 
                [label]="'BUTTON.GENERATE_RESUME' | translate" 
                routerLink="/resume-generation"
                icon="pi pi-file"
                class="p-button-primary">
        </button>
        
        <button pButton 
                [label]="'MAIN_MENU.JOB_PLATFORMS.name' | translate" 
                routerLink="/auth/callback"
                icon="pi pi-briefcase"
                class="p-button-outlined">
        </button>

        <button pButton 
                [label]="'BUTTON.PROFILE' | translate" 
                routerLink="/profile/view"
                icon="pi pi-user"
                class="p-button-secondary">
        </button>
      </div>
    </div>
  </div>
  <div class="legal-links legal-links-footer">
    <a routerLink="/terms-of-service">Пользовательское соглашение</a>
    <a routerLink="/privacy-policy">Политика конфиденциальности</a>
    <a routerLink="/public-offer">Публичная оферта</a>
    <a routerLink="/requisites-page">Реквизиты</a>
  </div>
</div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\about\about\about.spec.ts ---

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { About } from './about';

describe('About', () => {
  let component: About;
  let fixture: ComponentFixture<About>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [About]
    })
    .compileComponents();

    fixture = TestBed.createComponent(About);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\about\about\about.ts ---

import { Component } from '@angular/core';

@Component({
  selector: 'app-about',
  templateUrl: './about.html',
  styleUrls: ['./about.scss'],
  standalone: false,
})
export class About {
  ngOnInit() {
    this.updateMetaTags();
  }

  private updateMetaTags() {
    document.title = 'Rezulution';
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\ai-config-modal\ai-config-modal.component.html ---

<div class="ai-config-modal">
  <div class="providers-grid">
    <div *ngFor="let provider of providers" 
         class="provider-card"
         [class.configured]="provider.isConfigured"
         [class.current]="isCurrentProvider(provider.id)"
         [class.default-provider]="provider.isDefault">
      
      <div class="provider-header">
        <h3>{{ provider.name }}</h3>
        <div class="provider-status">
          <span *ngIf="provider.isDefault" class="status-badge default">
            {{ 'AI_CONFIG.STATUS.DEFAULT' | translate }}
          </span>
          <span *ngIf="provider.isConfigured" class="status-badge configured">
            {{ 'AI_CONFIG.STATUS.CONFIGURED' | translate }}
          </span>
          <span *ngIf="isCurrentProvider(provider.id)" class="status-badge active-text">
            {{ 'AI_CONFIG.STATUS.ACTIVE' | translate }}
          </span>
        </div>
      </div>

      <div class="provider-config" *ngIf="editingProvider === provider.id">
        <div class="config-field">
          <label>{{ 'AI_CONFIG.FIELDS.API_KEY' | translate }}:</label>
          <input type="password" 
                 [(ngModel)]="provider.apiKey"
                 [placeholder]="provider.isDefault ? 
                   ('AI_CONFIG.FIELDS.API_KEY_PLACEHOLDER_DEFAULT' | translate) : 
                   ('AI_CONFIG.FIELDS.API_KEY_PLACEHOLDER' | translate)"
                 [disabled]="!!(provider.isDefault && provider.isConfigured)">
        </div>
        
        <div class="config-field">
          <label>{{ 'AI_CONFIG.FIELDS.BASE_URL' | translate }}:</label>
          <input type="text" 
                 [(ngModel)]="provider.baseUrl"
                 [placeholder]="provider.baseUrl"
                 [disabled]="!!provider.isDefault">
        </div>

        <div class="config-actions">
          <button pButton 
                  [label]="'AI_CONFIG.BUTTONS.SAVE' | translate" 
                  (click)="saveProviderConfig(provider)"
                  class="p-button-success"
                  [disabled]="!!provider.isDefault">
          </button>
          <button pButton 
                  [label]="'AI_CONFIG.BUTTONS.CANCEL' | translate" 
                  (click)="cancelEdit()"
                  class="p-button-secondary">
          </button>
          <button *ngIf="provider.isConfigured"
                  pButton 
                  [label]="'AI_CONFIG.BUTTONS.TEST_CONNECTION' | translate" 
                  (click)="testConnection(provider.id)"
                  class="p-button-info">
          </button>
        </div>
      </div>

      <div class="provider-actions" *ngIf="editingProvider !== provider.id">
        <button pButton 
                [label]="provider.isConfigured ? 
                  ('AI_CONFIG.BUTTONS.EDIT' | translate) : 
                  ('AI_CONFIG.BUTTONS.CONFIGURE' | translate)"
                (click)="editProvider(provider.id)"
                class="p-button-outlined"
                [disabled]="!!(provider.isDefault && provider.isConfigured)">
        </button>
        
        <button *ngIf="provider.isConfigured && !isCurrentProvider(provider.id)"
                pButton 
                [label]="'AI_CONFIG.BUTTONS.USE' | translate" 
                (click)="setCurrentProvider(provider.id)"
                class="p-button-success">
        </button>

        <button *ngIf="provider.isDefault && !provider.isConfigured"
                pButton 
                [label]="'AI_CONFIG.BUTTONS.CONNECT' | translate" 
                (click)="connectTogetherAI()"
                class="p-button-help">
          <i class="pi pi-plug"></i>
        </button>
      </div>
    </div>
  </div>

  <div class="connection-help">
    <h4>{{ 'AI_CONFIG.HELP.TITLE' | translate }}</h4>
    <ul>
      <li>{{ 'AI_CONFIG.HELP.CHECK_API_KEY' | translate }}</li>
      <li>{{ 'AI_CONFIG.HELP.CHECK_PERMISSIONS' | translate }}</li>
      <li>{{ 'AI_CONFIG.HELP.TOGETHER_AI_AUTO' | translate }}</li>
      <li>{{ 'AI_CONFIG.HELP.CORS_ERRORS' | translate }}</li>
    </ul>
  </div>
</div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\ai-config-modal\ai-config-modal.component.ts ---

// Файл: src/app/components/Helpers/ai-config-modal/ai-config-modal.component.ts
import { Component, EventEmitter, Output, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ButtonModule } from 'primeng/button';
import { MessageService } from 'primeng/api';
import { AIService, AIProvider } from '../../../shared/ai/ai.service';
import { ConfigService } from '../../../shared/config/config.service';
import { ErrorHandlerService } from '../../../shared/error-handler.service';
import { TranslateModule, TranslateService } from '@ngx-translate/core';

@Component({
  selector: 'app-ai-config-modal',
  templateUrl: './ai-config-modal.component.html',
  styleUrls: ['./ai-config-modal.component.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule, ButtonModule, TranslateModule]
})
export class AiConfigModalComponent implements OnInit {
  @Output() closed = new EventEmitter<void>();
  
  providers: AIProvider[] = [];
  editingProvider: string | null = null;
  originalProviderState: any = null;
  isLoading = false;

  constructor(
    private aiService: AIService,
    private configService: ConfigService,
    private messageService: MessageService,
    private errorHandler: ErrorHandlerService
  ) {}

  ngOnInit(): void {
    // Подписываемся на обновления провайдеров
    this.aiService.getProvidersObservable().subscribe(providers => {
      this.providers = providers;
    });
  }

  isAnyProviderConfigured(): boolean {
    return this.aiService.isAnyProviderConfigured();
  }

  editProvider(providerId: string): void {
    this.editingProvider = providerId;
    const provider = this.providers.find(p => p.id === providerId);
    if (provider) {
      this.originalProviderState = { ...provider };
    }
  }

  cancelEdit(): void {
    if (this.originalProviderState && this.editingProvider) {
      const index = this.providers.findIndex(p => p.id === this.editingProvider);
      if (index !== -1) {
        this.providers[index] = { ...this.originalProviderState };
      }
    }
    this.editingProvider = null;
    this.originalProviderState = null;
  }

  setCurrentProvider(providerId: string): void {
    try {
      this.aiService.setCurrentProvider(providerId);
      this.messageService.add({
        severity: 'success',
        summary: 'Провайдер изменен',
        detail: 'Теперь используется выбранный AI провайдер'
      });
    } catch (error: any) {
      this.errorHandler.showError('Ошибка смены провайдера: ' + error.message, 'AiConfigModalComponent');
    }
  }

  testConnection(providerId: string): void {
    this.aiService.testProviderConnection(providerId).subscribe({
      next: (success) => {
        if (success) {
        }
      },
      error: (error) => {
      }
    });
  }
  async connectTogetherAI(): Promise<void> {
    this.isLoading = true;
    try {
      const success = await this.aiService.configureTogetherFromConfig();
      if (success) {
        this.messageService.add({
          severity: 'success',
          summary: 'Together AI подключен и активирован',
          detail: 'Провайдер готов к использованию'
        });
        
        // Автоматически тестируем подключение после настройки
        setTimeout(() => {
          this.testConnection('together');
        }, 1000);
      }
    } catch (error: any) {
      this.errorHandler.showAIError('Ошибка подключения Together AI: ' + error.message, 'AiConfigModalComponent');
    } finally {
      this.isLoading = false;
    }
  }

  saveProviderConfig(provider: AIProvider): void {
    const success = this.aiService.configureProvider(
      provider.id, 
      provider.apiKey, 
      provider.baseUrl
    );
    
    if (success) {
      if (provider.id === 'together' && !this.originalProviderState?.isConfigured) {
        this.aiService.setCurrentProvider('together');
      }
      
      this.messageService.add({
        severity: 'success',
        summary: 'Настройки сохранены',
        detail: `${provider.name} успешно настроен`
      });

      // Автоматически тестируем подключение после сохранения
      setTimeout(() => {
        this.testConnection(provider.id);
      }, 1000);
    } else {
      this.errorHandler.showAIError('Не удалось сохранить настройки провайдера', 'AiConfigModalComponent');
    }
    
    this.editingProvider = null;
    this.originalProviderState = null;
  }
  isCurrentProvider(providerId: string): boolean {
    const current = this.aiService.getCurrentProvider();
    return current?.id === providerId;
  }

  closeModal(): void {
    this.closed.emit();
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\auth\login\login.component.html ---

<div class="login-container">
  <div class="card">
    <h2>{{ 'AUTH.LOGIN.HEADER' | translate }}</h2>
    @if (errorMessage) {
      <div class="error-message">{{ errorMessage }}</div>
    }
    <button
      (click)="signInWithGoogle()"
      [disabled]="loading"
      class="google-btn"
    >
      <i class="pi pi-google"></i>
      {{ 'AUTH.LOGIN.VIA_GOOGLE' | translate }}
      <span *ngIf="loading" class="spinner"></span>
    </button>
  </div>
</div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\auth\login\login.component.spec.ts ---

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { LoginComponent } from './login.component';

describe('LoginComponent', () => {
  let component: LoginComponent;
  let fixture: ComponentFixture<LoginComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [LoginComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(LoginComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\auth\login\login.component.ts ---

import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { CommonModule } from '@angular/common';
import { TranslatePipe } from '@ngx-translate/core';
import { SupabaseService } from '../../../../shared/db/supabase.service';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    TranslatePipe
  ]
})
export class LoginComponent implements OnInit {
  loading = false;
  errorMessage: string | null = null;

  constructor(
    private supabase: SupabaseService,
    private router: Router
  ) {}

  ngOnInit() {
    if (this.supabase.currentUser) {
      this.router.navigate(['/']);
    }
  }
  async signInWithGoogle() {
    this.loading = true;
    this.errorMessage = null;
    
    try {
      const { error } = await this.supabase.signInWithGoogle();
      
      if (error) {
        console.error('Google sign-in error:', error);
        this.errorMessage = this.getErrorMessage(error);
        return;
      }
    } catch (error: unknown) {
      console.error('Unexpected error:', error);
      this.errorMessage = this.getErrorMessage(error);
    } finally {
      this.loading = false;
    }
  }

  private getErrorMessage(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === 'string') {
      return error;
    }
    return 'Неизвестная ошибка при входе через Google';
  }
}


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\cookies-consent\cookies-consent.component.html ---

<div class="cookies-banner" *ngIf="showCookiesBanner">
    <div class="cookies-content">
      <div class="cookies-text">
        <h3>Мы используем cookies</h3>
        <p>Этот сайт использует файлы cookie для улучшения работы сервиса. Продолжая использовать сайт, вы соглашаетесь с нашей <a routerLink="/privacy-policy" (click)="closeBanner()">Политикой конфиденциальности</a>.</p>
      </div>
      
      <div class="cookies-actions">
        <button class="btn-accept" (click)="acceptAll()">
          Принять все
        </button>
        <button class="btn-settings" (click)="showSettings = !showSettings">
          Настройки
        </button>
        <button class="btn-reject" (click)="rejectAll()">
          Отклонить
        </button>
      </div>
    </div>
  
    <div class="cookies-settings" *ngIf="showSettings">
      <div class="settings-content">
        <h4>Настройки cookies</h4>
        
        <div class="setting-item">
          <div class="setting-info">
            <h5>Обязательные cookies</h5>
            <p>Необходимы для работы сайта. Не могут быть отключены.</p>
          </div>
          <div class="setting-toggle">
            <input type="checkbox" checked disabled>
            <label>Всегда включены</label>
          </div>
        </div>
  
        <div class="setting-item">
          <div class="setting-info">
            <h5>Аналитические cookies</h5>
            <p>Помогают нам улучшать сервис, собирая анонимную статистику.</p>
          </div>
          <div class="setting-toggle">
            <input type="checkbox" id="analyticsCookies" [(ngModel)]="analyticsEnabled">
            <label for="analyticsCookies">Разрешить</label>
          </div>
        </div>
  
        <div class="setting-item">
          <div class="setting-info">
            <h5>Функциональные cookies</h5>
            <p>Запоминают ваши настройки и предпочтения.</p>
          </div>
          <div class="setting-toggle">
            <input type="checkbox" id="functionalCookies" [(ngModel)]="functionalEnabled">
            <label for="functionalCookies">Разрешить</label>
          </div>
        </div>
  
        <div class="settings-actions">
          <button class="btn-save" (click)="saveSettings()">
            Сохранить настройки
          </button>
        </div>
      </div>
    </div>
  </div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\cookies-consent\cookies-consent.component.ts ---

import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RouterModule } from '@angular/router';
import { AnalyticsService } from '../../../shared/analytics.service';

@Component({
  selector: 'app-cookies-consent',
  templateUrl: './cookies-consent.component.html',
  styleUrls: ['./cookies-consent.component.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule, RouterModule]
})
export class CookiesConsentComponent implements OnInit {
  showCookiesBanner = false;
  showSettings = false;
  analyticsEnabled = true;
  functionalEnabled = true;

  constructor(private analyticsService: AnalyticsService) {}

  ngOnInit() {
    // Проверяем, давал ли пользователь уже согласие на cookies
    const cookiesConsent = localStorage.getItem('cookies_consent');
    if (!cookiesConsent) {
      // Показываем баннер через 3 секунды после загрузки
      setTimeout(() => {
        this.showCookiesBanner = true;
      }, 3000);
    } else {
      // Если согласие уже дано, инициализируем аналитику
      const settings = JSON.parse(localStorage.getItem('cookies_settings') || '{}');
      this.analyticsService.initializeAnalytics(settings);
    }
  }

  acceptAll() {
    this.saveCookieSettings({
      necessary: true,
      analytics: true,
      functional: true
    });
    this.closeBanner();
  }

  rejectAll() {
    this.saveCookieSettings({
      necessary: true, // Обязательные cookies нельзя отключить
      analytics: false,
      functional: false
    });
    this.closeBanner();
  }

  saveSettings() {
    this.saveCookieSettings({
      necessary: true,
      analytics: this.analyticsEnabled,
      functional: this.functionalEnabled
    });
    this.showSettings = false;
    this.closeBanner();
  }

  private saveCookieSettings(settings: any) {
    localStorage.setItem('cookies_consent', 'true');
    localStorage.setItem('cookies_settings', JSON.stringify(settings));
    localStorage.setItem('cookies_consent_date', new Date().toISOString());
    
    // Инициализация аналитики в соответствии с настройками
    this.analyticsService.initializeAnalytics(settings);
    
    console.log('Настройки cookies сохранены:', settings);
  }

  closeBanner() {
    this.showCookiesBanner = false;
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\home\home.component.html ---

<div class="home-container">
  <h1>{{ 'HOME.WELCOME' | translate }}</h1>

  <div *ngIf="!supabase.currentUser" class="auth-buttons">
    <button [routerLink]="['/login']" class="login-btn">
      {{ 'BUTTON.LOGIN' | translate }}
    </button>
  </div>

  <div *ngIf="supabase.currentUser" class="user-actions">
    <button routerLink="/profile/view" class="profile-btn">
      {{ 'BUTTON.PROFILE' | translate }}
    </button>
    <button routerLink="/resume-generation" class="resume-btn">
      {{ 'BUTTON.GENERATE_RESUME' | translate }}
    </button>
  </div>
</div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\home\home.component.spec.ts ---

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HomeComponent } from './home.component';

describe('HomeComponent', () => {
  let component: HomeComponent;
  let fixture: ComponentFixture<HomeComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [HomeComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(HomeComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\home\home.component.ts ---

import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { TranslatePipe } from '@ngx-translate/core';
import { RouterModule } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { SupabaseService } from '../../../shared/db/supabase.service';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    TranslatePipe,
    RouterModule,
    ButtonModule
  ]
})
export class HomeComponent {
  constructor(public supabase: SupabaseService) {}
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\not-found\not-found.component.html ---

<div class="not-found-container">
    <div class="error-content">
      <h1>404</h1>
      <h2>{{ 'ERROR.NOT_FOUND' | translate }}</h2>
      <p>{{ 'ERROR.PAGE_NOT_EXIST' | translate }}</p>
      <button pButton 
              [label]="'BUTTON.BACK_HOME' | translate" 
              icon="pi pi-home"
              routerLink="/"
              class="p-button-primary">
      </button>
    </div>
  </div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\not-found\not-found.component.ts ---

import { Component } from '@angular/core';
import { ButtonModule } from 'primeng/button';
import { RouterModule } from '@angular/router';
import { TranslatePipe } from '@ngx-translate/core';

@Component({
  selector: 'app-not-found',
  standalone: true,
  imports: [ButtonModule, RouterModule, TranslatePipe],
  templateUrl: './not-found.component.html',
  styleUrl: './not-found.component.scss'
})
export class NotFoundComponent {}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\personal-data-consent\personal-data-consent.component.html ---

<div class="consent-modal" *ngIf="showConsentModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Согласие на обработку персональных данных</h2>
      </div>
      
      <div class="modal-body">
        <div class="consent-text">
          <p>В соответствии с Федеральным законом №152-ФЗ «О персональных данных» я даю согласие на обработку моих персональных данных:</p>
          
          <h3>1. Перечень персональных данных:</h3>
          <ul>
            <li>Фамилия, имя, отчество</li>
            <li>Контактная информация (email, телефон)</li>
            <li>Профессиональные данные (резюме, опыт работы, образование, навыки)</li>
            <li>Данные интеграций с платформами поиска работы</li>
          </ul>
  
          <h3>2. Цели обработки:</h3>
          <ul>
            <li>Предоставление услуг сервиса Rezulution</li>
            <li>Генерация резюме и сопроводительных писем</li>
            <li>Интеграция с платформами HH.ru, SuperJob и другими</li>
            <li>Отправка уведомлений и технических сообщений</li>
            <li>Улучшение качества предоставляемых услуг</li>
          </ul>
  
          <h3>3. Способы обработки:</h3>
          <p>Обработка осуществляется автоматизированными способами, включая сбор, запись, систематизацию, накопление, хранение, уточнение, извлечение, использование, передачу, обезличивание, блокирование, удаление.</p>
  
          <h3>4. Срок действия согласия:</h3>
          <p>Согласие действует до момента отзыва субъектом персональных данных.</p>
  
          <h3>5. Отзыв согласия:</h3>
          <p>Я осведомлен(а), что могу отозвать согласие путем отправки письменного заявления на email: privacy@rezulution.ru</p>
        </div>
  
        <div class="consent-actions">
          <div class="checkbox-group">
            <input type="checkbox" id="consentCheckbox" [(ngModel)]="consentGiven">
            <label for="consentCheckbox">
              Я даю согласие на обработку моих персональных данных в соответствии с указанными условиями
            </label>
          </div>
  
          <div class="buttons">
            <button class="btn-primary" (click)="acceptConsent()" [disabled]="!consentGiven">
              Принять и продолжить
            </button>
            <button class="btn-secondary" (click)="declineConsent()">
              Отклонить
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\personal-data-consent\personal-data-consent.component.ts ---

import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-personal-data-consent',
  templateUrl: './personal-data-consent.component.html',
  styleUrls: ['./personal-data-consent.component.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule]
})
export class PersonalDataConsentComponent implements OnInit {
  showConsentModal = false;
  consentGiven = false;

  ngOnInit() {
    // Проверяем, давал ли пользователь уже согласие
    const consentGiven = localStorage.getItem('personal_data_consent');
    if (!consentGiven) {
      // Показываем модальное окно через 2 секунды после загрузки
      setTimeout(() => {
        this.showConsentModal = true;
      }, 2000);
    }
  }

  acceptConsent() {
    if (this.consentGiven) {
      localStorage.setItem('personal_data_consent', 'true');
      localStorage.setItem('personal_data_consent_date', new Date().toISOString());
      this.showConsentModal = false;
      
      console.log('Пользователь принял согласие на обработку ПД');
    }
  }

  declineConsent() {
    localStorage.setItem('personal_data_consent', 'false');
    this.showConsentModal = false;
    
    alert('Без согласия на обработку персональных данных некоторые функции сервиса могут быть недоступны.');
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\privacy-policy\privacy-policy.component.html ---

<div class="legal-page">
    <div class="container">
      <header class="header">
        <h1>Политика конфиденциальности</h1>
        <p class="last-updated">Последнее обновление: {{currentYear}}</p>
      </header>
      
      <main class="content">
        <section class="section">
          <h2>1. Общие положения</h2>
          <p>1.1. Настоящая Политика конфиденциальности определяет порядок обработки и защиты персональных данных пользователей сервиса Rezulution.</p>
          <p>1.2. Используя Сервис, Пользователь соглашается с условиями настоящей Политики.</p>
        </section>
  
        <section class="section">
          <h2>2. Собираемая информация</h2>
          <p>2.1. Мы собираем следующую информацию:</p>
          <ul>
            <li>Персональные данные (имя, email, телефон)</li>
            <li>Профессиональная информация (резюме, опыт работы, образование)</li>
            <li>Данные интеграций с платформами (HH.ru, SuperJob)</li>
            <li>Технические данные (IP-адрес, браузер, устройство)</li>
          </ul>
        </section>
  
        <section class="section">
          <h2>3. Цели сбора информации</h2>
          <p>3.1. Собранная информация используется для:</p>
          <ul>
            <li>Предоставления услуг Сервиса</li>
            <li>Генерации резюме и сопроводительных писем</li>
            <li>Интеграции с платформами поиска работы</li>
            <li>Улучшения качества услуг</li>
            <li>Обратной связи с Пользователем</li>
          </ul>
        </section>
  
        <section class="section">
          <h2>4. Защита информации</h2>
          <p>4.1. Мы применяем современные методы защиты данных.</p>
          <p>4.2. Доступ к персональным данным имеют только уполномоченные сотрудники.</p>
          <p>4.3. Данные передаются по защищенным каналам связи.</p>
        </section>
  
        <section class="section">
          <h2>5. Передача данных третьим лицам</h2>
          <p>5.1. Мы не передаем персональные данные третьим лицам, за исключением:</p>
          <ul>
            <li>Случаев, требуемых законодательством</li>
            <li>Платформ поиска работы при интеграции (с согласия Пользователя)</li>
            <li>Партнеров для предоставления услуг</li>
          </ul>
        </section>
  
        <section class="section">
          <h2>6. Права Пользователя</h2>
          <p>6.1. Пользователь имеет право:</p>
          <ul>
            <li>На доступ к своим персональным данным</li>
            <li>На исправление неточных данных</li>
            <li>На удаление своих данных</li>
            <li>На отзыв согласия на обработку данных</li>
          </ul>
        </section>
  
        <section class="section">
          <h2>7. Cookies и аналитика</h2>
          <p>7.1. Мы используем cookies для улучшения работы Сервиса.</p>
          <p>7.2. Пользователь может отключить cookies в настройках браузера.</p>
        </section>
  
        <section class="section">
          <h2>8. Контакты</h2>
          <p>По вопросам защиты персональных данных обращайтесь:</p>
          <p>Email: runos.d.hino@gmail.com</p>
        </section>
      </main>
      
      <footer class="footer">
        <p>&copy; {{currentYear}} Rezulution. Все права защищены.</p>
        <div class="legal-links">
          <a href="/terms-of-service">Пользовательское соглашение</a>
          <a href="/privacy-policy">Политика конфиденциальности</a>
          <a href="/public-offer">Публичная оферта</a>
          <a href="/requisites-page">Реквизиты</a>
        </div>
      </footer>
    </div>
  </div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\privacy-policy\privacy-policy.component.ts ---

import { Component } from '@angular/core';

@Component({
  selector: 'app-privacy-policy',
  templateUrl: './privacy-policy.component.html',
  styleUrls: ['./privacy-policy.component.scss', '../../../../styles/legal-pages.common.scss']
})
export class PrivacyPolicyComponent {
  currentYear: number = new Date().getFullYear();
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\profile\profile-module.ts ---

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ProfileRoutingModule } from './profile-routing-module';
import { TranslateModule, TranslatePipe } from '@ngx-translate/core';
import { ProfileViewComponent } from './profile-view/profile-view.component';
import { AvatarModule } from 'primeng/avatar';
import { CheckboxModule } from 'primeng/checkbox';
import { ReactiveFormsModule } from '@angular/forms';
import { ProgressBarModule } from 'primeng/progressbar';
import { SelectModule } from 'primeng/select';
import { DatePickerModule } from 'primeng/datepicker';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { ButtonModule } from 'primeng/button';
import { FileUploadModule } from 'primeng/fileupload';
import { InputTextModule } from 'primeng/inputtext';
import { InputNumberModule } from 'primeng/inputnumber';
import { CardModule } from 'primeng/card';
import { PanelModule } from 'primeng/panel';
import { DialogModule } from 'primeng/dialog';
import { DividerModule } from 'primeng/divider';
import { SelectButtonModule } from 'primeng/selectbutton';
import { ResumeManagementComponent } from '../../Helpers/resume-management/resume-management.component';
import { ProfileEditComponent } from './profile-edit/profile-edit.component';

@NgModule({
  declarations: [
    ProfileEditComponent,
    ProfileViewComponent
  ],
  imports: [
    CommonModule,
    AvatarModule,
    CheckboxModule,
    ProfileRoutingModule,
    TranslatePipe,
    ReactiveFormsModule,
    TranslateModule,
    ProgressBarModule,
    SelectModule,
    DatePickerModule,
    ProgressSpinnerModule,
    ButtonModule,
    TranslatePipe,
    FileUploadModule,
    InputTextModule,
    InputNumberModule,
    ButtonModule,
    CardModule,
    PanelModule,
    DialogModule,
    DividerModule,
    ProgressBarModule,
    CheckboxModule,
    SelectButtonModule,
    SelectModule,
    DatePickerModule,
    ResumeManagementComponent
]
})
export class ProfileModule { }


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\profile\profile-routing-module.ts ---

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { ProfileViewComponent } from './profile-view/profile-view.component';
import { ProfileEditComponent } from './profile-edit/profile-edit.component';

const routes: Routes = [
  {
    path: "view", component: ProfileViewComponent
  },
  {
    path: "edit", component: ProfileEditComponent
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class ProfileRoutingModule { }


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\profile\profile-edit\profile-edit.component.html ---

<div class="profile-edit-container">
    @if (loading) {
    <p-progressBar mode="indeterminate"></p-progressBar>
    }

    <form [formGroup]="profileForm" (ngSubmit)="saveProfile()">
        <!-- Progress Bar -->
        <div class="completion-bar">
            <label>{{ 'PROFILE.COMPLETION' | translate }}</label>
            
            <p-progressBar [value]="getCompletionPercentage()" 
                           [showValue]="false">
            </p-progressBar>
            
            <div class="completion-percentage">
              <span class="percentage-text">{{ getCompletionPercentage() }}%</span>
              
              <span class="status-text" 
                    [class.complete]="getCompletionPercentage() === 100">
                {{ getCompletionPercentage() === 100 ? 
                   ('PROFILE.COMPLETE' | translate) : 
                   ('PROFILE.IN_PROGRESS' | translate) }}
              </span>
            </div>
          </div>
        <!-- Personal Information Section -->
        <p-panel [header]="'PROFILE.PERSONAL_INFO.TITLE' | translate" [toggleable]="true">
            <div class="form-grid">
                <div class="field">
                    <label for="name">{{ 'PROFILE.PERSONAL_INFO.NAME' | translate }} *</label>
                    <input id="name" type="text" pInputText formControlName="name"
                        [class]="{'p-invalid': profileForm.get('name')?.invalid && profileForm.get('name')?.touched}">
                    @if (profileForm.get('name')?.invalid && profileForm.get('name')?.touched) {
                    <small class="p-error">
                        {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                    </small>
                    }
                </div>

                <div class="field">
                    <label for="gender">{{ 'PROFILE.PERSONAL_INFO.GENDER' | translate }}</label>
                    <p-select 
                    [options]="genderOptions" 
                    optionLabel="label" 
                    optionValue="value"
                    formControlName="gender"
                    [placeholder]="'PROFILE.PERSONAL_INFO.GENDER' | translate">
                  </p-select>
                </div>
            </div>

            <div class="field">
                <label>{{ 'PROFILE.PERSONAL_INFO.DESIRED_POSITIONS' | translate }}</label>
                <div formArrayName="desiredPositions" class="array-container">
                    @for (pos of desiredPositions.controls; track i; let i = $index) {
                    <div class="array-item">
                        <input type="text" pInputText [formControlName]="i"
                            [class]="{'p-invalid': pos.invalid && pos.touched}">
                        <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                            (click)="removeDesiredPosition(i)">
                        </button>
                        @if (pos.invalid && pos.touched) {
                        <small class="p-error">
                            {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                        </small>
                        }
                    </div>
                    }
                    <button type="button" pButton icon="pi pi-plus" class="p-button-text"
                        (click)="addDesiredPosition()">
                        {{ 'PROFILE.PERSONAL_INFO.ADD_POSITION' | translate }}
                    </button>
                </div>
            </div>
        </p-panel>

        <!-- Contact Information Section -->
        <p-panel [header]="'PROFILE.CONTACT_INFO.TITLE' | translate" [toggleable]="true">
            <div formGroupName="contact" class="form-grid"> <!-- Добавлено formGroupName="contact" -->
              <div class="field">
                <label for="email">{{ 'PROFILE.CONTACT_INFO.EMAIL' | translate }} *</label>
                <input id="email" type="email" pInputText formControlName="email"
                       [class]="{'p-invalid': contactEmail?.invalid && contactEmail?.touched}">
                @if (contactEmail?.errors?.['required'] && contactEmail?.touched) {
                <small class="p-error">
                  {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                </small>
                }
                @if (contactEmail?.errors?.['email'] && contactEmail?.touched) {
                <small class="p-error">
                  {{ 'PROFILE.VALIDATION.INVALID_EMAIL' | translate }}
                </small>
                }
              </div>
          
              <div class="field">
                <label for="phone">{{ 'PROFILE.CONTACT_INFO.PHONE' | translate }}</label>
                <input id="phone" type="tel" pInputText formControlName="phone"
                       [class]="{'p-invalid': contactPhone?.invalid && contactPhone?.touched}">
                @if (contactPhone?.invalid && contactPhone?.touched) {
                <small class="p-error">
                  {{ 'PROFILE.CONTACT_INFO.PHONE_VALIDATION' | translate }}
                </small>
                }
              </div>
          
              <div class="field">
                <label for="linkedin">{{ 'PROFILE.CONTACT_INFO.LINKEDIN' | translate }}</label>
                <input id="linkedin" type="url" pInputText formControlName="linkedin">
              </div>
          
              <div class="field">
                <label for="github">{{ 'PROFILE.CONTACT_INFO.GITHUB' | translate }}</label>
                <input id="github" type="url" pInputText formControlName="github">
              </div>
            </div>
          </p-panel>

          <p-panel [header]="'PROFILE.LOCATION.TITLE' | translate" [toggleable]="true">
            <div formGroupName="location" class="form-grid"> <!-- Добавлено formGroupName="location" -->
              <div class="field">
                <label for="country">{{ 'PROFILE.LOCATION.COUNTRY' | translate }}</label>
                <input id="country" type="text" pInputText formControlName="country"> <!-- Убрано location. -->
              </div>
          
              <div class="field">
                <label for="city">{{ 'PROFILE.LOCATION.CITY' | translate }} *</label>
                <input id="city" type="text" pInputText formControlName="city"
                       [class]="{'p-invalid': locationCity?.invalid && locationCity?.touched}">
                @if (locationCity?.invalid && locationCity?.touched) {
                <small class="p-error">
                  {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                </small>
                }
              </div>
          
              <div class="field checkbox-field">
                <p-checkbox [binary]="true" formControlName="relocation"
                            [inputId]="'relocation'">
                </p-checkbox>
                <label for="relocation" class="checkbox-label">
                  {{ 'PROFILE.LOCATION.RELOCATION' | translate }}
                </label>
                <small class="checkbox-description">
                  {{ 'PROFILE.LOCATION.RELOCATION_DESC' | translate }}
                </small>
              </div>
          
              <div class="field checkbox-field">
                <p-checkbox [binary]="true" formControlName="remote"
                            [inputId]="'remote'">
                </p-checkbox>
                <label for="remote" class="checkbox-label">
                  {{ 'PROFILE.LOCATION.REMOTE' | translate }}
                </label>
                <small class="checkbox-description">
                  {{ 'PROFILE.LOCATION.REMOTE_DESC' | translate }}
                </small>
              </div>
          
              <div class="field checkbox-field">
                <p-checkbox [binary]="true" formControlName="business_trips"
                            [inputId]="'business_trips'">
                </p-checkbox>
                <label for="business_trips" class="checkbox-label">
                  {{ 'PROFILE.LOCATION.BUSINESS_TRIPS' | translate }}
                </label>
                <small class="checkbox-description">
                  {{ 'PROFILE.LOCATION.BUSINESS_TRIPS_DESC' | translate }}
                </small>
              </div>
            </div>
          </p-panel>

        <!-- Languages Section -->
        <p-panel [header]="'PROFILE.LANGUAGES.TITLE' | translate" [toggleable]="true">
            <div formArrayName="languages" class="array-container">
                @for (lang of languages.controls; track i; let i = $index) {
                <div [formGroupName]="i" class="array-item form-grid">
                    <div class="field">
                        <label>{{ 'PROFILE.LANGUAGES.LANGUAGE' | translate }} *</label>
                        <input type="text" pInputText formControlName="language"
                            [class]="{'p-invalid': lang.get('language')?.invalid && lang.get('language')?.touched}">
                        @if (lang.get('language')?.invalid && lang.get('language')?.touched) {
                        <small class="p-error">
                            {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                        </small>
                        }
                    </div>

                    <div class="field">
                        <label>{{ 'PROFILE.LANGUAGES.LEVEL' | translate }} *</label>
                        <p-select [options]="languageLevels" formControlName="level"
                            [placeholder]="'PROFILE.LANGUAGES.LEVEL' | translate">
                        </p-select>
                    </div>

                    <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                        (click)="removeLanguage(i)">
                    </button>
                </div>
                }
                <button type="button" pButton icon="pi pi-plus" class="p-button-text" (click)="addLanguage()">
                    {{ 'PROFILE.LANGUAGES.ADD_LANGUAGE' | translate }}
                </button>
            </div>
        </p-panel>

        <!-- Skills Section -->
        <p-panel [header]="'PROFILE.SKILLS.TITLE' | translate" [toggleable]="true">
            <div formArrayName="skills" class="array-container">
                @for (skill of skills.controls; track i; let i = $index) {
                <div [formGroupName]="i" class="array-item form-grid">
                    <div class="field">
                        <label>{{ 'PROFILE.SKILLS.AREA' | translate }} *</label>
                        <input type="text" pInputText formControlName="area"
                            [class]="{'p-invalid': skill.get('area')?.invalid && skill.get('area')?.touched}">
                        @if (skill.get('area')?.invalid && skill.get('area')?.touched) {
                        <small class="p-error">
                            {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                        </small>
                        }
                    </div>

                    <div class="field">
                        <label>{{ 'PROFILE.SKILLS.SKILL' | translate }} *</label>
                        <input type="text" pInputText formControlName="name"
                            [class]="{'p-invalid': skill.get('name')?.invalid && skill.get('name')?.touched}">
                        @if (skill.get('name')?.invalid && skill.get('name')?.touched) {
                        <small class="p-error">
                            {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                        </small>
                        }
                    </div>

                    <div class="field">
                        <label>{{ 'PROFILE.SKILLS.LEVEL' | translate }} *</label>
                        <p-inputNumber [min]="1" [max]="10" formControlName="level"
                            [class]="{'p-invalid': skill.get('level')?.invalid && skill.get('level')?.touched}">
                        </p-inputNumber>
                    </div>

                    <div class="field">
                        <label>{{ 'PROFILE.SKILLS.DATE' | translate }} *</label>
                        <p-datepicker
                            formControlName="date" 
                            dateFormat="yy-mm-dd" 
                            [showIcon]="true">
                        </p-datepicker>
                    </div>

                    <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                        (click)="removeSkill(i)">
                    </button>
                </div>
                }
                <button type="button" pButton icon="pi pi-plus" class="p-button-text" (click)="addSkill()">
                    {{ 'PROFILE.SKILLS.ADD_SKILL' | translate }}
                </button>
            </div>
        </p-panel>

        <!-- Education Section -->
        <p-panel [header]="'PROFILE.EDUCATION.TITLE' | translate" [toggleable]="true">
            <div formArrayName="education" class="array-container">
                @for (edu of education.controls; track i; let i = $index) {
                <div [formGroupName]="i" class="array-item form-grid">
                    <div class="field">
                        <label>{{ 'PROFILE.EDUCATION.INSTITUTION' | translate }} *</label>
                        <input type="text" pInputText formControlName="institution"
                            [class]="{'p-invalid': edu.get('institution')?.invalid && edu.get('institution')?.touched}">
                        @if (edu.get('institution')?.invalid && edu.get('institution')?.touched) {
                        <small class="p-error">
                            {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                        </small>
                        }
                    </div>

                    <div class="field">
                        <label>{{ 'PROFILE.EDUCATION.DEGREE' | translate }} *</label>
                        <input type="text" pInputText formControlName="degree"
                            [class]="{'p-invalid': edu.get('degree')?.invalid && edu.get('degree')?.touched}">
                        @if (edu.get('degree')?.invalid && edu.get('degree')?.touched) {
                        <small class="p-error">
                            {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                        </small>
                        }
                    </div>

                    <div class="field">
                        <label>{{ 'PROFILE.EDUCATION.SPECIALTY' | translate }} *</label>
                        <input type="text" pInputText formControlName="specialty"
                            [class]="{'p-invalid': edu.get('specialty')?.invalid && edu.get('specialty')?.touched}">
                        @if (edu.get('specialty')?.invalid && edu.get('specialty')?.touched) {
                        <small class="p-error">
                            {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                        </small>
                        }
                    </div>

                    <div class="field">
                        <label>{{ 'PROFILE.EDUCATION.YEAR' | translate }} *</label>
                        <p-inputNumber [min]="1900" [max]="currentYear" formControlName="year"
                            [class]="{'p-invalid': edu.get('year')?.invalid && edu.get('year')?.touched}">
                        </p-inputNumber>
                    </div>

                    <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                        (click)="removeEducation(i)">
                    </button>
                </div>
                }
                <button type="button" pButton icon="pi pi-plus" class="p-button-text" (click)="addEducation()">
                    {{ 'PROFILE.EDUCATION.ADD_EDUCATION' | translate }}
                </button>
            </div>
        </p-panel>

        <!-- Experience Section -->
        <p-panel [header]="'PROFILE.EXPERIENCE.TITLE' | translate" [toggleable]="true">
            <div formArrayName="experience" class="array-container">
                @for (exp of experience.controls; track i; let i = $index) {
                <div [formGroupName]="i" class="array-item">
                    <div class="form-grid">
                        <div class="field">
                            <label>{{ 'PROFILE.EXPERIENCE.COMPANY' | translate }} *</label>
                            <input type="text" pInputText formControlName="company"
                                [class]="{'p-invalid': exp.get('company')?.invalid && exp.get('company')?.touched}">
                            @if (exp.get('company')?.invalid && exp.get('company')?.touched) {
                            <small class="p-error">
                                {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                            </small>
                            }
                        </div>

                        <div class="field">
                            <label>{{ 'PROFILE.EXPERIENCE.POSITION' | translate }} *</label>
                            <input type="text" pInputText formControlName="position"
                                [class]="{'p-invalid': exp.get('position')?.invalid && exp.get('position')?.touched}">
                            @if (exp.get('position')?.invalid && exp.get('position')?.touched) {
                            <small class="p-error">
                                {{ 'PROFILE.VALIDATION.REQUIRED' | translate }}
                            </small>
                            }
                        </div>

                        <div class="field">
                            <label>{{ 'PROFILE.EXPERIENCE.START_DATE' | translate }} *</label>
                            <p-datepicker formControlName="startDate" dateFormat="yy-mm-dd" [showIcon]="true"
                                [class]="{'p-invalid': exp.get('startDate')?.invalid && exp.get('startDate')?.touched}">
                            </p-datepicker>
                        </div>

                        <div class="field">
                            <label>{{ 'PROFILE.EXPERIENCE.END_DATE' | translate }}</label>
                            <p-datepicker formControlName="endDate" dateFormat="yy-mm-dd" [showIcon]="true"
                                [disabled]="exp.get('current')?.value">
                            </p-datepicker>
                            <p-checkbox [binary]="true" formControlName="current">
                                {{ 'PROFILE.EXPERIENCE.CURRENT' | translate }}
                              </p-checkbox>
                        </div>
                    </div>

                    <!-- Tasks -->
                    <div class="sub-array">
                        <label>{{ 'PROFILE.EXPERIENCE.TASKS' | translate }}</label>
                        <div formArrayName="tasks" class="array-container">
                            @for (task of getTasksArray(exp).controls; track j; let j = $index) {
                            <div class="array-item">
                                <textarea pInputTextarea [rows]="1" [formControlName]="j"
                                    [class]="{'p-invalid': task.invalid && task.touched}">
                    </textarea>
                                <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                                 (click)="removeTask(i, j)">
                                </button>
                            </div>
                            }
                            <button type="button" pButton icon="pi pi-plus" class="p-button-text"
                                (click)="addTask(getFormGroup(exp))">
                                {{ 'PROFILE.EXPERIENCE.ADD_TASK' | translate }}
                            </button>
                        </div>
                    </div>

                    <!-- Technologies -->
                    <div class="sub-array">
                        <label>{{ 'PROFILE.EXPERIENCE.STACK' | translate }}</label>
                        <div formArrayName="stack" class="array-container">
                            @for (tech of getTechArray(exp).controls; track j; let j = $index) {
                            <div class="array-item">
                                <input type="text" pInputText [formControlName]="j"
                                    [class]="{'p-invalid': tech.invalid && tech.touched}">
                                <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                                (click)="removeTech(i, j)">
                                </button>
                            </div>
                            }
                            <button type="button" pButton icon="pi pi-plus" class="p-button-text"
                                (click)="addTech(getFormGroup(exp))">
                                {{ 'PROFILE.EXPERIENCE.ADD_TECH' | translate }}
                            </button>
                        </div>
                    </div>

                    <!-- Achievements -->
                    <div class="sub-array">
                        <label>{{ 'PROFILE.EXPERIENCE.ACHIEVEMENTS.TITLE' | translate }}</label>
                        <div formArrayName="achievements" class="array-container">
                            @for (ach of getAchievementsArray(exp).controls; track j; let j = $index) {
                            <div [formGroupName]="j" class="array-item form-grid">
                                <div class="field">
                                    <label>{{ 'PROFILE.EXPERIENCE.ACHIEVEMENTS.NAME' | translate }} *</label>
                                    <input type="text" pInputText formControlName="name"
                                        [class]="{'p-invalid': ach.get('name')?.invalid && ach.get('name')?.touched}">
                                </div>

                                <div class="field">
                                    <label>{{ 'PROFILE.EXPERIENCE.ACHIEVEMENTS.INITIAL' | translate }} *</label>
                                    <p-inputNumber formControlName="initial_value"
                                        [class]="{'p-invalid': ach.get('initial_value')?.invalid && ach.get('initial_value')?.touched}">
                                    </p-inputNumber>
                                </div>

                                <div class="field">
                                    <label>{{ 'PROFILE.EXPERIENCE.ACHIEVEMENTS.FINAL' | translate }} *</label>
                                    <p-inputNumber formControlName="final_value"
                                        [class]="{'p-invalid': ach.get('final_value')?.invalid && ach.get('final_value')?.touched}">
                                    </p-inputNumber>
                                </div>

                                <div class="field">
                                    <label>{{ 'PROFILE.EXPERIENCE.ACHIEVEMENTS.UNIT' | translate }}</label>
                                    <input type="text" pInputText formControlName="uom">
                                </div>

                                <div class="field">
                                    <label>{{ 'PROFILE.EXPERIENCE.ACHIEVEMENTS.TYPE' | translate }}</label>
                                    <input type="text" pInputText formControlName="type">
                                </div>

                                <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                                    (click)="removeAchievement(i, j)">
                                </button>
                            </div>
                            }
                            <button type="button" pButton icon="pi pi-plus" class="p-button-text"
                                (click)="addAchievement(getFormGroup(exp))">
                                {{ 'PROFILE.EXPERIENCE.ACHIEVEMENTS.ADD_ACHIEVEMENT' | translate }}
                            </button>
                        </div>
                    </div>

                    <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                        (click)="removeExperience(i)">
                    </button>
                </div>
                }
                <button type="button" pButton icon="pi pi-plus" class="p-button-text" (click)="addExperience()">
                    {{ 'PROFILE.EXPERIENCE.ADD_EXPERIENCE' | translate }}
                </button>
            </div>
        </p-panel>

        <!-- Hobby Section -->
        <p-panel [header]="'PROFILE.HOBBY' | translate" [toggleable]="true">
            <div formArrayName="hobby" class="array-container">
                @for (h of hobby.controls; track i; let i = $index) {
                <div class="array-item">
                    <input type="text" pInputText [formControlName]="i" [class]="{'p-invalid': h.invalid && h.touched}">
                    <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                        (click)="removeHobby(i)">
                    </button>
                </div>
                }
                <button type="button" pButton icon="pi pi-plus" class="p-button-text" (click)="addHobby()">
                    {{ 'PROFILE.ADD_HOBBY' | translate }}
                </button>
            </div>
        </p-panel>

        <!-- Literature Section -->
        <p-panel [header]="'PROFILE.LITERATURE' | translate" [toggleable]="true">
            <div formArrayName="literature" class="array-container">
                @for (l of literature.controls; track i; let i = $index) {
                <div class="array-item">
                    <input type="text" pInputText [formControlName]="i" [class]="{'p-invalid': l.invalid && l.touched}">
                    <button type="button" pButton icon="pi pi-times" class="p-button-text p-button-danger"
                        (click)="removeLiterature(i)">
                    </button>
                </div>
                }
                <button type="button" pButton icon="pi pi-plus" class="p-button-text" (click)="addLiterature()">
                    {{ 'PROFILE.ADD_LITERATURE' | translate }}
                </button>
            </div>
        </p-panel>

        <!-- Form Actions -->
        <div class="form-actions">
            <button type="submit" pButton [label]="'PROFILE.ACTIONS.SAVE' | translate"
                [disabled]="profileForm.invalid || loading">
            </button>

            <button type="button" pButton [label]="'PROFILE.ACTIONS.RESET' | translate" class="p-button-secondary"
                (click)="resetForm()">
            </button>

            <button type="button" pButton [label]="'PROFILE.ACTIONS.EXPORT_YAML' | translate" class="p-button-help"
                (click)="showPreview('yaml')">
            </button>

            <button type="button" pButton [label]="'PROFILE.ACTIONS.EXPORT_TXT' | translate" class="p-button-help"
                (click)="showPreview('txt')">
            </button>

            <p-fileUpload mode="basic" chooseLabel="Import YAML" accept=".yaml,.yml" (onSelect)="onFileSelect($event)"
                styleClass="p-button-outlined">
            </p-fileUpload>
        </div>
    </form>

    <!-- Preview Dialog -->
    <p-dialog header="{{ 'PROFILE.PREVIEW_TITLE' | translate }}" [(visible)]="previewVisible" [modal]="true"
        [style]="{ width: '50vw' }" [maximizable]="true">
        <pre class="preview-content">{{ previewContent }}</pre>
        <ng-template pTemplate="footer">
            <button pButton [label]="'PROFILE.DOWNLOAD' | translate" icon="pi pi-download"
                (click)="downloadFile(previewContent, previewFormat)">
            </button>
            <button pButton [label]="'PROFILE.CLOSE' | translate" class="p-button-secondary"
                (click)="closePreview()">
            </button>
        </ng-template>
    </p-dialog>
</div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\profile\profile-edit\profile-edit.component.spec.ts ---

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ProfileEditComponent } from './profile-edit.component';

describe('ProfileEditComponent', () => {
  let component: ProfileEditComponent;
  let fixture: ComponentFixture<ProfileEditComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ProfileEditComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ProfileEditComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\profile\profile-edit\profile-edit.component.ts ---

import { Component, inject, OnInit } from '@angular/core';
import { MessageService } from 'primeng/api';
import { FormBuilder, Validators, FormArray, FormGroup, AbstractControl, ValidationErrors } from '@angular/forms';
import { format } from 'date-fns';
import { Router } from '@angular/router';
import { Person, Skill, Education, Language } from '../../../../person-schema';
import { ProfileService } from '../../../../shared/profile/profile.service';
import { TranslateService } from '@ngx-translate/core';

@Component({
  selector: 'app-profile-edit',
  templateUrl: './profile-edit.component.html',
  styleUrls: ['./profile-edit.component.scss'],
  standalone: false,
  providers: [MessageService]
})
export class ProfileEditComponent implements OnInit {
  private fb = inject(FormBuilder);
  private translate = inject(TranslateService);
  
  profileForm = this.fb.group({
    name: ['', [Validators.required, Validators.maxLength(100)]],
    gender: ['unknown' as 'unknown' | 'male' | 'female'],
    desiredPositions: this.fb.array([]),
    contact: this.fb.group({
      phone: ['', [Validators.pattern(/^\+[0-9]{11}$/)]],
      email: ['', [Validators.required, Validators.email, Validators.maxLength(100)]],
      linkedin: ['', [this.urlValidator]],
      github: ['', [this.urlValidator]]
    }),
    location: this.fb.group({
      country: [''],
      city: ['', [Validators.required, Validators.maxLength(50)]],
      relocation: [false as boolean],
      remote: [false as boolean],
      business_trips: [false as boolean]
    }),
    languages: this.fb.array([]),
    skills: this.fb.array([]),
    education: this.fb.array([]),
    experience: this.fb.array([]),
    hobby: this.fb.array([]),
    literature: this.fb.array([])
  });
  loading = false;
  previewVisible = false;
  previewContent = '';
  previewFormat: 'yaml' | 'txt' = 'yaml';
  languageLevels = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'];
  genderOptions = [
    { label: this.translate.instant('PROFILE.PERSONAL_INFO.GENDER_OPTIONS.MALE'), value: 'male' },
    { label: this.translate.instant('PROFILE.PERSONAL_INFO.GENDER_OPTIONS.FEMALE'), value: 'female' },
    { label: this.translate.instant('PROFILE.PERSONAL_INFO.GENDER_OPTIONS.UNKNOWN'), value: 'unknown' }
  ];  

  constructor(
    private profileService: ProfileService,
    private messageService: MessageService,
    private router: Router
  ) {}
  

  ngOnInit(): void {
    this.loadProfile();
    this.translate.get([
      'PROFILE.PERSONAL_INFO.GENDER_OPTIONS.MALE',
      'PROFILE.PERSONAL_INFO.GENDER_OPTIONS.FEMALE', 
      'PROFILE.PERSONAL_INFO.GENDER_OPTIONS.UNKNOWN'
    ]).subscribe(translations => {
      this.genderOptions = [
        { label: translations['PROFILE.PERSONAL_INFO.GENDER_OPTIONS.MALE'], value: 'male' },
        { label: translations['PROFILE.PERSONAL_INFO.GENDER_OPTIONS.FEMALE'], value: 'female' },
        { label: translations['PROFILE.PERSONAL_INFO.GENDER_OPTIONS.UNKNOWN'], value: 'unknown' }
      ];
    });
  }
  private patchFormValues(profile: Person): void {
    this.clearAllArrays();
  
    this.profileForm.patchValue({
      name: profile.name,
      gender: profile.gender
    });
  
    if (this.contact) {
      this.contact.patchValue({
        phone: profile.contact.phone || '',
        email: profile.contact.email || '',
        linkedin: profile.contact['linkedin'] || '',
        github: profile.contact['github'] || ''
      });
    }
  
    if (this.location) {
      this.location.patchValue({
        country: profile.location.country || '',
        city: profile.location.city || '',
        relocation: profile.location.relocation || false,
        remote: profile.location.remote || false,
        business_trips: profile.location.business_trips || false
      });
    }
  
    profile.skills?.forEach(skill => this.addSkill(skill));
    
    profile.desiredPositions?.forEach(pos => this.addDesiredPosition(pos));
    profile.languages?.forEach(lang => this.addLanguage(lang));
    profile.education?.forEach(edu => this.addEducation(edu));
    
    profile.experience?.forEach(exp => {
      const expForForm = {
        ...exp,
        startDate: exp.startDate ? new Date(exp.startDate) : null,
        endDate: exp.endDate ? new Date(exp.endDate) : null,
        current: !exp.endDate // Если нет endDate, значит текущая работа
      };
      this.addExperience(expForForm);
    });

    profile.hobby?.forEach(h => this.addHobby(h));
    profile.literature?.forEach(l => this.addLiterature(l));
  }
  closePreview(): void {
    this.previewVisible = false;
  }
  private urlValidator(control: AbstractControl): ValidationErrors | null {
    if (!control.value || control.value === '') {
      return null; 
    }
    
    const url = control.value;
    if (url.includes('.') || url.startsWith('http://') || url.startsWith('https://')) {
      return null;
    }
    return { invalidUrl: true };
  }
  compareGenderObjects(option: any, value: any): boolean {
    if (!value || !option) return false;
    if (typeof value === 'object') {
      return option.value === value.value;
    }
    return option.value === value;
  }
  get desiredPositions(): FormArray {
    return this.profileForm.get('desiredPositions') as FormArray;
  }

  get languages(): FormArray {
    return this.profileForm.get('languages') as FormArray;
  }

  get skills(): FormArray {
    return this.profileForm.get('skills') as FormArray;
  }
  get contact(): FormGroup {
    return this.profileForm.get('contact') as FormGroup;
  }
  
  get location(): FormGroup {
    return this.profileForm.get('location') as FormGroup;
  }
  
  get contactEmail() {
    return this.contact.get('email');
  }
  
  get contactPhone() {
    return this.contact.get('phone');
  }
  
  get contactLinkedin() {
    return this.contact.get('linkedin');
  }
  
  get contactGithub() {
    return this.contact.get('github');
  }
  
  get locationCountry() {
    return this.location.get('country');
  }
  
  get locationCity() {
    return this.location.get('city');
  }
  
  get locationRelocation() {
    return this.location.get('relocation');
  }
  
  get locationRemote() {
    return this.location.get('remote');
  }
  
  get locationBusinessTrips() {
    return this.location.get('business_trips');
  }
  get education(): FormArray {
    return this.profileForm.get('education') as FormArray;
  }

  get experience(): FormArray {
    return this.profileForm.get('experience') as FormArray;
  }

  get hobby(): FormArray {
    return this.profileForm.get('hobby') as FormArray;
  }

  get literature(): FormArray {
    return this.profileForm.get('literature') as FormArray;
  }

  getFormGroup(control: AbstractControl): FormGroup {
    return control as FormGroup;
  }
  
  clearAllArrays(): void {
    this.desiredPositions.clear();
    this.languages.clear();
    this.skills.clear();
    this.education.clear();
    this.experience.clear();
    this.hobby.clear();
    this.literature.clear();
  }

  addDesiredPosition(value = ''): void {
    this.desiredPositions.push(this.fb.control(value, [Validators.required, Validators.maxLength(100)]));
  }

  removeDesiredPosition(index: number): void {
    this.desiredPositions.removeAt(index);
  }

  addLanguage(lang?: Language): void {
    this.languages.push(this.fb.group({
      language: [lang?.language || '', [Validators.required, Validators.maxLength(50)]],
      level: [lang?.level || 'B2', [Validators.required]]
    }));
  }

  removeLanguage(index: number): void {
    this.languages.removeAt(index);
  }

  addSkill(skill?: Skill): void {
    const defaultDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    
    this.skills.push(this.fb.group({
      area: [skill?.area || '', [Validators.required, Validators.maxLength(50)]],
      name: [skill?.name || '', [Validators.required, Validators.maxLength(50)]],
      level: [skill?.level || 5, [Validators.required, Validators.min(1), Validators.max(10)]],
      date: [skill?.date || defaultDate, [Validators.required]] // string, не Date!
    }));
  }

  removeSkill(index: number): void {
    this.skills.removeAt(index);
  }

  addEducation(edu?: Education): void {
    this.education.push(this.fb.group({
      institution: [edu?.institution || '', [Validators.required, Validators.maxLength(100)]],
      degree: [edu?.degree || '', [Validators.required, Validators.maxLength(50)]],
      specialty: [edu?.specialty || '', [Validators.required, Validators.maxLength(100)]],
      year: [edu?.year || null, [Validators.required, Validators.min(1900), Validators.max(new Date().getFullYear())]]
    }));
  }

  removeEducation(index: number): void {
    this.education.removeAt(index);
  }
  get currentYear(): number {
    return new Date().getFullYear();
  }

  addExperience(exp?: any): void {
    const expGroup = this.fb.group({
      company: [exp?.company || '', [Validators.required, Validators.maxLength(100)]],
      position: [exp?.position || '', [Validators.required, Validators.maxLength(100)]],
      startDate: [exp?.startDate || '', [Validators.required]],
      endDate: [exp?.endDate || ''],
      current: [exp?.current || false],
      tasks: this.fb.array([]),
      stack: this.fb.array([]),
      achievements: this.fb.array([])
    });
  
    // Заполняем массивы если есть данные
    if (exp?.tasks) {
      exp.tasks.forEach((task: string) => this.addTask(expGroup, task));
    }
    if (exp?.stack) {
      exp.stack.forEach((tech: string) => this.addTech(expGroup, tech));
    }
    if (exp?.achievements) {
      exp.achievements.forEach((ach: any) => this.addAchievement(expGroup, ach));
    }
    
    this.experience.push(expGroup);
  }

  addTask(exp: FormGroup, value: string = ''): void {
    const tasks = exp.get('tasks') as FormArray;
    tasks.push(this.fb.control(value));
  }
  
  addTech(exp: FormGroup, value: string = ''): void {
    const techArray = exp.get('stack') as FormArray;
    techArray.push(this.fb.control(value, [Validators.required, Validators.maxLength(50)]));
  }
  
  addAchievement(exp: FormGroup, ach?: any): void {
    const achievementsArray = exp.get('achievements') as FormArray;
    achievementsArray.push(this.fb.group({
      name: [ach?.name || '', [Validators.required, Validators.maxLength(100)]],
      initial_value: [ach?.initial_value || 0, [Validators.required, Validators.min(0)]],
      final_value: [ach?.final_value || 0, [Validators.required, Validators.min(0)]],
      uom: [ach?.uom || ''],
      type: [ach?.type || '']
    }));
  }

  getExperienceGroup(index: number): FormGroup {
    return this.experience.at(index) as FormGroup;
  }

  getTasksArray(exp: AbstractControl): FormArray {
    const formGroup = exp as FormGroup;
    return formGroup.get('tasks') as FormArray;
  }
  
  getTechArray(exp: AbstractControl): FormArray {
    const formGroup = exp as FormGroup;
    return formGroup.get('stack') as FormArray;
  }
  
  getAchievementsArray(exp: AbstractControl): FormArray {
    const formGroup = exp as FormGroup;
    return formGroup.get('achievements') as FormArray;
  }
  
  removeTask(expIndex: number, taskIndex: number): void {
    const expGroup = this.experience.at(expIndex) as FormGroup;
    const tasksArray = expGroup.get('tasks') as FormArray;
    tasksArray.removeAt(taskIndex);
  }
  
  removeTech(expIndex: number, techIndex: number): void {
    const expGroup = this.experience.at(expIndex) as FormGroup;
    const techArray = expGroup.get('stack') as FormArray;
    techArray.removeAt(techIndex);
  }
  removeAchievement(expIndex: number, achievementIndex: number): void {
    const expGroup = this.experience.at(expIndex) as FormGroup;
    const achievementsArray = expGroup.get('achievements') as FormArray;
    achievementsArray.removeAt(achievementIndex);
  }

  removeExperience(index: number): void {
    this.experience.removeAt(index);
  }

  addHobby(value = ''): void {
    this.hobby.push(this.fb.control(value, [Validators.maxLength(100)]));
  }

  removeHobby(index: number): void {
    this.hobby.removeAt(index);
  }

  addLiterature(value = ''): void {
    this.literature.push(this.fb.control(value, [Validators.maxLength(200)]));
  }

  removeLiterature(index: number): void {
    this.literature.removeAt(index);
  }

  getProfileDataFromForm(): Person {
    const formValue = this.profileForm.value;
    
    // Преобразуем даты в правильный формат YYYY-MM-DD
    const skills = this.skills.value.map((skill: any) => ({
      area: skill.area || '',
      name: skill.name || '',
      level: Number(skill.level) || 5,
      date: this.formatDateToYYYYMMDD(skill.date) // Должен быть string в формате YYYY-MM-DD
    }));
  
    // Валидируем URL
    const linkedin = this.validateAndFormatUrl(formValue.contact?.['linkedin'] || '');
    const github = this.validateAndFormatUrl(formValue.contact?.['github'] || '');
  
    // Преобразуем опыт работы
    const experience = this.experience.value.map((exp: any) => ({
      company: exp.company || '',
      position: exp.position || '',
      startDate: this.formatDateToYYYYMMDD(exp.startDate), // string YYYY-MM-DD
      endDate: exp.current ? null : this.formatDateToYYYYMMDD(exp.endDate), // string YYYY-MM-DD или null
      tasks: exp.tasks || [],
      stack: exp.stack || [],
      achievements: exp.achievements || []
    }));
  
    return {
      name: formValue.name || '',
      gender: (formValue.gender || 'unknown') as 'male' | 'female' | 'unknown',
      desiredPositions: this.desiredPositions.value || [],
      contact: {
        phone: formValue.contact?.phone || '',
        email: formValue.contact?.email || '',
        linkedin: linkedin,
        github: github
      },
      location: {
        country: formValue.location?.country || '',
        city: formValue.location?.city || '',
        relocation: !!formValue.location?.relocation,
        remote: !!formValue.location?.remote,
        business_trips: !!formValue.location?.business_trips
      },
      languages: this.languages.value.map((l: any) => ({
        language: l.language || '',
        level: l.level || 'B2'
      })),
      skills: skills,
      education: this.education.value.map((e: any) => ({
        institution: e.institution || '',
        degree: e.degree || '',
        specialty: e.specialty || '',
        year: Number(e.year) || new Date().getFullYear()
      })),
      experience: experience,
      hobby: this.hobby.value || [],
      literature: this.literature.value || []
    };
  }
  
  // Преобразование даты в формат YYYY-MM-DD
  private formatDateToYYYYMMDD(date: any): string {
    if (!date) {
      return new Date().toISOString().split('T')[0]; // Текущая дата по умолчанию
    }
  
    try {
      if (date instanceof Date) {
        return date.toISOString().split('T')[0];
      }
      
      if (typeof date === 'string') {
        // Если уже в правильном формате
        if (date.match(/^\d{4}-\d{2}-\d{2}$/)) {
          return date;
        }
        
        // Пытаемся распарсить другие форматы
        const parsedDate = new Date(date);
        if (!isNaN(parsedDate.getTime())) {
          return parsedDate.toISOString().split('T')[0];
        }
      }
    } catch (error) {
      console.error('Date parsing error:', error);
    }
    
    // Fallback - текущая дата
    return new Date().toISOString().split('T')[0];
  }
  
  // Валидация и форматирование URL
  private validateAndFormatUrl(url: string): string {
    if (!url || url.trim() === '') {
      return '';
    }
  
    const trimmedUrl = url.trim();
    
    // Если уже валидный URL, возвращаем как есть
    if (trimmedUrl.startsWith('http://') || trimmedUrl.startsWith('https://')) {
      return trimmedUrl;
    }
    
    // Если похоже на домен, добавляем https://
    if (trimmedUrl.includes('.') && !trimmedUrl.includes(' ')) {
      return `https://${trimmedUrl}`;
    }
    
    // Для некорректных URL возвращаем пустую строку
    return '';
  }
  
  // Преобразование Date в строку формата YYYY-MM-DD
  private formatDateForBackend(date: any): string {
    if (!date) return '';
    
    if (date instanceof Date) {
      return date.toISOString().split('T')[0]; // YYYY-MM-DD
    }
    
    if (typeof date === 'string') {
      // Если уже строка, проверяем формат
      if (date.match(/^\d{4}-\d{2}-\d{2}$/)) {
        return date;
      }
      // Пытаемся преобразовать из других форматов
      const parsedDate = new Date(date);
      if (!isNaN(parsedDate.getTime())) {
        return parsedDate.toISOString().split('T')[0];
      }
    }
    
    return '';
  }
  
  // Валидация и форматирование URL
  private formatUrl(url: string): string {
    if (!url) return '';
    
    // Если URL уже начинается с http:// или https://, оставляем как есть
    if (url.startsWith('http://') || url.startsWith('https://')) {
      return url;
    }
    
    // Если есть точка (домен), добавляем https://
    if (url.includes('.') && !url.includes(' ')) {
      return `https://${url}`;
    }
    
    // Для пустых или некорректных значений возвращаем пустую строку
    return '';
  }
  
  private ensureUrlProtocol(url: string): string {
    if (!url) return '';
    if (url.startsWith('http://') || url.startsWith('https://')) {
      return url;
    }
    if (url.includes('.')) {
      return `https://${url}`;
    }
    return '';
  }

  showPreview(format: 'yaml' | 'txt'): void {
    const profileData = this.getProfileDataFromForm();
    this.previewFormat = format;
    
    if (format === 'yaml') {
      this.previewContent = this.profileService.exportToYaml(profileData);
    } else {
      this.previewContent = this.profileService.exportToTxt(profileData);
    }
    
    this.previewVisible = true;
  }
  private showSaveError(error: any): void {
    console.error('Save error details:', error);
    
    let errorMessage = this.translate.instant('PROFILE.ACTIONS.SAVE_ERROR');
    
    if (error?.message) {
      errorMessage += `: ${error.message}`;
    }
    
    this.messageService.add({
      severity: 'error',
      summary: errorMessage,
      life: 5000
    });
  }
  
  saveProfile(): void {
    if (this.profileForm.invalid) {
      this.markAllAsTouched();
      this.messageService.add({
        severity: 'error',
        summary: this.translate.instant('PROFILE.VALIDATION.FORM_ERROR')
      });
      return;
    }
  
    this.loading = true;
    const profileData = this.getProfileDataFromForm();
  
    this.profileService.saveProfile(profileData).subscribe({
      next: (success) => {
        this.loading = false;
        if (success) {
          this.messageService.add({
            severity: 'success',
            summary: this.translate.instant('PROFILE.ACTIONS.SAVE_SUCCESS')
          });
          this.router.navigate(['/profile/view']);
        } else {
          this.showSaveError(new Error('Unknown save error'));
        }
      },
      error: (error) => {
        this.loading = false;
        this.showSaveError(error);
      }
    });
  }
  onFileSelect(event: any): void {
    const file = event.files[0];
    if (!file) return;
  
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const content = e.target?.result as string;
        this.profileService.importFromYaml(content).subscribe({
          next: (profile) => {
            if (profile) {
              this.patchFormValues(profile);
              this.messageService.add({
                severity: 'success',
                summary: this.translate.instant('PROFILE.ACTIONS.IMPORT_SUCCESS')
              });
            } else {
              this.messageService.add({
                severity: 'error',
                summary: this.translate.instant('PROFILE.ACTIONS.IMPORT_ERROR')
              });
            }
          },
          error: (error) => {
            console.error('Import error:', error);
            this.messageService.add({
              severity: 'error',
              summary: this.translate.instant('PROFILE.ACTIONS.IMPORT_ERROR'),
              detail: error.message
            });
          }
        });
      } catch (e) {
        console.error('File reading error:', e);
        this.messageService.add({
          severity: 'error',
          summary: this.translate.instant('PROFILE.ACTIONS.IMPORT_ERROR')
        });
      }
    };
    reader.readAsText(file);
  }

  downloadFile(content: string, format: 'yaml' | 'txt'): void {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `profile_${formatDate(new Date(), 'yyyyMMdd')}.${format}`;
    a.click();
    window.URL.revokeObjectURL(url);
  }

  resetForm(): void {
    if (confirm(this.translate.instant('PROFILE.ACTIONS.RESET_CONFIRM'))) {
      this.loadProfile();
    }
  }

  private markAllAsTouched(): void {
    Object.values(this.profileForm.controls).forEach(control => {
      control.markAsTouched();
      if (control instanceof FormGroup) {
        Object.values(control.controls).forEach(subControl => {
          subControl.markAsTouched();
        });
      } else if (control instanceof FormArray) {
        control.controls.forEach(arrayControl => {
          arrayControl.markAsTouched();
          if (arrayControl instanceof FormGroup) {
            Object.values(arrayControl.controls).forEach(subControl => {
              subControl.markAsTouched();
            });
          }
        });
      }
    });
  }
  loadProfile(): void {
    this.loading = true;
    this.profileService.loadProfile().subscribe({
      next: (profile) => {
        if (profile) {
          this.patchFormValues(profile);
        }
        this.loading = false;
      },
      error: (error) => {
        console.error('Error loading profile:', error);
        this.loading = false;
        this.messageService.add({
          severity: 'error',
          summary: 'Ошибка загрузки профиля',
          detail: error.message
        });
      }
    });
  }
  getCompletionPercentage(): number {
    const totalFields = 15;
    let completedFields = 0;

    if (this.profileForm.get('name')?.value) completedFields++;
    if (this.profileForm.get('contact.email')?.value) completedFields++;
    if (this.profileForm.get('location.city')?.value) completedFields++;
    if (this.desiredPositions.length > 0) completedFields++;
    if (this.languages.length > 0) completedFields++;
    if (this.skills.length > 0) completedFields++;
    if (this.education.length > 0) completedFields++;
    if (this.experience.length > 0) completedFields++;

    return Math.round((completedFields / totalFields) * 100);
  }
}

function formatDate(date: Date, formatStr: string): string {
  return format(date, formatStr);
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\profile\profile-view\profile-view.component.html ---

@if(loading) {
  <div class="loading-container">
    <p-progressSpinner></p-progressSpinner>
    <p>{{ 'LOADING.PROFILE' | translate }}</p>
  </div>
  } @else if (supabase.currentUser && userProfile) {
  <div class="profile-container">
    <div class="profile-header">
      <p-avatar [image]="userAvatar" size="xlarge" shape="circle"></p-avatar>
      <h2>{{ userProfile.name }}</h2>
      <p>{{ userProfile.contact.email }}</p>
      <p>{{ userProfile.contact.phone || ('PROFILE.CONTACT_INFO.PHONE_PLACEHOLDER' | translate) }}</p>
    </div>
  
    <!-- Вкладки для переключения между информацией и резюме -->
    <div class="profile-tabs">
      <button 
        [class]="['tab', activeTab === 'info' ? 'active' : '']"
        (click)="activeTab = 'info'">
        <i class="pi pi-user"></i>
        {{ 'PROFILE.INFO' | translate }}
      </button>
      
      <button 
        [class]="['tab', activeTab === 'resumes' ? 'active' : '']"
        (click)="activeTab = 'resumes'">
        <i class="pi pi-briefcase"></i>
        {{ 'PROFILE.RESUMES' | translate }}
      </button>
    </div>
  
    <!-- Основная информация профиля -->
    <div *ngIf="activeTab === 'info'" class="profile-info">
      <div class="profile-details">
        <!-- Личная информация -->
        <div class="profile-section">
          <h3>{{ 'PROFILE.PERSONAL_INFO.TITLE' | translate }}</h3>
          <p><strong>{{ 'PROFILE.PERSONAL_INFO.GENDER' | translate }}:</strong> {{ getGenderLabel(userProfile.gender) }}</p>
          <p><strong>{{ 'PROFILE.PERSONAL_INFO.DESIRED_POSITIONS' | translate }}:</strong> {{ userProfile.desiredPositions?.join(', ') || ('PROFILE.PERSONAL_INFO.NOT_SPECIFIED' | translate) }}</p>
        </div>
  
        <!-- Местоположение -->
        <div class="profile-section">
          <h3>{{ 'PROFILE.LOCATION.TITLE' | translate }}</h3>
          <p><strong>{{ 'PROFILE.LOCATION.CITY' | translate }}:</strong> {{ userProfile.location.city }}</p>
          <p><strong>{{ 'PROFILE.LOCATION.COUNTRY' | translate }}:</strong> {{ userProfile.location.country || ('PROFILE.LOCATION.NOT_SPECIFIED' | translate) }}</p>
          <p><strong>{{ 'PROFILE.LOCATION.RELOCATION' | translate }}:</strong> {{ userProfile.location.relocation ? ('YES' | translate) : ('NO' | translate) }}</p>
          <p><strong>{{ 'PROFILE.LOCATION.REMOTE' | translate }}:</strong> {{ userProfile.location.remote ? ('YES' | translate) : ('NO' | translate) }}</p>
          <p><strong>{{ 'PROFILE.LOCATION.BUSINESS_TRIPS' | translate }}:</strong> {{ userProfile.location.business_trips ? ('YES' | translate) : ('NO' | translate) }}</p>
        </div>
  
        <!-- Контакты -->
        <div class="profile-section">
          <h3>{{ 'PROFILE.CONTACT_INFO.TITLE' | translate }}</h3>
          <p><strong>LinkedIn:</strong> {{ userProfile.contact['linkedin'] || ('PROFILE.CONTACT_INFO.NOT_SPECIFIED' | translate) }}</p>
          <p><strong>GitHub:</strong> {{ userProfile.contact['github'] || ('PROFILE.CONTACT_INFO.NOT_SPECIFIED' | translate) }}</p>
        </div>
  
        <!-- Языки -->
        <div class="profile-section" *ngIf="userProfile.languages && userProfile.languages.length">
          <h3>{{ 'PROFILE.LANGUAGES.TITLE' | translate }}</h3>
          <div *ngFor="let lang of userProfile.languages">
            <p>{{ lang.language }} - {{ lang.level }}</p>
          </div>
        </div>
  
        <!-- Навыки -->
        <div class="profile-section" *ngIf="userProfile.skills && userProfile.skills.length">
          <h3>{{ 'PROFILE.SKILLS.TITLE' | translate }}</h3>
          <div *ngFor="let skill of userProfile.skills">
            <p>{{ skill.area }}: {{ skill.name }} ({{ skill.level }}/10)</p>
          </div>
        </div>
  
        <!-- Образование -->
        <div class="profile-section" *ngIf="userProfile.education && userProfile.education.length">
          <h3>{{ 'PROFILE.EDUCATION.TITLE' | translate }}</h3>
          <div *ngFor="let edu of userProfile.education">
            <p>{{ edu.institution }} - {{ edu.degree }}, {{ edu.specialty }} ({{ edu.year }})</p>
          </div>
        </div>
  
        <!-- Опыт работы -->
        <div class="profile-section" *ngIf="userProfile.experience && userProfile.experience.length">
          <h3>{{ 'PROFILE.EXPERIENCE.TITLE' | translate }}</h3>
          <div *ngFor="let exp of userProfile.experience" class="experience-item">
            <h4>{{ exp.company }} - {{ exp.position }}</h4>
            <p>{{ exp.startDate }} - {{ exp.endDate || ('PROFILE.EXPERIENCE.CURRENT' | translate) }}</p>
            <p><strong>{{ 'PROFILE.EXPERIENCE.STACK' | translate }}:</strong> {{ exp.stack.join(', ') }}</p>
            <div *ngIf="exp.tasks && exp.tasks.length">
              <strong>{{ 'PROFILE.EXPERIENCE.TASKS' | translate }}:</strong>
              <ul>
                <li *ngFor="let task of exp.tasks">{{ task }}</li>
              </ul>
            </div>
            <div *ngIf="exp.achievements && exp.achievements.length">
              <strong>{{ 'PROFILE.EXPERIENCE.ACHIEVEMENTS.TITLE' | translate }}:</strong>
              <ul>
                <li *ngFor="let ach of exp.achievements">
                  {{ ach.name }}: {{ ach.initial_value }} → {{ ach.final_value }} {{ ach.uom || '' }}
                </li>
              </ul>
            </div>
          </div>
        </div>
  
        <!-- Хобби -->
        <div class="profile-section" *ngIf="userProfile.hobby && userProfile.hobby.length">
          <h3>{{ 'PROFILE.HOBBY' | translate }}</h3>
          <p>{{ userProfile.hobby.join(', ') }}</p>
        </div>
  
        <!-- Литература -->
        <div class="profile-section" *ngIf="userProfile.literature && userProfile.literature.length">
          <h3>{{ 'PROFILE.LITERATURE' | translate }}</h3>
          <p>{{ userProfile.literature.join(', ') }}</p>
        </div>
      </div>
  
      <div class="profile-actions">
        <button pButton [label]="'PROFILE.PERSONAL_INFO.EDIT' | translate" icon="pi pi-pencil" 
                routerLink="/profile/edit" class="p-button-primary"></button>
        <button pButton [label]="'BUTTON.LOGOUT' | translate" icon="pi pi-sign-out" class="p-button-danger" 
                (click)="signOut()"></button>
      </div>
    </div>
  
    <!-- Управление резюме -->
    <div *ngIf="activeTab === 'resumes'" class="profile-resumes">
      <app-resume-management></app-resume-management>
    </div>
  </div>
  } @else if (supabase.currentUser && !userProfile) {
  <div class="profile-empty">
    <p>{{ 'PROFILE.VIEW.EMPTY' | translate }}</p>
    <button pButton [label]="'PROFILE.PERSONAL_INFO.EDIT' | translate" icon="pi pi-user-edit" 
            routerLink="/profile/edit" class="p-button-primary"></button>
  </div>
  } @else {
  <div class="not-authorized">
    <p>{{ 'PROFILE.PROFILE_VIEW.LOGIN_PROMPT' | translate }}</p>
    <a routerLink="/login">{{ 'AUTH.GO_TO_LOGIN' | translate }}</a>
  </div>
  }

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\profile\profile-view\profile-view.component.spec.ts ---

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ProfileViewComponent } from './profile-view.component';

describe('ProfileViewComponent', () => {
  let component: ProfileViewComponent;
  let fixture: ComponentFixture<ProfileViewComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ProfileViewComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ProfileViewComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\profile\profile-view\profile-view.component.ts ---

import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { filter, take } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { AvatarModule } from 'primeng/avatar';
import { ButtonModule } from 'primeng/button';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { TranslatePipe, TranslateService } from '@ngx-translate/core';
import { Person } from '../../../../person-schema';
import { SupabaseService } from '../../../../shared/db/supabase.service';
import { ProfileService } from '../../../../shared/profile/profile.service';

@Component({
  selector: 'app-profile-view',
  templateUrl: './profile-view.component.html',
  styleUrls: ['./profile-view.component.scss'],
  standalone: false,
})
export class ProfileViewComponent implements OnInit {
  userProfile: Person | null = null;
  loading = true;
  activeTab: 'info' | 'resumes' = 'info';
  
  constructor(
    public supabase: SupabaseService,
    private router: Router,
    private profileService: ProfileService,
    private translate: TranslateService
  ) {}

  ngOnInit() {
    this.supabase.initialized$.pipe(
      filter(initialized => initialized),
      take(1)
    ).subscribe(() => {
      if (!this.supabase.currentUser) {
        this.router.navigate(['/login'], {
          queryParams: { returnUrl: this.router.url }
        });
      } else {
        this.loadProfile();
      }
    });
  }

  loadProfile(): void {
    this.loading = true;
    this.profileService.loadProfile().subscribe({
      next: (profile) => {
        this.userProfile = profile;
        this.loading = false;
      },
      error: (error) => {
        console.error('Error loading profile:', error);
        this.loading = false;
      }
    });
  }

  get userAvatar(): string {
    return this.supabase.currentUser?.user_metadata?.['avatar_url'] || 'default_avatar.jpg';
  }

  get userName(): string {
    return this.supabase.currentUser?.user_metadata?.['full_name'] || this.supabase.currentUser?.email || '';
  }

  getGenderLabel(gender: string): string {
    const genders = {
      'male': this.translate.instant('PROFILE.PERSONAL_INFO.GENDER_OPTIONS.MALE'),
      'female': this.translate.instant('PROFILE.PERSONAL_INFO.GENDER_OPTIONS.FEMALE'),
      'unknown': this.translate.instant('PROFILE.PERSONAL_INFO.GENDER_OPTIONS.UNKNOWN')
    };
    return genders[gender as keyof typeof genders] || this.translate.instant('PROFILE.PERSONAL_INFO.GENDER_OPTIONS.UNKNOWN');
  }

  async signOut() {
    await this.supabase.signOut();
    this.router.navigate(['/login']); 
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\public-offer\public-offer.component.html ---

<div class="legal-page">
    <div class="container">
        <header class="header">
            <h1>Публичная оферта</h1>
            <p class="last-updated">Последнее обновление: {{currentYear}}</p>
        </header>
      
      <div class="page-navigation">
        <div class="nav-header">
          <h3>Содержание</h3>
          <span class="nav-toggle">▼</span>
        </div>
        <ul>
          <li><a href="#general" class="nav-link">Общие положения</a></li>
          <li><a href="#terms" class="nav-link">Термины и определения</a></li>
          <li><a href="#subject" class="nav-link">Предмет договора</a></li>
          <li><a href="#services" class="nav-link">Порядок оказания услуг</a></li>
          <li><a href="#payment" class="nav-link">Стоимость и порядок расчетов</a></li>
          <li><a href="#rights" class="nav-link">Права и обязанности сторон</a></li>
          <li><a href="#refund" class="nav-link">Возврат денежных средств</a></li>
          <li><a href="#responsibility" class="nav-link">Ответственность сторон</a></li>
          <li><a href="#contacts" class="nav-link">Контакты</a></li>
        </ul>
      </div>
      
      <main class="content">
        <section id="general" class="section">
            <h2>ДОГОВОР-ОФЕРТА</h2>
            <p>о предоставлении услуг сервиса Rezulution</p>
            
            <div class="highlight">
                <p>г. Москва {{currentYear}}</p>
            </div>
            
            <p>Настоящий документ является официальным предложением (публичной офертой) владельца сервиса Rezulution (далее — «Исполнитель») заключить договор на предоставление услуг с любым физическим или юридическим лицом (далее — «Заказчик»), которое примет настоящее предложение.</p>
        </section>
  
        <section id="terms" class="section">
          <h2>1. ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ</h2>
          <p><strong>1.1. Сервис</strong> — веб-платформа Rezulution, доступная по адресу: https://rezulution.ru</p>
          <p><strong>1.2. Услуги</strong> — функциональные возможности Сервиса, включая генерацию резюме, сопроводительных писем, подготовку к собеседованиям, интеграцию с платформами поиска работы.</p>
          <p><strong>1.3. Тарифный план</strong> — пакет Услуг, предоставляемых Заказчику на определенных условиях.</p>
          <p><strong>1.4. Аккаунт</strong> — учетная запись Заказчика в Сервисе.</p>
        </section>
  
        <section id="subject" class="section">
          <h2>2. ПРЕДМЕТ ДОГОВОРА</h2>
          <p><strong>2.1.</strong> Исполнитель предоставляет Заказчику услуги доступа к функциональным возможностям Сервиса в соответствии с выбранным Тарифным планом.</p>
          <p><strong>2.2.</strong> Заказчик оплачивает Услуги Исполнителя в порядке и на условиях, установленных настоящим Договором.</p>
          <p><strong>2.3.</strong> Факт регистрации в Сервисе и/или оплаты Услуг считается безоговорочным принятием условий настоящей оферты.</p>
        </section>
  
        <section id="services" class="section">
          <h2>3. ПОРЯДОК ОКАЗАНИЯ УСЛУГ</h2>
          <p><strong>3.1.</strong> Для начала использования Услуг Заказчик проходит регистрацию в Сервисе.</p>
          <p><strong>3.2.</strong> Исполнитель предоставляет Заказчику доступ к личному кабинету и выбранным функциональным возможностям.</p>
          <p><strong>3.3.</strong> Срок оказания Услуг определяется выбранным Тарифным планом.</p>
          <p><strong>3.4.</strong> Исполнитель вправе устанавливать лимиты и ограничения на использование Сервиса.</p>
        </section>
  
        <section id="payment" class="section">
          <h2>4. СТОИМОСТЬ УСЛУГ И ПОРЯДОК РАСЧЕТОВ</h2>
          <p><strong>4.1.</strong> Стоимость Услуг определяется действующими Тарифными планами, опубликованными на Сайте.</p>
          <p><strong>4.2.</strong> Оплата производится путем безналичного расчета через платежные системы.</p>
          <p><strong>4.3.</strong> Моментом оплаты считается поступление денежных средств на расчетный счет Исполнителя.</p>
          <p><strong>4.4.</strong> Исполнитель вправе изменять стоимость Услуг с уведомлением Заказчика за 10 календарных дней.</p>
        </section>
  
        <section id="rights" class="section">
          <h2>5. ПРАВА И ОБЯЗАННОСТИ СТОРОН</h2>
          
          <h3>5.1. Исполнитель обязуется:</h3>
          <ul>
            <li>Обеспечивать работоспособность Сервиса</li>
            <li>Предоставлять Заказчику доступ к оплаченным Услугам</li>
            <li>Обеспечивать конфиденциальность данных Заказчика</li>
            <li>Оказывать техническую поддержку</li>
          </ul>
  
          <h3>5.2. Заказчик обязуется:</h3>
          <ul>
            <li>Своевременно оплачивать Услуги</li>
            <li>Не передавать учетные данные третьим лицам</li>
            <li>Не использовать Сервис для незаконной деятельности</li>
            <li>Предоставлять достоверную информацию при регистрации</li>
          </ul>
  
          <h3>5.3. Заказчик вправе:</h3>
          <ul>
            <li>Требовать оказания Услуг в полном объеме</li>
            <li>Расторгнуть Договор в одностороннем порядке</li>
            <li>Требовать возврата денежных средств в установленных случаях</li>
          </ul>
        </section>
  
        <section id="refund" class="section">
          <h2>6. ВОЗВРАТ ДЕНЕЖНЫХ СРЕДСТВ</h2>
          <p><strong>6.1.</strong> Заказчик вправе потребовать возврата денежных средств в течение 14 дней с момента оплаты, если Услуги не были предоставлены.</p>
          <p><strong>6.2.</strong> Возврат осуществляется на тот же расчетный счет, с которого была произведена оплата.</p>
          <p><strong>6.3.</strong> Возврат не производится в случае фактического оказания Услуг.</p>
        </section>
  
        <section id="responsibility" class="section">
          <h2>7. ОТВЕТСТВЕННОСТЬ СТОРОН</h2>
          <p><strong>7.1.</strong> Исполнитель не несет ответственности за невозможность оказания Услуг по причинам, не зависящим от Исполнителя.</p>
          <p><strong>7.2.</strong> Исполнитель не гарантирует трудоустройство Заказчика.</p>
          <p><strong>7.3.</strong> Заказчик несет ответственность за достоверность предоставленной информации.</p>
        </section>
  
        <section id="contacts" class="section">
          <h2>8. КОНТАКТЫ И РЕКВИЗИТЫ</h2>
          
          <div class="contact-block">
            <h3>Контактная информация</h3>
            <p><strong>Email:</strong> runos.d.hino@gmail.com</p>
            <p><strong>Телефон:</strong> +7 (980) 203-65-57</p>
            <p><strong>Сайт:</strong> https://rezulution.ru</p>
          </div>
        </section>
      </main>
      
      <footer class="footer">
        <p>&copy; {{currentYear}} Rezulution. Все права защищены.</p>
        <div class="legal-links">
          <a href="/terms-of-service">Пользовательское соглашение</a>
          <a href="/privacy-policy">Политика конфиденциальности</a>
          <a href="/public-offer">Публичная оферта</a>
          <a href="/requisites-page">Реквизиты</a>
        </div>
      </footer>
    </div>
  </div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\public-offer\public-offer.component.ts ---

import { Component, OnInit, HostListener, Inject, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

@Component({
  selector: 'app-public-offer',
  templateUrl: './public-offer.component.html',
  styleUrls: ['./public-offer.component.scss', '../../../../styles/legal-pages.common.scss']
})
export class PublicOfferComponent implements OnInit {
  currentYear = new Date().getFullYear();

  constructor(@Inject(PLATFORM_ID) private platformId: Object) {}

  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      this.setupNavigation();
    }
  }

  @HostListener('window:scroll')
  onScroll() {
    if (isPlatformBrowser(this.platformId)) {
      this.updateActiveNavLink();
    }
  }

  setupNavigation() {
    // Добавляем обработчики для плавной прокрутки
    setTimeout(() => {
      const navLinks = document.querySelectorAll('.nav-link');
      navLinks.forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const targetId = (e.target as HTMLAnchorElement).getAttribute('href')?.substring(1);
          if (targetId) {
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              const offsetTop = targetElement.offsetTop - 70;
              window.scrollTo({
                top: offsetTop,
                behavior: 'smooth'
              });
            }
          }
        });
      });
    });
  }

  updateActiveNavLink() {
    const sections = document.querySelectorAll('.section');
    const navLinks = document.querySelectorAll('.nav-link');
    
    let currentSection = '';
    
    sections.forEach(section => {
      const sectionElement = section as HTMLElement;
      const sectionTop = sectionElement.offsetTop;
      const sectionHeight = sectionElement.clientHeight;
      if (window.scrollY >= sectionTop - 100 && window.scrollY < sectionTop + sectionHeight - 100) {
        currentSection = section.id;
      }
    });

    navLinks.forEach(link => {
      link.classList.remove('active');
      const href = link.getAttribute('href');
      if (href === `#${currentSection}`) {
        link.classList.add('active');
      }
    });
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\requisites-page\requisites-page.component.html ---

<div class="payment-details">
    <div class="container">
      <header class="header">
        <h1>Реквизиты для оплаты</h1>
      </header>
      
      <main class="content">
        <section class="info-section">
          <p class="intro-text">
            Я являюсь плательщиком налога на профессиональный доход (самозанятый).
            При переводе средств для оплаты моих услуг убедитесь, что платеж осуществляется на мое имя.
          </p>
          
          <div class="details-card">
            <div class="detail-item">
              <span class="label">ФИО:</span>
              <span class="value">Стребулаев Сергей Сергеевич</span>
            </div>
            
            <div class="detail-item">
              <span class="label">ИНН:</span>
              <span class="value inn">560309167631</span>
            </div>

            <div class="detail-item">
                <span class="label">Телефон:</span>
                <span class="value inn">+7 (977) 168-77-93</span>
              </div>
          </div>
          
          <p class="security-notice">
            Оплата осуществляется безопасно через защищенный сервис ЮKassa.
          </p>
        </section>
      </main>
      
      <footer class="footer">
        <p>&copy; {{currentYear}} Rezulution. Все права защищены.</p>
        <div class="legal-links">
          <a href="/terms-of-service">Пользовательское соглашение</a>
          <a href="/privacy-policy">Политика конфиденциальности</a>
          <a href="/public-offer">Публичная оферта</a>
          <a href="/requisites-page">Реквизиты</a>
        </div>
      </footer>
    </div>
</div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\requisites-page\requisites-page.component.ts ---

import { Component } from '@angular/core';

@Component({
  selector: 'app-requisites-page',
  imports: [],
  templateUrl: './requisites-page.component.html',
  styleUrls: ['./requisites-page.component.scss', '../../../../styles/legal-pages.common.scss']
})
export class RequisitesPageComponent {
  currentYear: number = new Date().getFullYear();
}


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\terms-of-service\terms-of-service.component.html ---

<div class="legal-page">
    <div class="container">
      <header class="header">
        <h1>Пользовательское соглашение</h1>
        <p class="last-updated">Последнее обновление: {{currentYear}}</p>
      </header>
      
      <main class="content">
        <section class="section">
          <h2>1. Общие положения</h2>
          <p>1.1. Настоящее Пользовательское соглашение (далее — «Соглашение») регулирует отношения между владельцем сервиса Rezulution (далее — «Сервис») и пользователем (далее — «Пользователь») по использованию услуг Сервиса.</p>
          <p>1.2. Используя Сервис, Пользователь соглашается с условиями настоящего Соглашения.</p>
          <p>1.3. Сервис предоставляет инструменты для генерации резюме, сопроводительных писем, подготовки к собеседованиям и интеграции с платформами поиска работы.</p>
        </section>
  
        <section class="section">
          <h2>2. Условия использования</h2>
          <p>2.1. Пользователь гарантирует, что вся предоставленная информация является достоверной и актуальной.</p>
          <p>2.2. Пользователь несет ответственность за конфиденциальность своих учетных данных.</p>
          <p>2.3. Запрещается использование Сервиса для:</p>
          <ul>
            <li>Создания мошеннических или поддельных документов</li>
            <li>Нарушения авторских прав</li>
            <li>Распространения вредоносного контента</li>
            <li>Любых незаконных действий</li>
          </ul>
        </section>
  
        <section class="section">
          <h2>3. Интеллектуальная собственность</h2>
          <p>3.1. Все права на программное обеспечение и дизайн Сервиса принадлежат его владельцам.</p>
          <p>3.2. Пользователь сохраняет права на создаваемый контент (резюме, сопроводительные письма).</p>
          <p>3.3. Сервис имеет право использовать анонимизированные данные для улучшения качества услуг.</p>
        </section>
  
        <section class="section">
          <h2>4. Тарифы и оплата</h2>
          <p>4.1. Сервис предоставляет различные тарифные планы, включая бесплатный и платные варианты.</p>
          <p>4.2. Оплата производится через защищенные платежные системы.</p>
          <p>4.3. Возврат средств осуществляется в соответствии с законодательством РФ.</p>
        </section>
  
        <section class="section">
          <h2>5. Ограничение ответственности</h2>
          <p>5.1. Сервис не гарантирует трудоустройство Пользователя.</p>
          <p>5.2. Сервис не несет ответственности за решения работодателей.</p>
          <p>5.3. Пользователь самостоятельно несет ответственность за содержание создаваемых документов.</p>
        </section>
  
        <section class="section">
          <h2>6. Конфиденциальность</h2>
          <p>6.1. Сервис обязуется защищать персональные данные Пользователя в соответствии с Политикой конфиденциальности.</p>
          <p>6.2. Пользователь дает согласие на обработку персональных данных для предоставления услуг.</p>
        </section>
  
        <section class="section">
          <h2>7. Контакты</h2>
          <p>По всем вопросам обращайтесь:</p>
          <p>Email: runos.d.hino@gmail.com</p>
        </section>
      </main>
      
      <footer class="footer">
        <p>&copy; {{currentYear}} Rezulution. Все права защищены.</p>
        <div class="legal-links">
          <a href="/terms-of-service">Пользовательское соглашение</a>
          <a href="/privacy-policy">Политика конфиденциальности</a>
          <a href="/public-offer">Публичная оферта</a>
          <a href="/requisites-page">Реквизиты</a>
        </div>
      </footer>
    </div>
  </div>

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\components\Pages\terms-of-service\terms-of-service.component.ts ---

import { Component } from '@angular/core';

@Component({
  selector: 'app-terms-of-service',
  templateUrl: './terms-of-service.component.html',
  styleUrls: ['./terms-of-service.component.scss', '../../../../styles/legal-pages.common.scss']
})
export class TermsOfServiceComponent {
  currentYear: number = new Date().getFullYear();
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\interceptors\auth.interceptor.ts ---

import { Injectable } from '@angular/core';
import {
  HttpRequest,
  HttpHandler,
  HttpEvent,
  HttpInterceptor
} from '@angular/common/http';
import { Observable } from 'rxjs';
import { SupabaseService } from '../shared/db/supabase.service';
import { ConfigService } from '../shared/config/config.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  constructor(
    private supabase: SupabaseService,
    private configService: ConfigService
  ) {}

  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
    if (request.url.includes('api.together.xyz')) {
      const config = this.configService.getConfig();
      if (!config?.togetherApiKey) {
        console.error('Together API key not configured');
        return next.handle(request);
      }
  
      const authReq = request.clone({
        setHeaders: {
          Authorization: `Bearer ${config.togetherApiKey}`
        }
      });
      return next.handle(authReq);
    }
  
    if (request.url.includes('/api/') && this.supabase.currentSession) {
      const authReq = request.clone({
        setHeaders: {
          Authorization: `Bearer ${this.supabase.currentSession.access_token}`
        }
      });
      return next.handle(authReq);
    }
  
    return next.handle(request);
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\analytics.service.ts ---

import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { ConfigService } from './config/config.service';

declare global {
  interface Window {
    dataLayer: any[];
    gtag: Function;
    ym: Function;
    clarity: Function;
    hj: Function;
  }
}

@Injectable({
  providedIn: 'root'
})
export class AnalyticsService {
  private isBrowser: boolean;
  private analyticsEnabled = false;
  private scriptsLoaded = {
    googleAnalytics: false,
    yandexMetrika: false,
    microsoftClarity: false,
    hotjar: false
  };

  constructor(
    private configService: ConfigService,
    @Inject(PLATFORM_ID) private platformId: Object
  ) {
    this.isBrowser = isPlatformBrowser(this.platformId);
  }

  initializeAnalytics(settings: any): void {
    if (!this.isBrowser) return;

    const config = this.configService.getConfig();
    this.analyticsEnabled = settings.analytics;

    if (!this.analyticsEnabled) {
      console.log('Analytics disabled by user');
      return;
    }

    // Загружаем скрипты аналитики с обработкой ошибок
    this.loadAnalyticsScripts(config.analytics);
  }

  private loadAnalyticsScripts(analyticsConfig: any): void {
    // Google Analytics
    if (analyticsConfig.googleAnalyticsId) {
      this.loadGoogleAnalytics(analyticsConfig.googleAnalyticsId);
    }

    // Yandex Metrika (загружаем с обработкой блокировки)
    if (analyticsConfig.yandexMetrikaId) {
      this.loadYandexMetrika(analyticsConfig.yandexMetrikaId);
    }

    // Microsoft Clarity
    if (analyticsConfig.microsoftClarityId) {
      this.loadMicrosoftClarity(analyticsConfig.microsoftClarityId);
    }

    // Hotjar
    if (analyticsConfig.hotjarId) {
      this.loadHotjar(analyticsConfig.hotjarId);
    }
  }

  private loadGoogleAnalytics(measurementId: string): void {
    try {
      const script = document.createElement('script');
      script.async = true;
      script.src = `https://www.googletagmanager.com/gtag/js?id=${measurementId}`;
      
      script.onload = () => {
        window.dataLayer = window.dataLayer || [];
        window.gtag = function() { 
          window.dataLayer.push(arguments); 
        };
        window.gtag('js', new Date());
        window.gtag('config', measurementId, {
          page_title: document.title,
          page_location: window.location.href
        });
        this.scriptsLoaded.googleAnalytics = true;
        console.log('✅ Google Analytics initialized with ID:', measurementId);
      };

      script.onerror = (error) => {
        console.warn('❌ Google Analytics script loading failed:', error);
      };

      document.head.appendChild(script);
    } catch (error) {
      console.warn('❌ Google Analytics initialization failed:', error);
    }
  }

  private loadYandexMetrika(counterId: string): void {
    try {
      const script = document.createElement('script');
      script.type = 'text/javascript';
      
      // Добавляем обработку ошибок для скрипта
      script.onerror = (error) => {
        console.warn('❌ Yandex Metrika script loading failed (likely blocked by ad blocker):', error);
        // Не прерываем выполнение - метрика может работать частично
      };

      script.innerHTML = `
        (function(m,e,t,r,i,k,a){
          m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
          m[i].l=1*new Date();
          for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
          k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a);
        })(window, document, 'script', 'https://mc.yandex.ru/metrika/tag.js', 'ym');

        try {
          ym(${counterId}, 'init', {
            clickmap: true,
            trackLinks: true,
            accurateTrackBounce: true,
            webvisor: true,
            ecommerce: "dataLayer"
          });
          console.log('✅ Yandex Metrika initialized');
        } catch (e) {
          console.warn('❌ Yandex Metrika initialization failed:', e);
        }
      `;
      
      document.head.appendChild(script);
      this.scriptsLoaded.yandexMetrika = true;
      console.log('✅ Yandex Metrika script injected with ID:', counterId);

      // Добавляем noscript (работает даже при блокировке JavaScript)
      const noscript = document.createElement('noscript');
      noscript.innerHTML = `<div><img src="https://mc.yandex.ru/watch/${counterId}" style="position:absolute; left:-9999px;" alt="" /></div>`;
      document.body.appendChild(noscript);

    } catch (error) {
      console.warn('❌ Yandex Metrika initialization failed:', error);
    }
  }

  private loadMicrosoftClarity(projectId: string): void {
    try {
      const script = document.createElement('script');
      script.type = 'text/javascript';
      
      script.onerror = (error) => {
        console.warn('❌ Microsoft Clarity script loading failed:', error);
      };

      script.innerHTML = `
        (function(c,l,a,r,i,t,y){
          c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
          t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
          y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "${projectId}");
      `;
      
      document.head.appendChild(script);
      this.scriptsLoaded.microsoftClarity = true;
      console.log('✅ Microsoft Clarity initialized with ID:', projectId);
    } catch (error) {
      console.warn('❌ Microsoft Clarity initialization failed:', error);
    }
  }

  private loadHotjar(hotjarId: string): void {
    try {
      const script = document.createElement('script');
      
      script.onerror = (error) => {
        console.warn('❌ Hotjar script loading failed:', error);
      };

      script.innerHTML = `
        (function(c,s,q,u,a,r,e){
          c.hj=c.hj||function(){(c.hj.q=c.hj.q||[]).push(arguments)};
          c._hjSettings={hjid:${hotjarId}};
          r=s.getElementsByTagName('head')[0];
          e=s.createElement('script');
          e.async=true;
          e.src=q+c._hjSettings.hjid+u;
          r.appendChild(e);
        })(window,document,'https://static.hj.contentsquare.net/c/csq-','.js');
      `;
      
      document.head.appendChild(script);
      this.scriptsLoaded.hotjar = true;
      console.log('✅ Hotjar initialized with ID:', hotjarId);
    } catch (error) {
      console.warn('❌ Hotjar initialization failed:', error);
    }
  }

  // Методы для отправки событий с проверкой доступности
  trackEvent(eventName: string, eventParams?: any): void {
    if (!this.isBrowser || !this.analyticsEnabled) return;

    try {
      // Google Analytics
      if (typeof window.gtag === 'function' && this.scriptsLoaded.googleAnalytics) {
        window.gtag('event', eventName, eventParams);
      }

      // Yandex Metrika (пробуем отправить, даже если скрипт мог быть заблокирован)
      if (typeof window.ym === 'function' && this.scriptsLoaded.yandexMetrika) {
        const config = this.configService.getConfig();
        try {
          window.ym(config.analytics.yandexMetrikaId, 'reachGoal', eventName, eventParams);
        } catch (e) {
          console.warn('Yandex Metrika event failed (likely blocked):', e);
        }
      }

      console.log(`📊 Analytics event: ${eventName}`, eventParams);
    } catch (error) {
      console.warn('Analytics event sending failed:', error);
    }
  }

  trackPageView(pageTitle: string, pagePath: string): void {
    if (!this.isBrowser || !this.analyticsEnabled) return;

    try {
      const config = this.configService.getConfig();

      // Google Analytics
      if (typeof window.gtag === 'function' && this.scriptsLoaded.googleAnalytics && config.analytics.googleAnalyticsId) {
        window.gtag('config', config.analytics.googleAnalyticsId, {
          page_title: pageTitle,
          page_location: pagePath
        });
      }

      this.trackEvent('page_view', {
        page_title: pageTitle,
        page_location: pagePath
      });
    } catch (error) {
      console.warn('Page view tracking failed:', error);
    }
  }

  // Метод для проверки статуса аналитики
  getAnalyticsStatus(): any {
    return {
      enabled: this.analyticsEnabled,
      scriptsLoaded: this.scriptsLoaded,
      config: this.configService.getConfig().analytics
    };
  }

  // Остальные методы без изменений...
  trackEcommerceEvent(action: string, params: any): void {
    if (!this.isBrowser || !this.analyticsEnabled) return;

    try {
      // Яндекс.Метрика e-commerce
      if (typeof window.ym === 'function' && this.scriptsLoaded.yandexMetrika) {
        const config = this.configService.getConfig();
        try {
          window.ym(config.analytics.yandexMetrikaId, 'ecommerce', action, params);
        } catch (e) {
          console.warn('Yandex Metrika ecommerce event failed:', e);
        }
      }

      // Google Analytics e-commerce
      if (typeof window.gtag === 'function' && this.scriptsLoaded.googleAnalytics) {
        window.gtag('event', action, params);
      }
    } catch (error) {
      console.warn('Ecommerce event tracking failed:', error);
    }
  }

  disableAnalytics(): void {
    this.analyticsEnabled = false;
    this.clearAnalyticsCookies();
    console.log('Analytics disabled');
  }

  private clearAnalyticsCookies(): void {
    const domains = [
      window.location.hostname,
      '.google.com',
      '.yandex.ru', 
      '.hotjar.com',
      '.clarity.ms'
    ];

    domains.forEach(domain => {
      this.clearCookiesForDomain(domain);
    });
  }

  private clearCookiesForDomain(domain: string): void {
    const cookies = document.cookie.split(';');
    
    cookies.forEach(cookie => {
      const eqPos = cookie.indexOf('=');
      const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
      
      if (name.includes('_ga') || name.includes('_ym') || name.includes('_hj') || name.includes('_cl')) {
        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;domain=${domain};path=/`;
      }
    });
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\consent.service.ts ---

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ConsentService {
  private personalDataConsent = new BehaviorSubject<boolean>(this.hasPersonalDataConsent());
  private cookiesConsent = new BehaviorSubject<any>(this.getCookiesSettings());

  personalDataConsent$ = this.personalDataConsent.asObservable();
  cookiesConsent$ = this.cookiesConsent.asObservable();

  setPersonalDataConsent(consent: boolean) {
    localStorage.setItem('personal_data_consent', consent.toString());
    localStorage.setItem('personal_data_consent_date', new Date().toISOString());
    this.personalDataConsent.next(consent);
  }

  setCookiesConsent(settings: any) {
    localStorage.setItem('cookies_consent', 'true');
    localStorage.setItem('cookies_settings', JSON.stringify(settings));
    localStorage.setItem('cookies_consent_date', new Date().toISOString());
    this.cookiesConsent.next(settings);
  }

  private hasPersonalDataConsent(): boolean {
    return localStorage.getItem('personal_data_consent') === 'true';
  }

  private getCookiesSettings(): any {
    const settings = localStorage.getItem('cookies_settings');
    return settings ? JSON.parse(settings) : {
      necessary: true,
      analytics: false,
      functional: false
    };
  }

  hasGivenAllConsents(): boolean {
    return this.hasPersonalDataConsent() && localStorage.getItem('cookies_consent') === 'true';
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\error-handler.service.ts ---

import { Injectable } from '@angular/core';
import { ErrorToastComponent } from '../components/Helpers/error-toast/error-toast.component';

@Injectable({
  providedIn: 'root'
})
export class ErrorHandlerService {
  private errorToastComponent?: ErrorToastComponent;

  constructor() {}

  handleAIConnectionError(error: any, context: string = 'AI Service') {
    if (error.status === 0 || error.message?.includes('CORS')) {
      this.showAIError('CORS ошибка: невозможно подключиться к AI API. Проверьте настройки провайдера.', context);
    } else if (error.status === 401) {
      this.showAIError('Неверный API ключ AI провайдера', context);
    } else if (error.status === 403) {
      this.showAIError('Доступ к AI сервису запрещен', context);
    } else if (error.status === 429) {
      this.showAIError('Превышен лимит запросов к AI сервису', context);
    } else {
      this.showAIError(`Ошибка AI сервиса: ${error.message}`, context);
    }
  }

  registerErrorToast(component: ErrorToastComponent) {
    this.errorToastComponent = component;
    console.log('ErrorToastComponent registered successfully');
  }

  showError(message: string, source?: string) {
    console.log('Showing error:', message, source);
    if (this.errorToastComponent) {
      this.errorToastComponent.showError(message, source);
    } else {
      console.warn('ErrorToastComponent not registered. Message:', message);
      // Fallback: показать alert или console.error
      console.error(`[${source}] ${message}`);
    }
  }

  showAIError(message: string, source?: string) {
    console.log('Showing AI error:', message, source);
    if (this.errorToastComponent) {
      this.errorToastComponent.showAIError(message, source);
    } else {
      console.warn('ErrorToastComponent not registered. AI Message:', message);
      console.error(`[AI-${source}] ${message}`);
    }
  }

  showWarning(message: string, source?: string) {
    this.errorToastComponent?.showWarning(message, source);
  }

  handleApiError(error: any, context: string = 'API') {
    if (error.status === 429) {
      this.showAIError('Слишком много запросов', context);
    } else if (error.status === 400) {
      this.showAIError('Неверный запрос', context);
    } else if (error.status >= 500) {
      this.showError('Ошибка сервера', context);
    } else {
      const message = error.message || 'Произошла ошибка';
      this.showError(message, context);
    }
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\file-upload.service.ts ---

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

export interface FileUploadState {
  fieldName: string;
  file: File | null;
  progress: number;
  status: 'idle' | 'uploading' | 'success' | 'error';
}

@Injectable({ providedIn: 'root' })
export class FileUploadService {
  private uploadStates = new BehaviorSubject<Map<string, FileUploadState>>(new Map());
  
  getUploadState(fieldName: string): FileUploadState | undefined {
    return this.uploadStates.value.get(fieldName);
  }

  setUploadState(fieldName: string, state: Partial<FileUploadState>): void {
    const currentStates = new Map(this.uploadStates.value);
    const existingState = currentStates.get(fieldName) || {
      fieldName,
      file: null,
      progress: 0,
      status: 'idle'
    };
    
    currentStates.set(fieldName, { ...existingState, ...state });
    this.uploadStates.next(currentStates);
    
    console.log(`File upload state updated for ${fieldName}:`, state);
  }

  clearUploadState(fieldName: string): void {
    const currentStates = new Map(this.uploadStates.value);
    currentStates.delete(fieldName);
    this.uploadStates.next(currentStates);
    
    console.log(`File upload state cleared for ${fieldName}`);
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\ai\ai-guard.service.ts ---

// src/app/shared/ai/ai-guard.service.ts
import { Injectable } from '@angular/core';
import { AIService } from './ai.service';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class AIGuardService {
  private currentProviderSubject = new BehaviorSubject<string>('Не настроен');
  
  constructor(private aiService: AIService) {
    // Подписываемся на изменения текущего провайдера
    this.aiService.getCurrentProviderObservable().subscribe(provider => {
      this.currentProviderSubject.next(provider?.name || 'Не настроен');
    });
  }

  checkAIConfigured(): boolean {
    return this.aiService.isAnyProviderConfigured();
  }

  getCurrentProviderName(): string {
    return this.currentProviderSubject.value;
  }

  getCurrentProviderNameObservable(): Observable<string> {
    return this.currentProviderSubject.asObservable();
  }

  ensureAIConfigured(): { configured: boolean; message?: string } {
    if (this.checkAIConfigured()) {
      return { configured: true };
    }
    
    return { 
      configured: false, 
      message: 'Для использования этой функции необходимо настроить AI провайдера' 
    };
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\ai\ai.service.ts ---

// src/app/shared/ai/ai.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, catchError, map, retry, throwError, of, BehaviorSubject } from 'rxjs';
import { ConfigService } from '../config/config.service';
import { ErrorHandlerService } from '../error-handler.service';

export interface AIRequest {
  model: string;
  prompt: string;
  max_tokens: number;
  temperature: number;
  top_p: number;
  top_k?: number;
  repetition_penalty?: number;
  stop?: string[];
  stream?: boolean;
}

export interface AIProvider {
  id: string;
  name: string;
  baseUrl: string;
  apiKey: string;
  isConfigured: boolean;
  models: string[];
  isDefault?: boolean;
}

@Injectable({ providedIn: 'root' })
export class AIService {
  private currentProvider: AIProvider | null = null;
  private providers: AIProvider[] = [];
  private providersSubject = new BehaviorSubject<AIProvider[]>([]);
  private currentProviderSubject = new BehaviorSubject<AIProvider | null>(null);

  constructor(
    private http: HttpClient,
    private configService: ConfigService,
    private errorHandler: ErrorHandlerService
  ) {
    this.initializeProviders();
  }

  private async initializeProviders(): Promise<void> {
    try {
      // Сначала загружаем конфиг
      const config = await this.configService.loadConfig();
      
      // Инициализируем провайдеров
      this.providers = [
        {
          id: 'together',
          name: 'Together AI',
          baseUrl: 'https://api.together.xyz/v1',
          apiKey: config.togetherApiKey || '',
          isConfigured: !!config.togetherApiKey,
          models: ['meta-llama/Llama-3.3-70B-Instruct-Turbo-Free', 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free'],
          isDefault: true
        },
        {
          id: 'deepseek',
          name: 'DeepSeek',
          baseUrl: 'https://api.deepseek.com/v1',
          apiKey: '',
          isConfigured: false,
          models: ['deepseek-chat', 'deepseek-coder']
        },
        {
          id: 'openai',
          name: 'OpenAI',
          baseUrl: 'https://api.openai.com/v1',
          apiKey: '',
          isConfigured: false,
          models: ['gpt-4', 'gpt-3.5-turbo']
        },
        {
          id: 'huggingface',
          name: 'Hugging Face',
          baseUrl: 'https://api-inference.huggingface.co/v1',
          apiKey: '',
          isConfigured: false,
          models: ['mistralai/Mistral-7B-Instruct-v0.2', 'google/flan-t5-xxl']
        }
      ];

      // Пытаемся загрузить сохраненную конфигурацию
      const savedConfig = localStorage.getItem('ai_providers_config');
      if (savedConfig) {
        try {
          const parsedConfig = JSON.parse(savedConfig);
          if (parsedConfig.providers) {
            // Обновляем провайдеров из сохраненной конфигурации
            this.providers.forEach(provider => {
              const savedProvider = parsedConfig.providers.find((p: any) => p.id === provider.id);
              if (savedProvider) {
                provider.apiKey = savedProvider.apiKey;
                provider.isConfigured = savedProvider.isConfigured;
                if (savedProvider.baseUrl) provider.baseUrl = savedProvider.baseUrl;
              }
            });
          }
          
          if (parsedConfig.currentProviderId) {
            const savedCurrentProvider = this.providers.find(p => p.id === parsedConfig.currentProviderId && p.isConfigured);
            if (savedCurrentProvider) {
              this.currentProvider = savedCurrentProvider;
            }
          }
        } catch (e) {
          console.error('Error parsing saved AI config:', e);
        }
      }

      // Если нет сохраненного текущего провайдера, но Together AI настроен - используем его
      if (!this.currentProvider) {
        const togetherProvider = this.providers.find(p => p.id === 'together');
        if (togetherProvider?.isConfigured) {
          this.currentProvider = togetherProvider;
        }
      }

      this.providersSubject.next([...this.providers]);
      this.currentProviderSubject.next(this.currentProvider);
      
    } catch (error) {
      console.error('Failed to initialize AI providers:', error);
      this.errorHandler.showError('Ошибка инициализации AI провайдеров', 'AIService');
    }
  }

  getProviders(): AIProvider[] {
    return this.providers;
  }

  getProvidersObservable(): Observable<AIProvider[]> {
    return this.providersSubject.asObservable();
  }

  getCurrentProvider(): AIProvider | null {
    return this.currentProvider;
  }

  getCurrentProviderObservable(): Observable<AIProvider | null> {
    return this.currentProviderSubject.asObservable();
  }

  setCurrentProvider(providerId: string): void {
    const provider = this.providers.find(p => p.id === providerId);
    if (provider && provider.isConfigured) {
      this.currentProvider = provider;
      this.saveProvidersConfig();
      this.currentProviderSubject.next(this.currentProvider);
      this.providersSubject.next([...this.providers]);
    } else {
      this.errorHandler.showError(`Провайдер ${providerId} не настроен или не найден`, 'AIService');
    }
  }

  configureProvider(providerId: string, apiKey: string, baseUrl?: string): boolean {
    const provider = this.providers.find(p => p.id === providerId);
    if (provider) {
      provider.apiKey = apiKey;
      if (baseUrl) provider.baseUrl = baseUrl;
      provider.isConfigured = !!apiKey;
      
      this.saveProvidersConfig();
      this.providersSubject.next([...this.providers]);
      return true;
    }
    return false;
  }

  async configureTogetherFromConfig(): Promise<boolean> {
    try {
      const config = await this.configService.loadConfig();
      const togetherProvider = this.providers.find(p => p.id === 'together');
      
      if (togetherProvider && config.togetherApiKey) {
        togetherProvider.apiKey = config.togetherApiKey;
        togetherProvider.isConfigured = true;
        
        // Автоматически устанавливаем как активного провайдера
        this.currentProvider = togetherProvider;
        
        this.saveProvidersConfig();
        this.providersSubject.next([...this.providers]);
        this.currentProviderSubject.next(this.currentProvider);
        
        return true;
      } else {
        this.errorHandler.showError('Together API ключ не найден в конфигурации', 'AIService');
        return false;
      }
    } catch (error) {
      console.error('Failed to configure Together AI from config:', error);
      this.errorHandler.showError('Ошибка настройки Together AI', 'AIService');
      return false;
    }
  }

  isAnyProviderConfigured(): boolean {
    return this.providers.some(provider => provider.isConfigured);
  }


  generateText(request: AIRequest): Observable<string> {
    if (!this.currentProvider || !this.currentProvider.isConfigured) {
      const error = new Error('AI provider not configured');
      this.errorHandler.showAIError('AI провайдер не настроен. Нажмите на кнопку AI в верхнем меню для настройки.', 'AIService');
      return throwError(() => error);
    }
  
    const url = `${this.currentProvider.baseUrl}/completions`;
  
    return this.http.post<any>(url, request, {
      headers: {
        'Authorization': `Bearer ${this.currentProvider.apiKey}`,
        'Content-Type': 'application/json'
      }
    }).pipe(
      map(response => {
        if (!response.choices?.[0]?.text) {
          throw new Error('Invalid response from AI API');
        }
        return this.cleanGeneratedText(response.choices[0].text);
      }),
      catchError(error => {
        console.error('AI API error:', error);
        
        let errorMessage = 'Ошибка подключения к AI сервису';
        
        if (error.status === 0) {
          // CORS ошибка
          errorMessage = 'CORS ошибка: невозможно подключиться к AI API из браузера. Используйте Together AI или настройте прокси';
        } else if (error.status === 401) {
          errorMessage = 'Неверный API ключ AI провайдера';
        } else if (error.status === 403) {
          errorMessage = 'Доступ к AI сервису запрещен. Проверьте настройки API ключа';
        } else if (error.status === 429) {
          errorMessage = 'Превышен лимит запросов к AI сервису. Попробуйте позже';
        } else if (error.status >= 500) {
          errorMessage = 'Временные проблемы с AI сервисом. Попробуйте позже';
        } else {
          errorMessage = `Ошибка AI сервиса: ${error.status} ${error.statusText || error.message}`;
        }
        
        this.errorHandler.showAIError(errorMessage, 'AIService');
        return throwError(() => new Error(errorMessage));
      }),
      retry(2)
    );
  }

  testProviderConnection(providerId: string): Observable<boolean> {
    const provider = this.providers.find(p => p.id === providerId);
    if (!provider || !provider.isConfigured) {
      this.errorHandler.showAIError(`Провайдер ${providerId} не настроен`, 'AIService');
      return of(false);
    }
  
    const testRequest = {
      model: provider.models[0],
      prompt: 'Test connection - ignore this message',
      max_tokens: 5,
      temperature: 0.1
    };
  
    return this.http.post<any>(`${provider.baseUrl}/completions`, testRequest, {
      headers: {
        'Authorization': `Bearer ${provider.apiKey}`,
        'Content-Type': 'application/json'
      }
    }).pipe(
      map(response => {
        // Успешное подключение
        return true;
      }),
      catchError(error => {
        console.error('AI connection test error:', error);
        
        let errorMessage = 'Ошибка подключения к AI провайдеру';
        
        if (error.status === 0) {
          // CORS ошибка или нет сети
          if (error.error instanceof ErrorEvent) {
            errorMessage = 'CORS ошибка: невозможно подключиться к AI API из браузера. Необходимо использовать прокси или серверную часть';
          } else {
            errorMessage = 'Нет подключения к интернету или CORS ошибка';
          }
        } else if (error.status === 401) {
          errorMessage = 'Неверный API ключ';
        } else if (error.status === 403) {
          errorMessage = 'Доступ запрещен. Проверьте API ключ и права доступа';
        } else if (error.status === 429) {
          errorMessage = 'Превышен лимит запросов к AI сервису';
        } else {
          errorMessage = `Ошибка подключения: ${error.status} ${error.statusText || error.message}`;
        }
        
        this.errorHandler.showAIError(errorMessage, 'AIService');
        return of(false);
      })
    );
  }

  private cleanGeneratedText(text: string): string {
    if (!text) return '';
    return text.trim();
  }

  private saveProvidersConfig(): void {
    const config = {
      providers: this.providers,
      currentProviderId: this.currentProvider?.id
    };
    localStorage.setItem('ai_providers_config', JSON.stringify(config));
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\billing\billing.models.ts ---

export interface TariffPlan {
    id: string;
    name: string;
    price: number;
    dailyLimits: {
      resumeGenerations: number;
      coverLetters: number;
      interviewPlans: number;
    };
    features: string[];
    description: string;
    popular?: boolean;
  }
  
  export interface UserSubscription {
    userId: string;
    planId: string;
    status: 'active' | 'canceled' | 'expired' | 'pending';
    currentPeriodStart: Date;
    currentPeriodEnd: Date;
    usage: {
      resumeGenerations: number;
      coverLetters: number;
      interviewPlans: number;
      lastReset: Date;
    };
    paymentId?: string;
    createdAt: Date;
    updatedAt: Date;
  }
  
  export interface PaymentResult {
    success: boolean;
    paymentUrl?: string;
    paymentId?: string;
    error?: string;
  }
  
  export interface UsageLimit {
    allowed: boolean;
    remaining: number;
    limit: number;
    feature: string;
  }

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\billing\billing.service.ts ---

import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { TariffPlan, UserSubscription } from './billing.models';
import { ConfigService } from '../config/config.service';
import { SupabaseService } from '../db/supabase.service';
import { TranslateService } from '@ngx-translate/core';

@Injectable({ providedIn: 'root' })
export class BillingService {
  private readonly PLANS: TariffPlan[] = [
    {
      id: 'free',
      name: 'Бесплатный',
      price: 0,
      dailyLimits: { 
        resumeGenerations: 1, 
        coverLetters: 1, 
        interviewPlans: 1 
      },
      features: [
        'Базовые функции генерации',
        '1 резюме в день',
        '1 сопроводительное письмо в день', 
        '1 план собеседования в день',
        'Поддержка по email'
      ],
      description: 'Для начала карьерного пути'
    },
    {
      id: 'basic',
      name: 'Базовый',
      price: 290,
      dailyLimits: { 
        resumeGenerations: 5, 
        coverLetters: 5, 
        interviewPlans: 5 
      },
      features: [
        'Все функции генерации',
        '5 резюме в день',
        '5 сопроводительных писем в день',
        '5 планов собеседования в день', 
        'Приоритетная поддержка',
        'Расширенные шаблоны'
      ],
      description: 'Для активного поиска работы',
      popular: true
    },
    {
      id: 'pro',
      name: 'PRO',
      price: 790,
      dailyLimits: { 
        resumeGenerations: -1, 
        coverLetters: -1, 
        interviewPlans: -1 
      },
      features: [
        'Безлимитная генерация',
        'Все функции платформы',
        'Премиум шаблоны',
        'Персональная поддержка',
        'Ранний доступ к новым функциям',
        'Аналитика эффективности'
      ],
      description: 'Для профессионалов и рекрутеров'
    }
  ];

  private currentSubscription = new BehaviorSubject<UserSubscription | null>(null);
  private plans: TariffPlan[] = [];

  constructor(
    private supabase: SupabaseService,
    private configService: ConfigService,
    private translate: TranslateService
  ) {
    console.log('BillingService initialized with:', {
      supabase: !!supabase,
      configService: !!configService,
      translate: !!translate
    });
  }
  
  async getUserSubscription(): Promise<UserSubscription> {
    const userId = this.supabase.currentUser?.id;
    if (!userId) {
      throw new Error('User not authenticated');
    }

    try {
      console.log('Loading subscription from Supabase for user:', userId);
      
      const { data, error } = await this.supabase.client
        .from('user_subscriptions')
        .select('*')
        .eq('user_id', userId)
        .single();

      if (error) {
        console.error('Supabase error:', error);
        
        if (error.code === 'PGRST116') {
          // Подписка не найдена - создаем новую
          console.log('Subscription not found, creating free subscription');
          return await this.createFreeSubscription(userId);
        }
        
        // Для других ошибок пробуем создать подписку
        console.warn('Error loading subscription, creating new one:', error.message);
        return await this.createFreeSubscription(userId);
      }

      console.log('Subscription loaded from DB:', data);
      
      const subscription = this.mapDbSubscriptionToModel(data);
      this.currentSubscription.next(subscription);
      return subscription;

    } catch (error) {
      console.error('Unexpected error loading subscription:', error);
      // Создаем бесплатную подписку как fallback
      return await this.createFreeSubscription(userId!);
    }
  }

  async saveSubscription(subscription: UserSubscription): Promise<void> {
    const userId = this.supabase.currentUser?.id;
    if (!userId) {
      throw new Error('User not authenticated');
    }

    subscription.updatedAt = new Date();
    
    try {
      console.log('Saving subscription to Supabase:', subscription);

      const { error } = await this.supabase.client
        .from('user_subscriptions')
        .upsert({
          user_id: subscription.userId,
          plan_id: subscription.planId,
          status: subscription.status,
          current_period_start: subscription.currentPeriodStart.toISOString(),
          current_period_end: subscription.currentPeriodEnd.toISOString(),
          usage: subscription.usage,
          payment_id: subscription.paymentId,
          updated_at: subscription.updatedAt.toISOString()
        }, { 
          onConflict: 'user_id'
        });

      if (error) {
        console.error('Error saving subscription to Supabase:', error);
        throw new Error(`Failed to save subscription: ${error.message}`);
      }

      console.log('Subscription saved successfully');
      this.currentSubscription.next(subscription);
      
    } catch (error) {
      console.error('Failed to save subscription:', error);
      throw error; // Пробрасываем ошибку дальше
    }
  }

  private mapDbSubscriptionToModel(dbData: any): UserSubscription {
    return {
      userId: dbData.user_id,
      planId: dbData.plan_id || 'free',
      status: dbData.status || 'active',
      currentPeriodStart: new Date(dbData.current_period_start),
      currentPeriodEnd: new Date(dbData.current_period_end),
      usage: dbData.usage || {
        resumeGenerations: 0,
        coverLetters: 0,
        interviewPlans: 0,
        lastReset: new Date()
      },
      paymentId: dbData.payment_id,
      createdAt: new Date(dbData.created_at),
      updatedAt: new Date(dbData.updated_at)
    };
  }

  private async createFreeSubscription(userId: string): Promise<UserSubscription> {
    const freeSubscription: UserSubscription = {
      userId,
      planId: 'free',
      status: 'active',
      currentPeriodStart: new Date(),
      currentPeriodEnd: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 год
      usage: {
        resumeGenerations: 0,
        coverLetters: 0,
        interviewPlans: 0,
        lastReset: new Date()
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    await this.saveSubscription(freeSubscription);
    
    return freeSubscription;
  }


  private initializePlans(): void {
    this.plans = [
      {
        id: 'free',
        name: this.translate.instant('BILLING.PLANS.FREE.NAME'),
        price: 0,
        dailyLimits: { 
          resumeGenerations: 1, 
          coverLetters: 1, 
          interviewPlans: 1 
        },
        features: [
          this.translate.instant('BILLING.PLANS.FREE.FEATURES.BASIC_GENERATION'),
          this.translate.instant('BILLING.PLANS.FREE.FEATURES.RESUME_LIMIT'),
          this.translate.instant('BILLING.PLANS.FREE.FEATURES.COVER_LETTER_LIMIT'),
          this.translate.instant('BILLING.PLANS.FREE.FEATURES.INTERVIEW_PLAN_LIMIT'),
          this.translate.instant('BILLING.PLANS.FREE.FEATURES.EMAIL_SUPPORT')
        ],
        description: this.translate.instant('BILLING.PLANS.FREE.DESCRIPTION')
      },
      {
        id: 'basic',
        name: this.translate.instant('BILLING.PLANS.BASIC.NAME'),
        price: 290,
        dailyLimits: { 
          resumeGenerations: 5, 
          coverLetters: 5, 
          interviewPlans: 5 
        },
        features: [
          this.translate.instant('BILLING.PLANS.BASIC.FEATURES.ALL_GENERATION'),
          this.translate.instant('BILLING.PLANS.BASIC.FEATURES.RESUME_LIMIT'),
          this.translate.instant('BILLING.PLANS.BASIC.FEATURES.COVER_LETTER_LIMIT'),
          this.translate.instant('BILLING.PLANS.BASIC.FEATURES.INTERVIEW_PLAN_LIMIT'),
          this.translate.instant('BILLING.PLANS.BASIC.FEATURES.PRIORITY_SUPPORT'),
          this.translate.instant('BILLING.PLANS.BASIC.FEATURES.EXTENDED_TEMPLATES')
        ],
        description: this.translate.instant('BILLING.PLANS.BASIC.DESCRIPTION'),
        popular: true
      },
      {
        id: 'pro',
        name: this.translate.instant('BILLING.PLANS.PRO.NAME'),
        price: 790,
        dailyLimits: { 
          resumeGenerations: -1, 
          coverLetters: -1, 
          interviewPlans: -1 
        },
        features: [
          this.translate.instant('BILLING.PLANS.PRO.FEATURES.UNLIMITED_GENERATION'),
          this.translate.instant('BILLING.PLANS.PRO.FEATURES.ALL_FEATURES'),
          this.translate.instant('BILLING.PLANS.PRO.FEATURES.PREMIUM_TEMPLATES'),
          this.translate.instant('BILLING.PLANS.PRO.FEATURES.PERSONAL_SUPPORT'),
          this.translate.instant('BILLING.PLANS.PRO.FEATURES.EARLY_ACCESS'),
          this.translate.instant('BILLING.PLANS.PRO.FEATURES.ANALYTICS')
        ],
        description: this.translate.instant('BILLING.PLANS.PRO.DESCRIPTION')
      }
    ];
  }

  getPlans(): TariffPlan[] {
    return this.plans;
  }

  getPlan(planId: string): TariffPlan {
    const plan = this.plans.find(p => p.id === planId);
    if (!plan) {
      throw new Error(this.translate.instant('BILLING.ERRORS.PLAN_NOT_FOUND', { planId }));
    }
    return plan;
  }

  getCurrentPlan(): TariffPlan {
    const subscription = this.currentSubscription.value;
    return this.getPlan(subscription?.planId || 'free');
  }

  async activateFreePlan(): Promise<void> {
    const userId = this.supabase.currentUser?.id;
    if (!userId) return;

    const subscription: UserSubscription = {
      userId,
      planId: 'free',
      status: 'active',
      currentPeriodStart: new Date(),
      currentPeriodEnd: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
      usage: {
        resumeGenerations: 0,
        coverLetters: 0,
        interviewPlans: 0,
        lastReset: new Date()
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    await this.saveSubscription(subscription);
  }

  async resetDailyUsageIfNeeded(subscription: UserSubscription): Promise<void> {
    const now = new Date();
    const lastReset = new Date(subscription.usage.lastReset);
    
    if (now.getDate() !== lastReset.getDate() || 
        now.getMonth() !== lastReset.getMonth() || 
        now.getFullYear() !== lastReset.getFullYear()) {
      
      subscription.usage = {
        resumeGenerations: 0,
        coverLetters: 0,
        interviewPlans: 0,
        lastReset: now
      };
      
      await this.saveSubscription(subscription);
    }
  }

  getCurrentSubscriptionObservable(): Observable<UserSubscription | null> {
    return this.currentSubscription.asObservable();
  }

  getPaymentMethod(): string {
    return 'yookassa';
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\billing\payment.service.ts ---

import { Injectable, Injector } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { PaymentResult } from './billing.models';
import { ConfigService } from '../config/config.service';
import { SupabaseService } from '../db/supabase.service';
import { TranslateService } from '@ngx-translate/core';
import { BillingService } from './billing.service'; // Добавить импорт

@Injectable({ providedIn: 'root' })
export class PaymentService {
  private readonly API_BASE = '/api/payments';

  constructor(
    private http: HttpClient,
    private configService: ConfigService,
    private supabase: SupabaseService,
    private translate: TranslateService,
    private injector: Injector
  ) {}

  async createPayment(planId: string): Promise<PaymentResult> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) {
        throw new Error('User not authenticated');
      }

      // Для бесплатного тарифа сразу активируем
      if (planId === 'free') {
        await this.activateFreePlan(userId);
        return {
          success: true,
          paymentUrl: undefined,
          paymentId: `free_activation_${Date.now()}`
        };
      }

      const response = await this.http.post<{paymentUrl: string; paymentId: string}>(
        `${this.API_BASE}/create`,
        { planId, userId }
      ).toPromise();

      if (!response) {
        throw new Error('No response from payment API');
      }

      return {
        success: true,
        paymentUrl: response.paymentUrl,
        paymentId: response.paymentId
      };
    } catch (error: any) {
      console.error('Payment creation error:', error);
      return {
        success: false,
        error: error.message || 'Ошибка создания платежа'
      };
    }
  }

  private async activateFreePlan(userId: string): Promise<void> {
    // Ленивая загрузка BillingService чтобы избежать циклической зависимости
    const billingService = this.injector.get(BillingService);
    await billingService.activateFreePlan();
  }

  async handlePaymentSuccess(paymentId: string, planId: string): Promise<void> {
    const userId = this.supabase.currentUser?.id;
    if (!userId) return;

    // Ленивая загрузка BillingService
    const billingService = this.injector.get(BillingService);
    const subscription = await billingService.getUserSubscription();
    
    subscription.planId = planId;
    subscription.status = 'active';
    subscription.paymentId = paymentId;
    subscription.currentPeriodStart = new Date();
    subscription.currentPeriodEnd = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
    subscription.usage = {
      resumeGenerations: 0,
      coverLetters: 0,
      interviewPlans: 0,
      lastReset: new Date()
    };

    await billingService.saveSubscription(subscription);
  }

  async checkPaymentStatus(paymentId: string): Promise<{status: string; planId?: string}> {
    try {
      const response = await this.http.get<{status: string; planId?: string}>(
        `${this.API_BASE}/status/${paymentId}`
      ).toPromise();

      if (!response) {
        return { status: 'unknown' };
      }

      return response;
    } catch (error) {
      console.error('Payment status check error:', error);
      return { status: 'unknown' };
    }
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\billing\usage.service.ts ---

import { Injectable } from '@angular/core';
import { UsageLimit } from './billing.models';
import { BillingService } from './billing.service';
import { SupabaseService } from '../db/supabase.service';

@Injectable({ providedIn: 'root' })
export class UsageService {
  
  constructor(
    private billingService: BillingService,
    private supabase: SupabaseService
  ) {
    console.log('UsageService initialized');
  }

  async getUsageStats(): Promise<{feature: string, used: number, limit: number, remaining: number}[]> {
    const subscription = await this.billingService.getUserSubscription();
    const plan = this.billingService.getPlan(subscription.planId);

    return [
      {
        feature: 'Резюме',
        used: subscription.usage.resumeGenerations,
        limit: plan.dailyLimits.resumeGenerations,
        remaining: plan.dailyLimits.resumeGenerations === -1 ? -1 : plan.dailyLimits.resumeGenerations - subscription.usage.resumeGenerations
      },
      {
        feature: 'Сопроводительные письма',
        used: subscription.usage.coverLetters,
        limit: plan.dailyLimits.coverLetters,
        remaining: plan.dailyLimits.coverLetters === -1 ? -1 : plan.dailyLimits.coverLetters - subscription.usage.coverLetters
      },
      {
        feature: 'Планы собеседований',
        used: subscription.usage.interviewPlans,
        limit: plan.dailyLimits.interviewPlans,
        remaining: plan.dailyLimits.interviewPlans === -1 ? -1 : plan.dailyLimits.interviewPlans - subscription.usage.interviewPlans
      }
    ];
  }

  private async resetDailyUsageIfNeeded(subscription: any): Promise<void> {
    const now = new Date();
    const lastReset = new Date(subscription.usage.lastReset);
    
    // Сбрасываем счетчики если прошло больше 24 часов
    if (now.getDate() !== lastReset.getDate() || now.getMonth() !== lastReset.getMonth() || now.getFullYear() !== lastReset.getFullYear()) {
      subscription.usage = {
        resumeGenerations: 0,
        coverLetters: 0,
        interviewPlans: 0,
        lastReset: now
      };
      await this.billingService.saveSubscription(subscription);
    }
  }

  private getFeatureName(feature: string): string {
    const names: {[key: string]: string} = {
      'resumeGenerations': 'Генерация резюме',
      'coverLetters': 'Генерация сопроводительных писем',
      'interviewPlans': 'Генерация планов собеседований'
    };
    return names[feature] || feature;
  }

  async checkLimit(feature: 'resumeGenerations' | 'coverLetters' | 'interviewPlans'): Promise<UsageLimit> {
    try {
      const subscription = await this.billingService.getUserSubscription();
      
      // Сбрасываем дневное использование если нужно
      await this.billingService.resetDailyUsageIfNeeded(subscription);
      
      const plan = this.billingService.getPlan(subscription.planId);
      const limit = plan.dailyLimits[feature];
      const used = subscription.usage[feature];

      // Безлимитный тариф
      if (limit === -1) {
        return {
          allowed: true,
          remaining: -1,
          limit: -1,
          feature: this.getFeatureName(feature)
        };
      }

      const remaining = limit - used;
      const allowed = remaining > 0;

      return {
        allowed,
        remaining: Math.max(0, remaining),
        limit,
        feature: this.getFeatureName(feature)
      };
    } catch (error) {
      console.error('Error checking limit:', error);
      // В случае ошибки разрешаем использование
      return {
        allowed: true,
        remaining: -1,
        limit: -1,
        feature: this.getFeatureName(feature)
      };
    }
  }

  async incrementUsage(feature: 'resumeGenerations' | 'coverLetters' | 'interviewPlans'): Promise<void> {
    try {
      const subscription = await this.billingService.getUserSubscription();
      const plan = this.billingService.getPlan(subscription.planId);
      
      // Не увеличиваем счетчик для безлимитного тарифа
      if (plan.dailyLimits[feature] === -1) {
        return;
      }

      subscription.usage[feature]++;
      await this.billingService.saveSubscription(subscription);
    } catch (error) {
      console.error('Error incrementing usage:', error);
    }
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\config\config.service.ts ---

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { BehaviorSubject } from 'rxjs';
import { environment } from '../../../environments/environment';
import { ErrorHandlerService } from '../error-handler.service';

export interface AnalyticsConfig {
  googleAnalyticsId: string;
  yandexMetrikaId: string;
  microsoftClarityId: string;
  hotjarId: string;
}

export interface AppConfig {
  supabaseUrl: string;
  supabaseKey: string;
  togetherApiKey: string;
  hhClientId: string;
  hhClientSecret: string;
  superJobClientId: string;
  superJobClientSecret: string;
  habrClientId: string;
  habrClientSecret: string;
  yookassaShopId: string;
  yookassaSecretKey: string;
  demoMode: boolean;
  analytics: AnalyticsConfig;
}

export interface EnvironmentConfig {
  production: boolean;
  supabaseUrl: string;
  supabaseKey: string;
  togetherApiKey: string;
  hh?: {
    hhClientId: string;
    hhClientSecret: string;
  };
  superJob?: {
    superJobClientId: string;
    superJobClientSecret: string;
  };
  habr?: {
    habrClientId: string;
    habrClientSecret: string;
  };
  yookassaShopId?: string;
  yookassaSecretKey?: string;
  demoMode?: boolean;
  analytics?: AnalyticsConfig;
}

@Injectable({ providedIn: 'root' })
export class ConfigService {
  private configLoaded = new BehaviorSubject<boolean>(false);
  private config!: AppConfig;
  private configCache: AppConfig | null = null;

  constructor(
    private http: HttpClient,
    private errorHandler: ErrorHandlerService
  ) {}

  async loadConfig(): Promise<AppConfig> {
    if (this.configCache) {
      return this.configCache;
    }
    if (!environment.production) {
      console.log('Using development config from environment.ts');
      const devConfig: AppConfig = {
        supabaseUrl: environment.supabaseUrl,
        supabaseKey: environment.supabaseKey,
        togetherApiKey: environment.togetherApiKey,
        hhClientId: environment.hh?.hhClientId || '',
        hhClientSecret: environment.hh?.hhClientSecret || '',
        superJobClientId: environment.superJob?.superJobClientId || '',
        superJobClientSecret: environment.superJob?.superJobClientSecret || '',
        habrClientId: environment.habr?.habrClientId || '',
        habrClientSecret: environment.habr?.habrClientSecret || '',
        yookassaShopId: environment.yookassaShopId || '',
        yookassaSecretKey: environment.yookassaSecretKey || '',
        demoMode: environment.demoMode || true,
        analytics: {
          googleAnalyticsId: environment.analytics?.googleAnalyticsId || '',
          yandexMetrikaId: environment.analytics?.yandexMetrikaId || '',
          microsoftClarityId: environment.analytics?.microsoftClarityId || '',
          hotjarId: environment.analytics?.hotjarId || '',
        }
      };
      
      this.config = devConfig;
      this.configCache = devConfig;
      this.configLoaded.next(true);
      return devConfig;
    }

    // В production всегда используем API endpoint
    try {
      console.log('Loading config from API endpoint');
      const config = await this.http.get<AppConfig>('/api/config').toPromise();
      
      if (!config) {
        throw new Error('Empty response from config API');
      }

      console.log('Config loaded from API successfully');
      this.config = config;
      this.configCache = config;
      this.configLoaded.next(true);
      return config;

    } catch (error) {
      this.errorHandler.showError('Ошибка загрузки конфигурации', 'ConfigService');

      const emptyConfig: AppConfig = {
        supabaseUrl: '',
        supabaseKey: '',
        togetherApiKey: '',
        hhClientId: '',
        hhClientSecret: '',
        superJobClientId: '',
        superJobClientSecret: '',
        habrClientId: '',
        habrClientSecret: '',
        yookassaShopId: '',
        yookassaSecretKey: '',
        demoMode: true,
        analytics: {
          googleAnalyticsId: '',
          yandexMetrikaId: '',
          microsoftClarityId: '',
          hotjarId: '',
        }
      };
      
      this.config = emptyConfig;
      this.configCache = emptyConfig;
      this.configLoaded.next(true);
      return emptyConfig;
    }
  }

  getConfig(): AppConfig {
    if (!this.config) {
      throw new Error('Config not loaded yet');
    }
    return this.config;
  }

  isConfigLoaded() {
    return this.configLoaded.asObservable();
  }

  hasAnalytics(): boolean {
    const analytics = this.config?.analytics;
    return !!(analytics?.googleAnalyticsId || analytics?.yandexMetrikaId || 
              analytics?.microsoftClarityId || analytics?.hotjarId);
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\cover-letter\cover-letter.service.ts ---

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of, throwError, from, forkJoin } from 'rxjs';
import { map, catchError, switchMap } from 'rxjs/operators';
import { HHAuthService } from '../job-platforms/hh/hh-auth.service';
import { ProfileService } from '../profile/profile.service';
import { ConfigService } from '../config/config.service';
import { AIService } from '../ai/ai.service';
import { VacancyService } from '../vacancy/vacancy.service';
import { SuperJobAuthService } from '../job-platforms/super-job/superjob-auth.service';
import { ErrorHandlerService } from '../error-handler.service';
import { UsageService } from '../billing/usage.service';
import { MessageService } from 'primeng/api';

export interface CoverLetterRequest {
  resume_id: string;
  vacancy_id: string;
  style?: string;
  tone?: string;
  selected_resume?: any;
  resume_content?: string;
}

export interface CoverLetterResponse {
  id?: string;
  content: string;
  generated_at: string;
  resume_id: string;
  vacancy_id: string;
  style: string;
  tone: string;
}

export interface CoverLetterTemplate {
  id: string;
  name: string;
  content: string;
  is_default: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class CoverLetterService {
  currentVacancy: any = null;

  constructor(
    private hhAuthService: HHAuthService,
    private profileService: ProfileService,
    private aiService: AIService,
    private vacancyService: VacancyService,
    private errorHandler: ErrorHandlerService,
    private usageService: UsageService,
    private messageService: MessageService
  ) {}

  generateCoverLetter(request: any): Observable<any> {
    return from(this.usageService.checkLimit('coverLetters')).pipe(
      switchMap(limitCheck => {
        if (!limitCheck.allowed) {
          const errorMsg = `Достигнут дневной лимит генерации сопроводительных писем. Доступно: ${limitCheck.remaining} из ${limitCheck.limit}. Обновите тариф для увеличения лимитов.`;
          this.messageService.add({
            severity: 'warn',
            summary: 'Лимит исчерпан',
            detail: errorMsg,
            life: 5000
          });
          throw new Error(errorMsg);
        }
  
        return forkJoin({
          vacancy: this.getVacancyDetails(request.vacancy_id).pipe(
            catchError(error => {
              this.errorHandler.showError('Ошибка загрузки вакансии', 'CoverLetterService');
              throw new Error(`Не удалось загрузить вакансию: ${error.message}`);
            })
          ),
          profile: this.profileService.loadProfile().pipe(
            catchError(error => {
              this.errorHandler.showError('Ошибка загрузки профиля', 'CoverLetterService');
              throw new Error(`Не удалось загрузить профиля: ${error.message}`);
            })
          )
        }).pipe(
          switchMap(({ vacancy, profile }) => {
            console.log('📊 Using full profile data:', profile);
            console.log('📋 Using full vacancy data:', vacancy);
            
            const promptText = this.buildPrompt(vacancy, profile, request.style || 'formal', request.tone || 'professional');
            
            const aiRequest = {
              model: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free',
              prompt: promptText,
              max_tokens: 1500, // Увеличил для более детальных писем
              temperature: 0.4, // Снизил для большей консистентности
              top_p: 0.8,
              top_k: 40,
              repetition_penalty: 1.2,
              stop: [],
              stream: false
            };
      
            return this.aiService.generateText(aiRequest).pipe(
              map(content => {
                const cleaned = this.cleanLetterContent(content);
                
                // Проверяем, что в письме есть контактные данные
                const finalContent = this.ensureContactDetails(cleaned, profile);
                
                return {
                  content: finalContent,
                  generated_at: new Date().toISOString(),
                  resume_id: request.resume_id || 'uploaded',
                  vacancy_id: request.vacancy_id,
                  style: request.style || 'formal',
                  tone: request.tone || 'professional',
                  profile_used: !!profile, // Флаг что использовались данные профиля
                  contacts_included: this.hasContactDetails(finalContent, profile)
                };
              }),
              switchMap(response => {
                return from(this.usageService.incrementUsage('coverLetters')).pipe(
                  map(() => response)
                );
              })
            );
          }),
          catchError(error => {
            if (error.status === 429 || error.status === 400) {
              this.errorHandler.showAIError('Ошибка генерации письма', 'CoverLetterService');
            } else {
              this.errorHandler.showError('Ошибка генерации письма', 'CoverLetterService');
            }
            return throwError(() => error);
          })
        );
      }),
      catchError(error => {
        return throwError(() => error);
      })
    );
  }

  private ensureContactDetails(content: string, profile: any): string {
    const hasEmail = content.includes('@') || 
                    (profile?.email && content.toLowerCase().includes(profile.email.toLowerCase())) ||
                    (profile?.contact?.email && content.toLowerCase().includes(profile.contact.email.toLowerCase()));
    
    const hasPhone = /\+\d|тел|phone|contact/i.test(content) ||
                    (profile?.phone && content.includes(profile.phone)) ||
                    (profile?.contact?.phone && content.includes(profile.contact.phone));
    
    const userName = profile?.name || profile?.full_name || 'Кандидат';
    
    let finalContent = content;
    
    // Добавляем контактные данные если их нет
    if (!hasEmail || !hasPhone) {
      let contactSection = `\n\nС уважением,\n${userName}`;
      
      if (!hasEmail && profile?.email) {
        contactSection += `\nEmail: ${profile.email}`;
      } else if (!hasEmail && profile?.contact?.email) {
        contactSection += `\nEmail: ${profile.contact.email}`;
      }
      
      if (!hasPhone && profile?.phone) {
        contactSection += `\nТелефон: ${profile.phone}`;
      } else if (!hasPhone && profile?.contact?.phone) {
        contactSection += `\nТелефон: ${profile.contact.phone}`;
      }
      
      if (content.includes('С уважением')) {
        finalContent = content.replace(/С уважением[\s\S]*$/, contactSection);
      } else {
        finalContent += contactSection;
      }
    }
    
    return finalContent;
  }
  
  private hasContactDetails(content: string, profile: any): boolean {
    const hasEmail = content.includes('@') || 
                    (profile?.email && content.toLowerCase().includes(profile.email.toLowerCase())) ||
                    (profile?.contact?.email && content.toLowerCase().includes(profile.contact.email.toLowerCase()));
    
    const hasPhone = /\+\d|тел|phone|contact/i.test(content) ||
                    (profile?.phone && content.includes(profile.phone)) ||
                    (profile?.contact?.phone && content.includes(profile.contact.phone));
    
    return hasEmail && hasPhone;
  }

  private cleanLetterContent(content: string): string {
    if (!content) return this.createFallbackLetterContent();
    
    console.log('🧹 Cleaning AI response, length:', content.length);
    
    let cleaned = content
      .replace(/```(?:json|html|markdown)?/g, '')
      .replace(/[\*\_]{2,}/g, '')
      .replace(/\n{3,}/g, '\n\n') 
      .replace(/^\s*\{.*?\}\s*$/gm, '')
      .replace(/\b(?:шаг\s*\d+|этап\s*\d+|step\s*\d+)/gi, '')
      .replace(/\b(?:комиссия по отбору|члены комиссии|экспертная оценка|улучшенная версия)\b/gi, '')
      .replace(/[!]{2,}/g, '!')
      .trim();
  
    const invalidPhrases = [
      'комиссия по отбору',
      'члены комиссии', 
      'экспертная оценка',
      'улучшенная версия',
      'шаг 6',
      'с уважением!',
      '!!!',
      'господа',
      'уважаемые господа'
    ];
  
    invalidPhrases.forEach(phrase => {
      const regex = new RegExp(phrase, 'gi');
      cleaned = cleaned.replace(regex, '');
    });
  
    return cleaned;
  }

  private createFallbackLetterContent(vacancy?: any, profile?: any): string {
    const companyName = vacancy?.employer?.name || vacancy?.firm_name || 'компании';
    const vacancyName = vacancy?.name || vacancy?.profession || 'должности';
    const userName = profile?.name || 'Кандидат';
    
    return `Не работает генерация сопр. письма`;
  }

  private getVacancyDetails(vacancyId: string): Observable<any> {
    return this.vacancyService.getVacancy(vacancyId).pipe(
      catchError(error => {
        this.errorHandler.showError('Ошибка загрузки вакансии', 'CoverLetterService');
        throw new Error(`Не удалось загрузить вакансию: ${error.message}`);
      })
    );
  }

  private buildPrompt(vacancy: any, profile: any, style: string, tone: string): string {
    console.log('🔍 BUILDING ENHANCED PROMPT WITH FULL PROFILE DATA');
    
    // Извлечение данных вакансии
    let companyName, vacancyName, city, salary, description, requirements, keySkills, experience, employment, responsibilities;
    
    if (vacancy.platform === 'superjob') {
      companyName = vacancy.firm_name || vacancy.employer?.name;
      vacancyName = vacancy.profession || vacancy.name;
      city = vacancy.town?.title || vacancy.area?.name || '';
      salary = vacancy.salary ? this.formatSalary(vacancy.salary) : 
               (vacancy.payment_from || vacancy.payment_to) ? 
               `${vacancy.payment_from ? `от ${vacancy.payment_from}` : ''} ${vacancy.payment_to ? `до ${vacancy.payment_to}` : ''} ${vacancy.currency || 'руб.'}`.trim() : '';
      description = vacancy.vacancyRichText || vacancy.description || '';
      requirements = vacancy.candidat || '';
      keySkills = vacancy.key_skills?.map((skill: any) => skill.name).join(', ') || '';
      experience = vacancy.experience?.name || '';
      employment = vacancy.type_of_work?.title || vacancy.employment?.name || '';
      responsibilities = vacancy.work_place || '';
    } else {
      companyName = vacancy.employer?.name;
      vacancyName = vacancy.name;
      city = vacancy.area?.name || '';
      salary = vacancy.salary ? this.formatSalary(vacancy.salary) : '';
      description = vacancy.description || '';
      requirements = vacancy.snippet?.requirement || '';
      keySkills = vacancy.key_skills?.map((skill: any) => skill.name).join(', ') || '';
      experience = vacancy.experience?.name || '';
      employment = vacancy.employment?.name || '';
      responsibilities = vacancy.snippet?.responsibility || '';
    }
  
    // Полное извлечение данных профиля
    const userName = profile?.name || profile?.full_name || 'Кандидат';
    const userEmail = profile?.email || profile?.contact?.email || '';
    const userPhone = profile?.phone || profile?.contact?.phone || '';
    const userPosition = profile?.position || profile?.title || '';
    const userAbout = profile?.about || profile?.summary || '';
    
    // Навыки профиля
    const userSkills = profile?.skills?.map((s: any) => {
      if (typeof s === 'string') return s;
      return `${s.name}${s.level ? ` (${s.level}/10)` : ''}`;
    }).join(', ') || '';
    
    // Опыт работы
    const userExperience = this.calculateTotalExperience(profile?.experience);
    const formattedExperience = this.formatExperience(userExperience);
    
    // Образование
    const userEducation = profile?.education?.map((e: any) => {
      if (typeof e === 'string') return e;
      return `${e.institution || e.school} - ${e.specialty || e.degree}${e.year ? ` (${e.year})` : ''}`;
    }).join('; ') || '';
    
    // Языки
    const userLanguages = profile?.languages?.map((l: any) => {
      if (typeof l === 'string') return l;
      return `${l.language}${l.level ? ` - ${l.level}` : ''}`;
    }).join(', ') || '';
    
    // Дополнительная информация
    const userCertifications = profile?.certifications?.map((c: any) => {
      if (typeof c === 'string') return c;
      return `${c.name}${c.issuer ? ` (${c.issuer})` : ''}${c.date ? ` - ${c.date}` : ''}`;
    }).join('; ') || '';
  
    const userProjects = profile?.projects?.map((p: any) => {
      if (typeof p === 'string') return p;
      return `${p.name}${p.description ? `: ${p.description}` : ''}`;
    }).join('; ') || '';
  
    if (!companyName || !vacancyName) {
      console.error('❌ Insufficient vacancy data:', vacancy);
      throw new Error('Недостаточно данных о вакансии для генерации письма');
    }
  
    const promptText = `Ты профессиональный HR-специалист и эксперт по составлению сопроводительных писем. Сгенерируй КОРРЕКТНОЕ и РЕЛЕВАНТНОЕ сопроводительное письмо строго по шаблону.
  
  # КРИТИЧЕСКИ ВАЖНЫЕ ПРАВИЛА:
  - Текст должен быть РЕЛЕВАНТЕН конкретной вакансии и навыкам кандидата
  - Используй ТОЛЬКО реальные данные из профиля кандидата
  - Деловой профессиональный стиль, без эмоциональных восклицаний
  - Без упоминания "комиссии по отбору", "членов комиссии" и т.п.
  - Максимальная конкретика и соответствие требованиям вакансии
  - Длина: 250-400 слов
  - Обязательно включи контактные данные: ${userEmail}${userPhone ? `, ${userPhone}` : ''}
  
  # ШАБЛОН ПИСЬМА (соблюдай структуру):
  
  [ПРИВЕТСТВИЕ]
  Уважаемые HR-специалисты компании "${companyName}"!
  
  [ВСТУПЛЕНИЕ - интерес к вакансии]
  Проявляю интерес к вакансии "${vacancyName}" и хотел(а) бы представить свою кандидатуру на рассмотрение.
  
  [СООТВЕТСТВИЕ ТРЕБОВАНИЯМ - конкретные навыки и опыт]
  ${this.generateSkillsSection(keySkills, userSkills, userExperience, userPosition)}
  
  [МОТИВАЦИЯ - почему именно эта компания/должность]
  ${this.generateMotivationSection(companyName, vacancyName, userAbout)}
  
  [ЗАВЕРШЕНИЕ]
  Буду рад(а) обсудить возможность сотрудничества на собеседовании.
  
  [ПОДПИСЬ]
  С уважением,
  ${userName}
  ${userEmail ? `Email: ${userEmail}` : ''}${userPhone ? `
  Телефон: ${userPhone}` : ''}
  
  # ДАННЫЕ ВАКАНСИИ:
  - Компания: "${companyName}"
  - Должность: "${vacancyName}"
  - Город: ${city || 'не указан'}
  - Зарплата: ${salary || 'не указана'}
  - Требуемый опыт: ${experience || 'не указан'}
  - Тип занятости: ${employment || 'не указан'}
  
  # КЛЮЧЕВЫЕ ТРЕБОВАНИЯ ВАКАНСИИ:
  ${keySkills || 'Не указаны'}
  ${requirements ? `Дополнительные требования: ${requirements.substring(0, 300)}...` : ''}
  ${responsibilities ? `Обязанности: ${responsibilities.substring(0, 300)}...` : ''}
  
  # ОПИСАНИЕ ВАКАНСИИ:
  ${description.substring(0, 600)}...
  
  # ПРОФИЛЬ КАНДИДАТА:
  - Имя: ${userName}
  - Текущая должность: ${userPosition || 'не указана'}
  - Email: ${userEmail || 'не указан'}
  - Телефон: ${userPhone || 'не указан'}
  - Опыт работы: ${formattedExperience}
  - Ключевые навыки: ${userSkills || 'не указаны'}
  - Образование: ${userEducation || 'не указано'}
  - Языки: ${userLanguages || 'не указаны'}
  - ${userAbout ? `О себе: ${userAbout.substring(0, 200)}...` : ''}
  - ${userCertifications ? `Сертификаты: ${userCertifications}` : ''}
  - ${userProjects ? `Проекты: ${userProjects}` : ''}
  
  # СТИЛЬ И ТОН:
  - Стиль: ${this.getStyleDescription(style)}
  - Тон: ${this.getToneDescription(tone)}
  
  Сгенерируй сопроводительное письмо строго по шаблону, используя ВСЕ релевантные данные из профиля кандидата и делая акцент на соответствие требованиям вакансии:`;
  
    return promptText;
  }

  private calculateTotalExperience(experience: any[]): number {
    if (!experience || !Array.isArray(experience)) return 0;
    
    let totalMonths = 0;
    
    experience.forEach(exp => {
      if (exp.start_date && exp.end_date) {
        const start = new Date(exp.start_date);
        const end = exp.end_date === 'present' ? new Date() : new Date(exp.end_date);
        const months = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        totalMonths += Math.max(0, months);
      } else if (exp.duration) {
        // Если длительность указана в текстовом формате
        totalMonths += this.parseDuration(exp.duration);
      }
    });
    
    return Math.round(totalMonths / 12);
  }
  
  private parseDuration(duration: string): number {
    const yearsMatch = duration.match(/(\d+)\s*год/);
    const monthsMatch = duration.match(/(\d+)\s*месяц/);
    
    let months = 0;
    if (yearsMatch) months += parseInt(yearsMatch[1]) * 12;
    if (monthsMatch) months += parseInt(monthsMatch[1]);
    
    return months;
  }
  
  private formatExperience(years: number): string {
    if (years === 0) return 'Без опыта';
    if (years === 1) return '1 год';
    if (years >= 2 && years <= 4) return `${years} года`;
    return `${years} лет`;
  }
  
  private generateSkillsSection(vacancySkills: string, userSkills: string, experience: number, position: string): string {
    let section = 'Мои профессиональные навыки и опыт включают: ';
    
    if (userSkills) {
      // Находим пересечение навыков вакансии и кандидата
      const vacancySkillsArray = vacancySkills.toLowerCase().split(', ').map(s => s.trim());
      const userSkillsArray = userSkills.split(', ').map(s => s.trim());
      
      const matchingSkills = userSkillsArray.filter(skill => 
        vacancySkillsArray.some(vacSkill => 
          skill.toLowerCase().includes(vacSkill) || vacSkill.includes(skill.toLowerCase())
        )
      );
      
      if (matchingSkills.length > 0) {
        section += matchingSkills.slice(0, 5).join(', ') + '. ';
      } else {
        section += userSkills.split(', ').slice(0, 5).join(', ') + '. ';
      }
    }
    
    if (experience > 0) {
      section += `Опыт работы в сфере ${position || 'по специальности'} составляет ${experience} ${this.pluralize(experience, ['год', 'года', 'лет'])}.`;
    } else {
      section += `Несмотря на отсутствие коммерческого опыта, обладаю сильной теоретической подготовкой в ключевых областях.`;
    }
    
    return section;
  }
  
  private generateMotivationSection(companyName: string, vacancyName: string, userAbout: string): string {
    let motivation = `Заинтересован(а) в позиции "${vacancyName}" в компании "${companyName}", так как `;
    
    if (userAbout && userAbout.length > 50) {
      // Извлекаем ключевые моменты из "О себе"
      const aboutKeywords = this.extractKeywords(userAbout);
      if (aboutKeywords.length > 0) {
        motivation += `мои профессиональные интересы и компетенции (${aboutKeywords.slice(0, 3).join(', ')}) полностью соответствуют требованиям данной позиции.`;
      } else {
        motivation += `считаю, что мой опыт и навыки идеально подходят для успешного выполнения поставленных задач.`;
      }
    } else {
      motivation += `уверен(а), что смогу внести значительный вклад в развитие компании благодаря своему опыту и профессиональным качествам.`;
    }
    
    return motivation;
  }
  
  private extractKeywords(text: string): string[] {
    const keywords = [
      'разработка', 'управление', 'анализ', 'проектирование', 'оптимизация', 
      'внедрение', 'координация', 'планирование', 'контроль', 'развитие',
      'автоматизация', 'тестирование', 'дизайн', 'маркетинг', 'продажи'
    ];
    
    return keywords.filter(keyword => 
      text.toLowerCase().includes(keyword.toLowerCase())
    );
  }
  
  private formatSalary(salary: any): string {
    if (!salary) return '';
    
    if (salary.from && salary.to) {
      return `${salary.from} - ${salary.to} ${salary.currency}`;
    } else if (salary.from) {
      return `от ${salary.from} ${salary.currency}`;
    } else if (salary.to) {
      return `до ${salary.to} ${salary.currency}`;
    }
    return '';
  }
  
  private getStyleDescription(style: string): string {
    const styles: { [key: string]: string } = {
      'formal': 'формальный деловой стиль',
      'creative': 'креативный современный стиль', 
      'technical': 'технический ориентированный стиль'
    };
    return styles[style] || 'формальный деловой стиль';
  }
  
  private getToneDescription(tone: string): string {
    const tones: { [key: string]: string } = {
      'professional': 'профессиональный сдержанный',
      'enthusiastic': 'энтузиастичный энергичный',
      'conservative': 'консервативный традиционный'
    };
    return tones[tone] || 'профессиональный сдержанный';
  }

  private pluralize(count: number, forms: string[]): string {
    const cases = [2, 0, 1, 1, 1, 2];
    return forms[
      count % 100 > 4 && count % 100 < 20 ? 2 : cases[Math.min(count % 10, 5)]
    ];
  }

  sendToHH(coverLetterContent: string, vacancyId: string, resumeId: string, hhToken: string): Observable<any> {
    return from(this.hhAuthService.sendApplication(vacancyId, resumeId, coverLetterContent, hhToken)).pipe(
      catchError(error => {
        this.errorHandler.showError('Ошибка отправки на HH.ru', 'CoverLetterService');
        return throwError(() => new Error('Ошибка отправки на HH.ru: ' + error.message));
      })
    );
  }

  saveTemplate(template: CoverLetterTemplate): Observable<CoverLetterTemplate> {
    const templates = this.getTemplates();
    const existingIndex = templates.findIndex(t => t.id === template.id);
    
    if (existingIndex >= 0) {
      templates[existingIndex] = template;
    } else {
      templates.push(template);
    }

    localStorage.setItem('cover_letter_templates', JSON.stringify(templates));
    return of(template);
  }

  getTemplates(): CoverLetterTemplate[] {
    const stored = localStorage.getItem('cover_letter_templates');
    return stored ? JSON.parse(stored) : this.getDefaultTemplates();
  }

  deleteTemplate(templateId: string): Observable<void> {
    const templates = this.getTemplates().filter(t => t.id !== templateId);
    localStorage.setItem('cover_letter_templates', JSON.stringify(templates));
    return of(void 0);
  }

  private getDefaultTemplates(): CoverLetterTemplate[] {
    return [
      {
        id: 'formal-1',
        name: 'Формальный шаблон',
        content: `Уважаемые представители компании {{companyName}}!

Проявляю интерес к вашей вакансии "{{vacancyName}}" и представляю свое резюме.

С уважением,
{{userName}}`,
        is_default: true
      },
      {
        id: 'creative-1',
        name: 'Креативный шаблон',
        content: `Привет команде {{companyName}}! 🚀

Загорелся вашей вакансией "{{vacancyName}}"!

Давайте знакомиться!
{{userName}}`,
        is_default: false
      }
    ];
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\db\edge-config.service.ts ---

import { get } from '@vercel/edge-config';

export class EdgeConfigService {
  // Кэширование настроек платформ
  async getPlatformConfigs() {
    return await get('platformConfigs') || {
      hh: { enabled: true, rateLimit: 100 },
      superjob: { enabled: true, rateLimit: 50 },
      habr: { enabled: false }
    };
  }

  async getFeatureFlags() {
    return await get('featureFlags') || {
      aiResumeGeneration: true,
      interviewPrep: true,
      coverLetterTemplates: false,
      newUI: false
    };
  }

  async getAIPrompts() {
    return await get('aiPrompts') || {
      resume: "Сгенерируй профессиональное резюме...",
      coverLetter: "Создай сопроводительное письмо...",
      interview: "Подготовь план собеседования..."
    };
  }

  async getCacheConfig() {
    return await get('cacheConfig') || {
      vacancyCacheTtl: 3600,
      resumeCacheTtl: 7200,
      profileCacheTtl: 1800
    };
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\db\supabase.service.ts ---

import { Injectable } from '@angular/core';
import { createClient, SupabaseClient, AuthSession, User } from '@supabase/supabase-js';
import { environment } from '../../../environments/environment.prod';
import { Router } from '@angular/router';
import { BehaviorSubject, Observable } from 'rxjs';
import { AppConfig } from '../config/config.service';
import { AppStateService } from '../state/app-state.service';
import { ErrorHandlerService } from '../error-handler.service';

export interface UserProfile {
  id: string;
  email: string;
  full_name: string;
  phone?: string;
  gender: 'male' | 'female' | 'unknown';
  profile_data: {
    desiredPositions: string[];
    contact: {
      linkedin?: string;
      github?: string;
      [key: string]: any;
    };
    location: {
      country?: string;
      city: string;
      relocation: boolean;
      remote: boolean;
      business_trips: boolean;
    };
    languages: any[];
    skills: any[];
    education: any[];
    experience: any[];
    hobby: string[];
    literature: string[];
  };
  created_at: string;
  updated_at: string;
}

@Injectable({
  providedIn: 'root'
})
export class SupabaseService {
  private supabase: SupabaseClient | undefined;
  private session: AuthSession | null = null;
  private userSubject = new BehaviorSubject<User | null>(null);
  private _initialized = false;
  private initializedSubject = new BehaviorSubject<boolean>(false);
  public initialized$: Observable<boolean> = this.initializedSubject.asObservable();
  
  get initialized(): boolean {
    return this.initializedSubject.value;
  }

  constructor(
    private router: Router, 
    private appStateService: AppStateService,
    private errorHandler: ErrorHandlerService
  ) {
    this.setupAuthStateHandling();
  }

  private setupAuthStateHandling(): void {
    this.supabase?.auth.onAuthStateChange((event, session) => {
      this.session = session;
      this.userSubject.next(session?.user || null);
      
      if (event === 'SIGNED_IN') {
        this.appStateService.saveState({
          ...this.appStateService.getState(),
          user: {
            id: session?.user?.id,
            email: session?.user?.email
          }
        });
        this.router.navigate(['/profile/view']);
      } else if (event === 'SIGNED_OUT') {
        this.appStateService.clearState();
        this.router.navigate(['/login']);
      }
    });
  }

  private async mockSignOut() {
    console.log('Mock sign-out triggered');
    
    localStorage.removeItem('sb-mock-session');
    localStorage.removeItem('sb-local-profile');
    this.session = null;
    this.userSubject.next(null);
    
    this.router.navigate(['/']);
  }

  get client(): SupabaseClient {
    if (!this.supabase) {
      throw new Error('Supabase client not initialized');
    }
    return this.supabase;
  }

  async initialize(config: AppConfig): Promise<void> {
    try {
      console.log('Initializing Supabase with config from:', 
        environment.production ? 'API endpoint' : 'environment.ts');

      if (!config.supabaseUrl || !config.supabaseKey) {
        console.warn('Supabase configuration missing, using mock mode');
        this.setupMockAuth();
        return;
      }

      try {
        const testResponse = await fetch(`${config.supabaseUrl}/rest/v1/`, {
          method: 'HEAD',
          headers: {
            'apikey': config.supabaseKey
          }
        });
        
        if (!testResponse.ok) {
          throw new Error(`Supabase not accessible: ${testResponse.status}`);
        }
        
        console.log('Supabase is accessible, initializing client');
        
      } catch (error) {
        console.warn('Supabase not accessible, using mock mode:', error);
        this.setupMockAuth();
        return;
      }

      // Инициализируем реальный клиент с исправленными настройками auth
      this.supabase = createClient(config.supabaseUrl, config.supabaseKey, {
        auth: {
          persistSession: true,
          autoRefreshToken: true,
          detectSessionInUrl: true,
          flowType: 'pkce',
          // Отключаем встроенный lock для избежания ошибок
          storage: this.createSafeStorage()
        }
      });

      await this.initAuth();

    } catch (error) {
      console.error('Supabase initialization failed, using mock mode:', error);
      this.setupMockAuth();
    }
  }

  // Создаем безопасную реализацию storage для обхода проблем с LockManager
  private createSafeStorage() {
    return {
      getItem: (key: string): Promise<string | null> => {
        return new Promise((resolve) => {
          try {
            const value = localStorage.getItem(key);
            resolve(value);
          } catch (error) {
            console.warn('Storage getItem failed:', error);
            resolve(null);
          }
        });
      },
      setItem: (key: string, value: string): Promise<void> => {
        return new Promise((resolve) => {
          try {
            localStorage.setItem(key, value);
            resolve();
          } catch (error) {
            console.warn('Storage setItem failed:', error);
            resolve();
          }
        });
      },
      removeItem: (key: string): Promise<void> => {
        return new Promise((resolve) => {
          try {
            localStorage.removeItem(key);
            resolve();
          } catch (error) {
            console.warn('Storage removeItem failed:', error);
            resolve();
          }
        });
      }
    };
  }

  private async initAuth(): Promise<void> {
    if (!this.supabase) return;
  
    try {
      // Используем безопасный метод получения сессии
      const { data: { session }, error } = await this.supabase.auth.getSession();
      
      if (error) {
        console.warn('Session error:', error);
        // Пробуем восстановить сессию из localStorage
        await this.tryRecoverSession();
      } else if (session) {
        this.session = session;
        this.userSubject.next(session.user);
      }
  
      // Настраиваем обработчик изменений состояния аутентификации
      this.supabase.auth.onAuthStateChange((event, session) => {
        console.log('Auth state changed:', event);
        this.session = session;
        this.userSubject.next(session?.user || null);
  
        if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
          this.appStateService.saveState({
            ...this.appStateService.getState(),
            user: {
              id: session?.user?.id,
              email: session?.user?.email
            }
          });
          
          if (this.router.url.includes('/login') || this.router.url.includes('/auth/callback')) {
            this.router.navigate(['/profile/view']);
          }
        } else if (event === 'SIGNED_OUT') {
          this.appStateService.clearState();
          this.router.navigate(['/login']);
        }
      });
  
      this.initializedSubject.next(true);
  
    } catch (error) {
      console.error('Auth initialization failed:', error);
      this.initializedSubject.next(true);
    }
  }

  private async tryRecoverSession(): Promise<void> {
    try {
      const storageKey = `sb-${environment.supabaseUrl?.split('//')[1]?.split('.')[0]}-auth-token`;
      const storedSession = localStorage.getItem(storageKey);
      
      if (storedSession) {
        const session = JSON.parse(storedSession);
        if (session?.access_token && session?.expires_at > Date.now() / 1000) {
          this.session = session;
          this.userSubject.next(session.user);
          console.log('Session recovered from localStorage');
        }
      }
    } catch (error) {
      console.warn('Session recovery failed:', error);
    }
  }

  private setupMockAuth(): void {
    console.log('Setting up mock authentication');
    
    const savedSession = localStorage.getItem('sb-mock-session');
    if (savedSession) {
      try {
        const session = JSON.parse(savedSession);
        this.session = session;
        this.userSubject.next(session.user);
        console.log('Restored mock session from storage');
      } catch (e) {
        console.error('Error parsing saved session:', e);
      }
    }

    this.initializedSubject.next(true);
  }

  get currentUser(): User | null {
    if (!this.session && localStorage.getItem('sb-mock-session')) {
      try {
        this.session = JSON.parse(localStorage.getItem('sb-mock-session')!);
      } catch (e) {
        console.error('Error parsing saved session:', e);
      }
    }
    return this.session?.user || null;
  }

  get currentSession() {
    return this.session;
  }

  get isInitialized(): boolean {
    return this._initialized;
  }

  private async mockGoogleSignIn() {
    console.log('Mock Google sign-in triggered');
    
    const mockUser = {
      id: this.generateValidUUID(),
      email: 'test.user@example.com',
      user_metadata: { 
        full_name: 'Test User', 
        avatar_url: 'default_avatar.jpg',
        provider: 'google'
      },
      app_metadata: { provider: 'google' },
      aud: 'authenticated',
      created_at: new Date().toISOString(),
      confirmed_at: new Date().toISOString(),
      last_sign_in_at: new Date().toISOString(),
      role: 'authenticated',
      updated_at: new Date().toISOString()
    };
  
    const mockSession: any = {
      user: mockUser,
      access_token: 'mock-access-token-' + Math.random().toString(36).substring(2),
      refresh_token: 'mock-refresh-token-' + Math.random().toString(36).substring(2),
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: 'bearer' as const
    };
  
    localStorage.setItem('sb-mock-session', JSON.stringify(mockSession));
    this.session = mockSession;
    this.userSubject.next(mockUser);
    
    this.router.navigate(['/profile/view']);
    
    return { data: { user: mockUser }, error: null };
  }
  
  async signInWithGoogle() {
    // Если Supabase недоступен, используем мок
    if (!this.supabase) {
      return this.mockGoogleSignIn();
    }
  
    try {
      const { error } = await this.supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: this.getRedirectUri(),
          queryParams: {
            access_type: 'offline',
            prompt: 'consent'
          }
        }
      });
  
      if (error) throw error;
      return { data: { user: null }, error: null };
    } catch (error) {
      console.error('Google OAuth error, using mock:', error);
      return this.mockGoogleSignIn();
    }
  }

  private getRedirectUri(): string {
    if (environment.production) {
      return 'https://rezulution.vercel.app/auth/callback';
    }
    return window.location.origin + '/auth/callback';
  }

  async saveFullProfile(profileData: any): Promise<{ data: any; error: any }> {
    try {
      const userId = this.currentUser?.id;
      if (!userId) {
        throw new Error('User not authenticated');
      }
  
      const profile = {
        id: userId,
        email: profileData.contact?.email || this.currentUser?.email,
        full_name: profileData.name,
        phone: profileData.contact?.phone,
        gender: profileData.gender,
        profile_data: {
          desiredPositions: profileData.desiredPositions || [],
          contact: {
            linkedin: profileData.contact?.['linkedin'],
            github: profileData.contact?.['github']
          },
          location: profileData.location,
          languages: profileData.languages || [],
          skills: profileData.skills || [],
          education: profileData.education || [],
          experience: profileData.experience || [],
          hobby: profileData.hobby || [],
          literature: profileData.literature || []
        },
        updated_at: new Date().toISOString()
      };
  
      if (!environment.production) {
        localStorage.setItem('sb-local-profile', JSON.stringify(profile));
        return { data: profile, error: null };
      }
  
      const { data, error } = await this.supabase!
        .from('user_profiles')
        .upsert(profile, { 
          onConflict: 'id'
        })
        .select();

      if (error) {
        this.errorHandler.showError('Ошибка Supabase', 'SupabaseService');
        localStorage.setItem('sb-local-profile', JSON.stringify(profile));
        return { data: profile, error: null };
      }
  
      return { data: data ? data[0] : profile, error: null };
    } catch (error) {
      console.error('Error saving profile:', error);
      return { data: null, error: error as Error };
    }
  }

  async getFullProfile(): Promise<UserProfile | null> {
    try {
      if (!this.currentUser?.id) {
        return null;
      }
  
      if (!environment.production) {
        const profile = localStorage.getItem('sb-local-profile');
        return profile ? JSON.parse(profile) : this.createDefaultProfile();
      }
  
      const { data, error } = await this.supabase!
        .from('user_profiles')
        .select('*')
        .eq('id', this.currentUser.id)
        .single();
  
      if (error) {
        console.error('Supabase error loading profile:', error);
        
        if (error.code === 'PGRST116') {
          const defaultProfile = this.createDefaultProfile();
          return defaultProfile;
        }
        
        return this.createDefaultProfile();
      }
  
      return data || this.createDefaultProfile();
    } catch (error) {
      this.errorHandler.showError('Ошибка загрузки профиля', 'SupabaseService');
      return this.createDefaultProfile();
    }
  }

  private createDefaultProfile(): UserProfile {
    return {
      id: this.currentUser?.id || 'local-user',
      email: this.currentUser?.email || '',
      full_name: this.currentUser?.user_metadata?.['full_name'] || 'User',
      phone: '',
      gender: 'unknown',
      profile_data: {
        desiredPositions: [],
        contact: {
          linkedin: '',
          github: ''
        },
        location: {
          country: '',
          city: '',
          relocation: false,
          remote: false,
          business_trips: false
        },
        languages: [],
        skills: [],
        education: [],
        experience: [],
        hobby: [],
        literature: []
      },
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
  }

  private generateValidUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  async signOut() {
    if (!this.supabase) {
      return this.mockSignOut();
    }

    try {
      // Очищаем localStorage перед выходом
      this.clearProblematicStorage();
      
      await this.supabase.auth.signOut();
      window.location.href = '/';
    } catch (error) {
      this.errorHandler.showError('Ошибка выхода из системы', 'SupabaseService');
      this.mockSignOut();
    }
  }

  async createUserProfile(userData: any) {
    try {
      const profile = {
        id: userData.id,
        email: userData.email || '',
        full_name: userData.user_metadata?.['full_name'] || 'User',
        avatar_url: userData.user_metadata?.['avatar_url'] || '',
        created_at: new Date().toISOString()
      };
  
      if (!environment.production) {
        localStorage.setItem('sb-local-profile', JSON.stringify(profile));
        return { data: [profile], error: null };
      }
  
      const { data, error } = await this.supabase!
        .from('user_profiles')
        .upsert(profile, { onConflict: 'id' });
  
      if (error) {
        this.errorHandler.showError('Ошибка Supabase', 'SupabaseService');
        localStorage.setItem('sb-local-profile', JSON.stringify(profile));
        return { data: [profile], error: null };
      }
  
      return { data, error: null };
    } catch (error) {
      this.errorHandler.showError('Ошибка создания профиля', 'SupabaseService'); 
      return { data: null, error: error as Error };
    }
  }

  async getProfile() {
    if (!environment.production) {
      const profile = localStorage.getItem('sb-local-profile');
      if (profile) {
        return JSON.parse(profile);
      }
      
      const mockProfile = {
        id: this.currentUser?.id || 'local-user-' + Math.random().toString(36).substring(2),
        email: this.currentUser?.email || 'local-user@example.com',
        full_name: this.currentUser?.user_metadata?.['full_name'] || 'Local User',
        phone: '',
        gender: 'unknown',
        profile_data: {}
      };
      
      localStorage.setItem('sb-local-profile', JSON.stringify(mockProfile));
      return mockProfile;
    }
    
    const { data, error } = await this.supabase!
      .from('user_profiles')
      .select('*')
      .eq('id', this.currentUser?.id)
      .single();
  
    if (error) {
      if (error.code === 'PGRST116') {
        return await this.createUserProfile(this.currentUser);
      }
      throw error;
    }
    return data;
  }

  // Метод для очистки проблемных локальных данных
  clearProblematicStorage(): void {
    const keysToRemove = [
      'sb-lxlzpilbbnzriywuvcnf-auth-token',
      'sb-mock-session',
      'sb-local-profile'
    ];
    
    keysToRemove.forEach(key => {
      try {
        localStorage.removeItem(key);
        sessionStorage.removeItem(key);
      } catch (e) {
        console.warn(`Failed to remove ${key}:`, e);
      }
    });
    
    // Очищаем все ключи, связанные с Supabase
    Object.keys(localStorage)
      .filter(key => key.startsWith('sb-') || key.includes('supabase'))
      .forEach(key => {
        try {
          localStorage.removeItem(key);
        } catch (e) {
          console.warn(`Failed to remove ${key}:`, e);
        }
      });
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\directives\translate-file-input.directive.ts ---

import { Directive, ElementRef, OnInit, OnDestroy } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { LanguageService } from '../utils/language.service';
import { Subscription } from 'rxjs';

@Directive({
  selector: 'input[type="file"][translate]',
  standalone: true
})
export class TranslateFileInputDirective implements OnInit, OnDestroy {
  private subscriptions: Subscription[] = [];

  constructor(
    private el: ElementRef<HTMLInputElement>,
    private translate: TranslateService,
    private languageService: LanguageService
  ) {}

  ngOnInit() {
    this.updatePlaceholder();
    
    this.subscriptions.push(
      this.languageService.languageChanges$.subscribe(() => {
        this.updatePlaceholder();
      })
    );
  }

  private updatePlaceholder() {
    const currentLang = this.languageService.getCurrentLanguage();
    
    if (currentLang === 'ru') {
      this.el.nativeElement.setAttribute('placeholder', 'Файл не выбран');
    } else {
      this.el.nativeElement.setAttribute('placeholder', 'No file chosen');
    }
  }

  ngOnDestroy() {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\favorites\favorites.service.ts ---

import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { Vacancy } from '../../vacancy-schema';

export interface FavoriteVacancy extends Vacancy {
  isFavorite: boolean;
  coverLetter?: string;
  developmentPlan?: string;
  generatedResume?: string;
  lastGenerated?: string;
}

@Injectable({
  providedIn: 'root'
})
export class FavoritesService {
  private readonly FAVORITES_KEY = 'favorite_vacancies';
  private favoritesSubject = new BehaviorSubject<FavoriteVacancy[]>([]);
  public favorites$ = this.favoritesSubject.asObservable();

  constructor() {
    this.loadFavorites();
  }

  private loadFavorites(): void {
    const favorites = localStorage.getItem(this.FAVORITES_KEY);
    if (favorites) {
      try {
        const parsedFavorites = JSON.parse(favorites);
        this.favoritesSubject.next(parsedFavorites);
      } catch (error) {
        console.error('Error loading favorites:', error);
        this.favoritesSubject.next([]);
      }
    }
  }

  getFavorites(): FavoriteVacancy[] {
    return this.favoritesSubject.value;
  }

  addToFavorites(vacancy: Vacancy): void {
    const favorites = this.getFavorites();
    const existingIndex = favorites.findIndex(fav => fav.id === vacancy.id);
    
    if (existingIndex === -1) {
      const favoriteVacancy: FavoriteVacancy = {
        ...vacancy,
        isFavorite: true,
        lastGenerated: new Date().toISOString()
      };
      favorites.push(favoriteVacancy);
      this.saveFavorites(favorites);
    }
  }

  removeFromFavorites(vacancyId: string): void {
    const favorites = this.getFavorites().filter(fav => fav.id !== vacancyId);
    this.saveFavorites(favorites);
  }

  updateFavorite(vacancyId: string, updates: Partial<FavoriteVacancy>): void {
    const favorites = this.getFavorites();
    const index = favorites.findIndex(fav => fav.id === vacancyId);
    
    if (index !== -1) {
      favorites[index] = { ...favorites[index], ...updates };
      this.saveFavorites(favorites);
    }
  }

  isFavorite(vacancyId: string): boolean {
    return this.getFavorites().some(fav => fav.id === vacancyId);
  }

  private saveFavorites(favorites: FavoriteVacancy[]): void {
    localStorage.setItem(this.FAVORITES_KEY, JSON.stringify(favorites));
    this.favoritesSubject.next(favorites);
  }

  clearGeneratedContent(vacancyId: string, contentType: 'coverLetter' | 'developmentPlan' | 'resume'): void {
    const favorites = this.getFavorites();
    const index = favorites.findIndex(fav => fav.id === vacancyId);
    
    if (index !== -1) {
      switch (contentType) {
        case 'coverLetter':
          favorites[index].coverLetter = undefined;
          break;
        case 'developmentPlan':
          favorites[index].developmentPlan = undefined;
          break;
        case 'resume':
          favorites[index].generatedResume = undefined;
          break;
      }
      this.saveFavorites(favorites);
    }
  }

  getFavoriteById(vacancyId: string): FavoriteVacancy | undefined {
    return this.getFavorites().find(fav => fav.id === vacancyId);
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\guards\auth.guard.ts ---

import { catchError, filter, map, Observable, of, switchMap, take } from "rxjs";
import { SupabaseService } from "../db/supabase.service";
import { CanActivate, Router } from "@angular/router";
import { Injectable } from "@angular/core";

@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(
    private supabase: SupabaseService,
    private router: Router
  ) {}

  canActivate(): Observable<boolean> {
    return this.supabase.initialized$.pipe(
      filter(initialized => initialized),
      take(1),
      switchMap(() => {
        if (this.supabase.currentUser) {
          return of(true);
        } else {
          this.router.navigate(['/login'], {
            queryParams: { returnUrl: this.router.url }
          });
          return of(false);
        }
      }),
      catchError(() => {
        this.router.navigate(['/login']);
        return of(false);
      })
    );
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\guards\logged-in.guard.ts ---

import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { SupabaseService } from '../db/supabase.service';

@Injectable
({ 
  providedIn: 'root' 
})

export class LoggedInGuard implements CanActivate {
  constructor
  (
    private supabase: SupabaseService, 
    private router: Router
  ) {}

  canActivate(): boolean {
    if (!this.supabase.currentUser) {
      return true;
    }
    this.router.navigate(['/']);
    return false;
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\job-platforms\habr\habr-auth.service.ts ---


import { Injectable } from '@angular/core';
import { ConfigService } from '../../config/config.service';

export interface HabrTokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token?: string;
  expires_at?: number;
}

export interface HabrVacancy {
  id: number;
  title: string;
  company: { name: string; logo: string };
  salary: { from: number; to: number; currency: string };
  location: { city: string; country: string };
  description: string;
  requirements: string;
  conditions: string;
  skills: string[];
  experience: string;
  employment: string;
  published_at: string;
}

export interface HabrResume {
  id: number;
  title: string;
  skills: string[];
  experience: Array<{
    company: string;
    position: string;
    description: string;
    start_date: string;
    end_date: string;
  }>;
  education: Array<{
    institution: string;
    specialty: string;
    degree: string;
    end_year: number;
  }>;
  languages: Array<{
    language: string;
    level: string;
  }>;
}

@Injectable({ providedIn: 'root' })
export class HabrAuthService {
  private readonly HABR_TOKEN_KEY = 'habr_access_token';
  private readonly HABR_REFRESH_TOKEN_KEY = 'habr_refresh_token';
  private readonly HABR_TOKEN_EXPIRY_KEY = 'habr_token_expiry';
  private clientId: string = '';
  private clientSecret: string = '';
  private readonly API_URL = 'https://career.habr.com/api';

  constructor(private configService: ConfigService) {
    this.initializeConfig();
  }

  async initializeConfig(): Promise<void> {
    try {
      await this.configService.loadConfig();
      const config = this.configService.getConfig();
      this.clientId = config.habrClientId;
      this.clientSecret = config.habrClientSecret;
      
      if (!this.clientId || !this.clientSecret) {
        throw new Error('OAuth credentials not configured');
      }
    } catch (error) {
      console.error('Failed to initialize config:', error);
      throw error;
    }
  }

  getAuthUrl(state: string): string {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.getRedirectUri(),
      response_type: 'code',
      state: state,
      scope: 'cv_read cv_write applications_read applications_write'
    });
    
    return `https://career.habr.com/info/oauth/authorize?${params.toString()}`;
  }

  private getRedirectUri(): string {
    return window.location.origin + '/auth/habr-callback';
  }

  async exchangeCodeForToken(code: string): Promise<HabrTokenResponse> {
    if (!this.clientId || !this.clientSecret) {
      throw new Error('Habr Career OAuth not configured');
    }

    const response = await fetch('https://career.habr.com/info/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        client_id: this.clientId,
        client_secret: this.clientSecret,
        code: code,
        redirect_uri: this.getRedirectUri(),
        grant_type: 'authorization_code'
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Habr Career token exchange failed: ${response.status} ${errorText}`);
    }

    const tokenData: HabrTokenResponse = await response.json();
    this.saveToken(tokenData);
    
    return tokenData;
  }

  private saveToken(tokenData: HabrTokenResponse): void {
    const expiryTime = Date.now() + (tokenData.expires_in * 1000);
    
    localStorage.setItem(this.HABR_TOKEN_KEY, tokenData.access_token);
    localStorage.setItem(this.HABR_TOKEN_EXPIRY_KEY, expiryTime.toString());
    
    if (tokenData.refresh_token) {
      localStorage.setItem(this.HABR_REFRESH_TOKEN_KEY, tokenData.refresh_token);
    }
  }

  getStoredToken(): string | null {
    const token = localStorage.getItem(this.HABR_TOKEN_KEY);
    const expiry = localStorage.getItem(this.HABR_TOKEN_EXPIRY_KEY);

    if (!token || !expiry) {
      return null;
    }

    if (Date.now() > parseInt(expiry)) {
      this.clearTokens();
      return null;
    }

    return token;
  }

  isTokenValid(): boolean {
    return this.getStoredToken() !== null;
  }

  clearTokens(): void {
    localStorage.removeItem(this.HABR_TOKEN_KEY);
    localStorage.removeItem(this.HABR_REFRESH_TOKEN_KEY);
    localStorage.removeItem(this.HABR_TOKEN_EXPIRY_KEY);
  }

  async refreshToken(): Promise<string | null> {
    const refreshToken = localStorage.getItem(this.HABR_REFRESH_TOKEN_KEY);
    
    if (!refreshToken) {
      return null;
    }

    try {
      const response = await fetch('https://career.habr.com/info/oauth/token', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: new URLSearchParams({
          client_id: this.clientId,
          client_secret: this.clientSecret,
          refresh_token: refreshToken,
          grant_type: 'refresh_token'
        })
      });

      if (!response.ok) {
        throw new Error('Token refresh failed');
      }

      const tokenData: HabrTokenResponse = await response.json();
      this.saveToken(tokenData);
      
      return tokenData.access_token;
    } catch (error) {
      console.error('Habr Career token refresh error:', error);
      this.clearTokens();
      return null;
    }
  }

  async getValidToken(): Promise<string | null> {
    let token = this.getStoredToken();
    
    if (!token) {
      token = await this.refreshToken();
    }

    return token;
  }

  async getVacancies(params: any = {}): Promise<{ data: HabrVacancy[]; meta: any }> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в Habr Career');
    }

    const queryParams = new URLSearchParams({
      ...params,
      per_page: params.per_page || 20,
      page: params.page || 1
    });

    const response = await fetch(`${this.API_URL}/v1/vacancies?${queryParams}`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`Habr Career API error: ${response.status}`);
    }
    
    return await response.json();
  }

  async getResumes(): Promise<{ data: HabrResume[] }> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в Habr Career');
    }

    const response = await fetch(`${this.API_URL}/v1/resumes`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`Habr Career API error: ${response.status}`);
    }
    
    return await response.json();
  }

  async getVacancyDetails(vacancyId: number): Promise<{ data: HabrVacancy }> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в Habr Career');
    }

    const response = await fetch(`${this.API_URL}/v1/vacancies/${vacancyId}`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`Habr Career API error: ${response.status}`);
    }
    
    return await response.json();
  }

  async publishResume(resumeData: any): Promise<any> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в Habr Career');
    }

    const response = await fetch(`${this.API_URL}/v1/resumes`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(resumeData)
    });
    
    if (!response.ok) {
      throw new Error(`Habr Career API error: ${response.status}`);
    }
    
    return await response.json();
  }

  async sendApplication(vacancyId: number, resumeId: number, message: string): Promise<any> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в Habr Career');
    }

    const response = await fetch(`${this.API_URL}/v1/applications`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        vacancy_id: vacancyId,
        resume_id: resumeId,
        message: message
      })
    });
    
    if (!response.ok) {
      throw new Error(`Habr Career API error: ${response.status}`);
    }
    
    return await response.json();
  }

  async getCurrentUser(): Promise<any> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в Habr Career');
    }

    const response = await fetch(`${this.API_URL}/v1/me`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`Habr Career API error: ${response.status}`);
    }
    
    return await response.json();
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\job-platforms\hh\hh-auth.service.ts ---

import { Injectable } from '@angular/core';
import { ConfigService } from '../../config/config.service';
import { environment } from '../../../../environments/environment';
import { ErrorToastComponent } from '../../../components/Helpers/error-toast/error-toast.component';
import { ErrorHandlerService } from '../../error-handler.service';

type HHTokenResponse = {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token?: string;
  expires_at?: number;
};
export interface HHResume {
  id: string;
  title: string;
  created: string;
  updated: string;
  url: string;
  access_type: { type: string };
  status: { id: string; name: string };
  views_count: number;
  total_views: number;
  skills: string;
  experience: Array<{
    company: string;
    position: string;
    start: string;
    end: string;
  }>;
  education: Array<{
    level: { name: string };
    primary: Array<{
      name: string;
      year: number;
    }>;
  }>;
}

@Injectable({ providedIn: 'root' })
export class HHAuthService {
  private clientId: string = '';
  private clientSecret: string = '';
  private readonly HH_TOKEN_KEY = 'hh_access_token';
  private readonly HH_TOKEN_EXPIRY_KEY = 'hh_token_expiry';
  private readonly HH_REFRESH_TOKEN_KEY = 'hh_refresh_token';

  constructor(private configService: ConfigService,
  private errorHandler: ErrorHandlerService
  ) {
    this.configService.isConfigLoaded().subscribe(loaded => {
      if (loaded) {
        const config = this.configService.getConfig();
        this.clientId = config.hhClientId;
        this.clientSecret = config.hhClientSecret;
      }
    });
    this.initializeConfig();

  }
  private apiUrl = 'https://api.hh.ru';

  async initializeConfig(): Promise<void> {
    try {
      await this.configService.loadConfig();
      const config = this.configService.getConfig();
      this.clientId = config.hhClientId;
      this.clientSecret = config.hhClientSecret;
      
      if (!this.clientId || !this.clientSecret) {
        throw new Error('OAuth credentials not configured');
      }
    } catch (error) {
      console.error('Failed to initialize config:', error);
      throw error;
    }
  }
  getAuthUrl(state: string): string {
    if (!this.clientId) {
      throw new Error('HH OAuth not configured');
    }

    const params = new URLSearchParams({
      response_type: 'code',
      client_id: this.clientId,
      redirect_uri: this.getRedirectUri(),
      state: state,
    });
    
    return `https://hh.ru/oauth/authorize?${params.toString()}`;
  }
  async getUserResumes(): Promise<HHResume[]> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в HH.ru');
    }
  
    const response = await fetch('https://api.hh.ru/resumes/mine', {
      headers: {
        'Authorization': `Bearer ${token}`,
        'User-Agent': 'RezulutionApp/1.0',
        'HH-User-Agent': 'RezulutionApp/1.0',
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HH API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.items || [];
  }
  
  async deleteResume(resumeId: string): Promise<void> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в HH.ru');
    }
  
    const response = await fetch(`https://api.hh.ru/resumes/${resumeId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
        'User-Agent': 'RezulutionApp/1.0',
        'HH-User-Agent': 'RezulutionApp/1.0'
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to delete resume: ${response.status}`);
    }
  }
  private getRedirectUri(): string {
    return environment.production 
      ? 'https://rezulution.vercel.app/auth/callback'
      : 'http://localhost:4200/auth/callback';
  }

  async exchangeCodeForToken(code: string): Promise<HHTokenResponse> {
    if (!this.clientId || !this.clientSecret) {
      throw new Error('HH OAuth not configured');
    }

    const body = new URLSearchParams({
      grant_type: 'authorization_code',
      client_id: this.clientId,
      client_secret: this.clientSecret,
      code: code,
      redirect_uri: this.getRedirectUri(),
    });

    const response = await fetch('https://hh.ru/oauth/token', {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'RezulutionApp/1.0'
      },
      body,
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Token exchange failed: ${response.status} ${errorText}`);
    }

    const tokenData: HHTokenResponse = await response.json();
    
    this.saveToken(tokenData);
    
    return tokenData;
  }

  private saveToken(tokenData: HHTokenResponse): void {
    const expiryTime = Date.now() + (tokenData.expires_in * 1000);
    
    localStorage.setItem(this.HH_TOKEN_KEY, tokenData.access_token);
    localStorage.setItem(this.HH_TOKEN_EXPIRY_KEY, expiryTime.toString());
    
    if (tokenData.refresh_token) {
      localStorage.setItem(this.HH_REFRESH_TOKEN_KEY, tokenData.refresh_token);
    }
  }

  getStoredToken(): string | null {
    const token = localStorage.getItem(this.HH_TOKEN_KEY);
    const expiry = localStorage.getItem(this.HH_TOKEN_EXPIRY_KEY);

    if (!token || !expiry) {
      return null;
    }

    if (Date.now() > parseInt(expiry)) {
      this.clearTokens();
      return null;
    }

    return token;
  }

  isTokenValid(): boolean {
    return this.getStoredToken() !== null;
  }

  clearTokens(): void {
    localStorage.removeItem(this.HH_TOKEN_KEY);
    localStorage.removeItem(this.HH_TOKEN_EXPIRY_KEY);
    localStorage.removeItem(this.HH_REFRESH_TOKEN_KEY);
  }

  async refreshToken(): Promise<string | null> {
    const refreshToken = localStorage.getItem(this.HH_REFRESH_TOKEN_KEY);
    
    if (!refreshToken) {
      return null;
    }

    try {
      const body = new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: this.clientId,
        client_secret: this.clientSecret,
      });

      const response = await fetch('https://hh.ru/oauth/token', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/x-www-form-urlencoded',
          'User-Agent': 'RezulutionApp/1.0'
        },
        body,
      });

      if (!response.ok) {
        throw new Error('Token refresh failed');
      }

      const tokenData: HHTokenResponse = await response.json();
      this.saveToken(tokenData);
      
      return tokenData.access_token;
    } catch (error) {
      this.errorHandler.showError('Ошибка обновления токена', 'HHAuthService');
      this.clearTokens();
      return null;
    }
  }

  async getValidToken(): Promise<string | null> {
    let token = this.getStoredToken();
    
    if (!token) {
      token = await this.refreshToken();
    }

    return token;
  }

  async getVacancyDetails(vacancyId: string, accessToken: string): Promise<any> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в HH.ru');
    }

    const response = await fetch(`https://api.hh.ru/vacancies/${vacancyId}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'User-Agent': 'RezulutionApp/1.0',
        'HH-User-Agent': 'RezulutionApp/1.0'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  }

  async getCurrentUser(accessToken: string): Promise<any> {
    const response = await fetch(`${this.apiUrl}/me`, {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'User-Agent': 'RezulutionApp/1.0 (serezhka@example.com)'
      }
    });
    
    if (!response.ok) throw new Error('Failed to fetch HH user info');
    return response.json();
  }
  
  async publishResume(accessToken: string, resumeData: any): Promise<string> {
    const draftResponse = await fetch(`${this.apiUrl}/resumes`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
        'User-Agent': 'RezulutionApp/1.0 (serezhka@example.com)'
      },
      body: JSON.stringify(resumeData)
    });

    if (!draftResponse.ok) {
      const error = await draftResponse.json();
      throw new Error(error.description || 'Failed to create resume draft');
    }

    const { id } = await draftResponse.json();
    
    const publishResponse = await fetch(`${this.apiUrl}/resumes/${id}/publish`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'User-Agent': 'RezulutionApp/1.0 (serezhka@example.com)'
      }
    });

    if (!publishResponse.ok) {
      const error = await publishResponse.json();
      throw new Error(error.description || 'Failed to publish resume');
    }

    return id;
  }

  async getResumeStatus(accessToken: string, resumeId: string): Promise<any> {
    const response = await fetch(`${this.apiUrl}/resumes/${resumeId}`, {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'User-Agent': 'RezulutionApp/1.0 (serezhka@example.com)'
      }
    });
    
    if (!response.ok) throw new Error('Failed to fetch resume status');
    return response.json();
  }

  async sendApplication(vacancyId: string, resumeId: string, letter: string, accessToken: string): Promise<any> {
    try {
      const applicationData = {
        vacancy_id: vacancyId,
        resume_id: resumeId,
        message: letter
      };
  
      const response = await fetch('https://api.hh.ru/negotiations', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
          'User-Agent': 'RezulutionApp/1.0',
          'HH-User-Agent': 'RezulutionApp/1.0'
        },
        body: JSON.stringify(applicationData)
      });
  
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.description || `HTTP error! status: ${response.status}`);
      }
  
      return await response.json();
    } catch (error) {
      this.errorHandler.showError('Ошибка отправки заявки', 'HHAuthService');
      throw error;
    }
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\job-platforms\hh\hh-vacancy.service.ts ---

import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, from, map, catchError, of, switchMap, throwError } from 'rxjs';
import { HHAuthService } from './hh-auth.service';
import { vacancySchema, type Vacancy } from '../../../vacancy-schema';
import { TranslateService } from '@ngx-translate/core';

export interface VacancySearchParams {
  text?: string;
  area?: string;
  experience?: string;
  employment?: string;
  schedule?: string;
  salary?: number;
  currency?: string;
  only_with_salary?: boolean;
  period?: number;
  professional_role?: string;
  industry?: string;
  employer_id?: string;
  order_by?: string;
  per_page?: number;
  page?: number;
  [key: string]: any;
}

export interface VacancyExportOptions {
  includeSalary: boolean;
  includeContacts: boolean;
  includeAddress: boolean;
  includeCounters: boolean;
  includeSnippet: boolean;
  includeDescription: boolean;
  includeRequirements: boolean;
  includeResponsibilities: boolean;
  includeEmployerInfo: boolean;
  includeMetadata: boolean;
  format: 'txt' | 'json' | 'yaml';
}

export interface VacancyFromUrlResult {
  vacancy: Vacancy;
  vacancyId: string;
  success: boolean;
  error?: string;
}

@Injectable({ providedIn: 'root' })
export class HHVacancyService {
  private readonly API_URL = 'https://api.hh.ru/vacancies';
  private vacancyCache = new Map<string, any>();

  constructor(
    private http: HttpClient,
    private hhAuthService: HHAuthService,
    private translate: TranslateService
  ) {}
  getVacancy(identifier: string): Observable<Vacancy> {
    return from(this.hhAuthService.getValidToken()).pipe(
      switchMap(token => {
        const vacancyId = typeof identifier === 'string' 
        ? this.extractVacancyIdFromUrl(identifier) || identifier
        : String(identifier);

        if (!this.validateVacancyId(vacancyId)) {
          return throwError(() => new Error(`Invalid vacancy ID: ${vacancyId}`));
        }

        return this.http.get<any>(`https://api.hh.ru/vacancies/${vacancyId}`, {
          headers: {
            'User-Agent': 'RezulutionApp/1.0 (serezhka@example.com)',
            'HH-User-Agent': 'RezulutionApp/1.0'
          }
        }).pipe(
          map(response => {
            const validation = vacancySchema.safeParse(response);
            if (!validation.success) {
              throw new Error('Invalid vacancy data format');
            }
            return validation.data;
          }),
          catchError(error => {
            throw new Error(this.handleApiError(error, 'HH.ru'));
          })
        );
      })
    );
  }

  searchVacancies(params: VacancySearchParams): Observable<any> {
    return from(this.hhAuthService.getValidToken()).pipe(
      switchMap(token => {
        let httpParams = new HttpParams();
        
        Object.keys(params).forEach(key => {
          const value = params[key];
          if (value !== undefined && value !== null && value !== '') {
            httpParams = httpParams.append(key, value.toString());
          }
        });

        return this.http.get<any>('https://api.hh.ru/vacancies', {
          headers: {
            'User-Agent': 'RezulutionApp/1.0 (serezhka@example.com)',
            'HH-User-Agent': 'RezulutionApp/1.0'
          },
          params: httpParams
        }).pipe(
          catchError(error => {
            throw new Error(this.handleApiError(error, 'HH.ru'));
          })
        );
      })
    );
  } 
  getVacancyFromUrl(url: string): Observable<VacancyFromUrlResult> {
    const vacancyId = this.extractVacancyIdFromUrl(url);
    
    if (!vacancyId) {
      return of({
        vacancy: null as any,
        vacancyId: '',
        success: false,
        error: 'Не удалось извлечь ID вакансии из ссылки'
      });
    }
  
    return this.getVacancy(vacancyId).pipe(
      map(vacancy => ({
        vacancy: vacancy,
        vacancyId: vacancyId,
        success: true
      })),
      catchError(error => {
        return of({
          vacancy: null as any,
          vacancyId: vacancyId,
          success: false,
          error: error.message
        });
      })
    );
  }
  
  getVacancyById(id: string): Observable<Vacancy> {
    return this.getVacancy(id);
  }

  async getVacancyWithCache(vacancyIdOrUrl: string): Promise<any> {
    const vacancyId = this.extractVacancyIdFromUrl(vacancyIdOrUrl) || vacancyIdOrUrl;
    
    if (this.vacancyCache.has(vacancyId)) {
      return this.vacancyCache.get(vacancyId);
    }
    
    const vacancy = await this.getVacancyDetails(vacancyId).toPromise();
    this.vacancyCache.set(vacancyId, vacancy);
    return vacancy;
  }
  extractKeySkills(vacancy: any): string[] {
    return vacancy.key_skills?.map((skill: any) => skill.name) || [];
  }
  
  extractRequirements(vacancy: any): string {
    return this.cleanHtml(vacancy.snippet?.requirement || '');
  }
  
  extractCompanyInfo(vacancy: any): any {
    return {
      name: vacancy.employer?.name,
      industry: vacancy.employer?.industry?.name,
      trusted: vacancy.employer?.trusted
    };
  }

  private handleApiError(error: any, platform: string): string {
    console.error(`${platform} API error:`, error);
    
    if (error.status === 0) {
      return `Network error: Cannot connect to ${platform}`;
    }
    
    if (error.status >= 500) {
      return `${platform} server error: ${error.status}`;
    }
    
    if (error.status === 404) {
      return `Not found on ${platform}`;
    }
    
    if (error.status === 401 || error.status === 403) {
      return `Authorization error on ${platform}`;
    }
    
    return `Error accessing ${platform}: ${error.status} ${error.statusText}`;
  }

  exportVacancy(vacancy: any, options: VacancyExportOptions): string {
    let exportData = this.prepareExportData(vacancy, options);

    switch (options.format) {
      case 'json':
        return JSON.stringify(exportData, null, 2);
      case 'yaml':
        return this.convertToYaml(exportData);
      case 'txt':
      default:
        return this.convertToText(exportData, vacancy, options);
    }
  }

  extractVacancyIdFromUrl(url: string): string | null {
    if (!url) return null;
    
    try {
      let normalizedUrl = url;
      if (!url.startsWith('http')) {
        normalizedUrl = 'https://' + url;
      }
      
      const urlObj = new URL(normalizedUrl);
      
      const hhDomains = ['hh.ru', 'hh.ua', 'hh.by', 'hh.kz', 'api.hh.ru'];
      
      if (!hhDomains.some(domain => urlObj.hostname.includes(domain))) {
        return null;
      }
      
      const pathParts = urlObj.pathname.split('/').filter(part => part);
      const vacancyIndex = pathParts.findIndex(part => 
        part === 'vacancy' || part === 'vacancies'
      );
      
      if (vacancyIndex !== -1 && vacancyIndex + 1 < pathParts.length) {
        let id = pathParts[vacancyIndex + 1];
        
        if (id.includes('?')) id = id.split('?')[0];
        if (id.includes('/')) id = id.split('/')[0];
        
        if (/^\d+$/.test(id)) {
          return id;
        }
      }
      
      const directIdMatch = url.match(/\b\d{5,10}\b/);
      if (directIdMatch) {
        return directIdMatch[0];
      }
      
      return null;
      
    } catch (error) {
      console.error('Error parsing URL:', error);
      
      const digitMatch = url.match(/\d{5,10}/);
      return digitMatch ? digitMatch[0] : null;
    }
  }
  validateVacancyId(id: string): boolean {
    return /^\d{5,10}$/.test(id);
  }
  private prepareExportData(vacancy: any, options: VacancyExportOptions): any {
    const data: any = {};

    if (options.includeMetadata) {
      data.id = vacancy.id;
      data.name = vacancy.name;
      data.published_at = vacancy.published_at;
      data.alternate_url = vacancy.alternate_url;
      data.type = vacancy.type?.name;
    }

    if (options.includeEmployerInfo && vacancy.employer) {
      data.employer = {
        name: vacancy.employer.name,
        url: vacancy.employer.alternate_url,
        trusted: vacancy.employer.trusted,
        accredited_it_employer: vacancy.employer.accredited_it_employer
      };
    }

    if (options.includeMetadata) {
      data.experience = vacancy.experience?.name;
      data.employment = vacancy.employment?.name;
      data.schedule = vacancy.schedule?.name;
      data.professional_roles = vacancy.professional_roles?.map((role: any) => role.name);
    }

    if (options.includeSalary && vacancy.salary) {
      data.salary = vacancy.salary;
    }

    if (options.includeAddress && vacancy.address) {
      data.address = {
        city: vacancy.address.city,
        street: vacancy.address.street,
        building: vacancy.address.building,
        description: vacancy.address.description,
        metro_stations: vacancy.address.metro_stations?.map((station: any) => ({
          name: station.station_name,
          line: station.line_name
        }))
      };
    }

    if (options.includeContacts && vacancy.contacts) {
      data.contacts = vacancy.contacts;
    }

    if (options.includeCounters && vacancy.counters) {
      data.counters = vacancy.counters;
    }

    if (options.includeSnippet && vacancy.snippet) {
      data.snippet = {};
      if (options.includeRequirements && vacancy.snippet.requirement) {
        data.snippet.requirement = this.cleanHtml(vacancy.snippet.requirement);
      }
      if (options.includeResponsibilities && vacancy.snippet.responsibility) {
        data.snippet.responsibility = this.cleanHtml(vacancy.snippet.responsibility);
      }
    }

    if (options.includeDescription && vacancy.description) {
      data.description = this.cleanHtml(vacancy.description);
    }

    return data;
  }
  getVacancyDetails(vacancyId: string): Observable<Vacancy> {
    return from(this.hhAuthService.getValidToken()).pipe(
      switchMap(token => {
        if (!token) {
          throw new Error('Требуется авторизация в HH.ru');
        }
  
        return this.http.get<any>(`https://api.hh.ru/vacancies/${vacancyId}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'User-Agent': 'RezulutionApp/1.0',
            'HH-User-Agent': 'RezulutionApp/1.0'
          }
        });
      }),
      map(response => {
        const validation = vacancySchema.safeParse(response);
        if (!validation.success) {
          throw new Error('Invalid vacancy data format');
        }
        return validation.data;
      }),
      catchError(error => {
        console.error('Vacancy details error:', error);
        throw new Error('Ошибка получения деталей вакансии: ' + error.message);
      })
    );
  }
  private convertToText(data: any, originalVacancy: any, options: VacancyExportOptions): string {
    let text = `=== ИНФОРМАЦИЯ О ВАКАНСИИ ===\n\n`;
    
    if (data.id) text += `ID: ${data.id}\n`;
    if (data.name) text += `Название: ${data.name}\n`;
    if (data.employer?.name) text += `Компания: ${data.employer.name}\n`;
    if (data.alternate_url) text += `Ссылка: ${data.alternate_url}\n`;
    if (data.published_at) text += `Опубликована: ${new Date(data.published_at).toLocaleDateString('ru-RU')}\n\n`;

    if (data.type || data.experience || data.employment || data.schedule) {
      text += `=== ОСНОВНАЯ ИНФОРМАЦИЯ ===\n`;
      if (data.type) text += `Тип: ${data.type}\n`;
      if (data.experience) text += `Опыт: ${data.experience}\n`;
      if (data.employment) text += `Занятость: ${data.employment}\n`;
      if (data.schedule) text += `График: ${data.schedule}\n`;
      
      if (data.professional_roles && data.professional_roles.length > 0) {
        text += `Роли: ${data.professional_roles.join(', ')}\n`;
      }
      text += '\n';
    }

    if (data.salary) {
      text += `=== ЗАРПЛАТА ===\n`;
      if (data.salary.from) text += `От: ${data.salary.from} ${data.salary.currency}\n`;
      if (data.salary.to) text += `До: ${data.salary.to} ${data.salary.currency}\n`;
      text += `Брутто: ${data.salary.gross ? 'Да' : 'Нет'}\n\n`;
    }

    if (data.address) {
      text += `=== АДРЕС ===\n`;
      if (data.address.city) text += `Город: ${data.address.city}\n`;
      if (data.address.street) text += `Улица: ${data.address.street}\n`;
      if (data.address.building) text += `Дом: ${data.address.building}\n`;
      if (data.address.description) text += `Описание: ${data.address.description}\n`;
      
      if (data.address.metro_stations && data.address.metro_stations.length > 0) {
        text += `Метро: ${data.address.metro_stations.map((s: any) => s.name).join(', ')}\n`;
      }
      text += '\n';
    }

    if (data.snippet) {
      text += `=== КРАТКОЕ ОПИСАНИЕ ===\n`;
      if (data.snippet.requirement) {
        text += `Требования: ${data.snippet.requirement}\n\n`;
      }
      if (data.snippet.responsibility) {
        text += `Обязанности: ${data.snippet.responsibility}\n\n`;
      }
    }

    if (data.description) {
      text += `=== ПОЛНОЕ ОПИСАНИЕ ===\n`;
      text += `${data.description}\n\n`;
    }

    if (data.contacts) {
      text += `=== КОНТАКТЫ ===\n`;
      if (data.contacts.name) text += `Контактное лицо: ${data.contacts.name}\n`;
      if (data.contacts.email) text += `Email: ${data.contacts.email}\n`;
      if (data.contacts.phones && data.contacts.phones.length > 0) {
        text += `Телефоны:\n`;
        data.contacts.phones.forEach((phone: any, index: number) => {
          text += `  ${index + 1}. ${phone.country}${phone.city}${phone.number}`;
          if (phone.comment) text += ` (${phone.comment})`;
          text += '\n';
        });
      }
    }

    return text;
  }

  private convertToYaml(data: any): string {
    const convertToYamlString = (obj: any, indent = 0): string => {
      let yaml = '';
      const spaces = '  '.repeat(indent);
      
      if (typeof obj !== 'object' || obj === null) {
        return `${spaces}${obj}\n`;
      }
      
      if (Array.isArray(obj)) {
        obj.forEach(item => {
          if (typeof item === 'object') {
            yaml += `${spaces}- \n`;
            yaml += convertToYamlString(item, indent + 2);
          } else {
            yaml += `${spaces}- ${item}\n`;
          }
        });
      } else {
        Object.keys(obj).forEach(key => {
          const value = obj[key];
          if (typeof value === 'object' && value !== null) {
            yaml += `${spaces}${key}:\n`;
            yaml += convertToYamlString(value, indent + 1);
          } else {
            yaml += `${spaces}${key}: ${value}\n`;
          }
        });
      }
      
      return yaml;
    };
    
    return convertToYamlString(data);
  }

  private cleanHtml(text: string): string {
    if (!text) return '';
    
    return text
      .replace(/<[^>]*>/g, '')
      .replace(/&nbsp;/g, ' ')
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/\s+/g, ' ')
      .trim();
  }

  downloadFile(content: string, filename: string, format: string): void {
    const blob = new Blob([content], { 
      type: format === 'json' ? 'application/json' : 
            format === 'yaml' ? 'application/yaml' : 'text/plain' 
    });
    
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.${format}`;
    a.click();
    window.URL.revokeObjectURL(url);
  }

  getAvailableFilters(): any {
    return {
      experience: [
        { value: 'noExperience', label: this.translate.instant('FILTERS.EXPERIENCE.NO_EXPERIENCE') },
        { value: 'between1And3', label: this.translate.instant('FILTERS.EXPERIENCE.BETWEEN_1_AND_3') },
        { value: 'between3And6', label: this.translate.instant('FILTERS.EXPERIENCE.BETWEEN_3_AND_6') },
        { value: 'moreThan6', label: this.translate.instant('FILTERS.EXPERIENCE.MORE_THAN_6') }
      ],
      employment: [
        { value: 'full', label: this.translate.instant('FILTERS.EMPLOYMENT.FULL') },
        { value: 'part', label: this.translate.instant('FILTERS.EMPLOYMENT.PART') },
        { value: 'project', label: this.translate.instant('FILTERS.EMPLOYMENT.PROJECT') },
        { value: 'volunteer', label: this.translate.instant('FILTERS.EMPLOYMENT.VOLUNTEER') },
        { value: 'probation', label: this.translate.instant('FILTERS.EMPLOYMENT.PROBATION') }
      ],
      schedule: [
        { value: 'fullDay', label: this.translate.instant('FILTERS.SCHEDULE.FULL_DAY') },
        { value: 'shift', label: this.translate.instant('FILTERS.SCHEDULE.SHIFT') },
        { value: 'flexible', label: this.translate.instant('FILTERS.SCHEDULE.FLEXIBLE') },
        { value: 'remote', label: this.translate.instant('FILTERS.SCHEDULE.REMOTE') },
        { value: 'flyInFlyOut', label: this.translate.instant('FILTERS.SCHEDULE.FLY_IN_FLY_OUT') }
      ],
      order_by: [
        { value: 'relevance', label: this.translate.instant('FILTERS.ORDER_BY.RELEVANCE') },
        { value: 'salary_desc', label: this.translate.instant('FILTERS.ORDER_BY.SALARY_DESC') },
        { value: 'salary_asc', label: this.translate.instant('FILTERS.ORDER_BY.SALARY_ASC') },
        { value: 'publication_time', label: this.translate.instant('FILTERS.ORDER_BY.PUBLICATION_TIME') },
        { value: 'distance', label: this.translate.instant('FILTERS.ORDER_BY.DISTANCE') }
      ]
    };
  }

  getDefaultExportOptions(): VacancyExportOptions {
    return {
      includeSalary: true,
      includeContacts: false,
      includeAddress: true,
      includeCounters: false,
      includeSnippet: true,
      includeDescription: true,
      includeRequirements: true,
      includeResponsibilities: true,
      includeEmployerInfo: true,
      includeMetadata: true,
      format: 'txt'
    };
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\job-platforms\super-job\superjob-auth.service.ts ---

import { Injectable } from '@angular/core';
import { ConfigService } from '../../config/config.service';
import { BehaviorSubject, filter, first } from 'rxjs';
import { ErrorHandlerService } from '../../error-handler.service';

export interface SuperJobTokenResponse {
  access_token: string;
  refresh_token: string;
  ttl: number;
  expires_in: number;
  token_type: string;
  expires_at?: number;
}

export interface SuperJobResume {
  id: number;
  title: string;
  profession: string;
  created: number;
  modified: number;
  status: number;
  skills: string;
  education: Array<{ name: string; year: number }>;
  experience: Array<{ position: string; company: string; period: string }>;
  payment?: number;
  currency?: string;
  name?: string;
  photo?: string;
  published?: number;
  platform?: string;
}

export interface SuperJobVacancy {
  id: number;
  profession: string;
  firm_name: string;
  town: { title: string };
  payment_from: number;
  payment_to: number;
  currency: string;
  vacancyRichText: string;
  type_of_work: { title: string };
  education: { title: string };
  experience: { title: string };
  catalogues: Array<{ title: string }>;
  date_published: number;
}

export interface SuperJobResume {
  id: number;
  title: string;
  profession: string;
  education: Array<{ name: string; year: number }>;
  experience: Array<{ position: string; company: string; period: string }>;
  skills: string;
  language?: Array<{ level: string; language: string }>;
}

@Injectable({ providedIn: 'root' })
export class SuperJobAuthService {
  private readonly SJ_TOKEN_KEY = 'superjob_access_token';
  private readonly SJ_REFRESH_TOKEN_KEY = 'superjob_refresh_token';
  private readonly SJ_TOKEN_EXPIRY_KEY = 'superjob_token_expiry';
  public clientId: string = '';
  public clientSecret: string = '';
  private readonly API_URL = 'https://api.superjob.ru/2.0';
  private configLoaded = new BehaviorSubject<boolean>(false);

  constructor(
    private configService: ConfigService,
    private errorHandler: ErrorHandlerService
  ) {
    this.initializeConfig().catch(console.error);
  }

  async initializeConfig(): Promise<void> {
    try {
      await this.configService.loadConfig();
      const config = this.configService.getConfig();
      
      this.clientId = config.superJobClientId;
      this.clientSecret = config.superJobClientSecret;

      if (!this.clientId || !this.clientSecret) {
        console.warn('SuperJob OAuth credentials not configured');
      }
      
      this.configLoaded.next(true);
      
    } catch (error) {
      console.error('Failed to initialize SuperJob config:', error);
      this.configLoaded.next(true);
    }
  }

  async getVacancies(params: any = {}): Promise<{ objects: SuperJobVacancy[]; total: number }> {
    try {
      await this.waitForConfig();
      
      const queryParams = new URLSearchParams();
      Object.keys(params).forEach(key => {
        if (params[key] !== undefined && params[key] !== null && params[key] !== '') {
          queryParams.append(key, params[key].toString());
        }
      });
  
      const response = await fetch('/api/cors-proxy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          url: `https://api.superjob.ru/2.0/vacancies/?${queryParams}`,
          method: 'GET'
        })
      });
  
      if (!response.ok) {
        throw new Error(`SuperJob API error: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('SuperJob getVacancies error:', error);
      throw error;
    }
  }
  
  async getVacancyDetails(vacancyId: number): Promise<SuperJobVacancy> {
    const response = await fetch('/api/cors-proxy', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        url: `https://api.superjob.ru/2.0/vacancies/${vacancyId}/`,
        method: 'GET'
      })
    });
  
    if (!response.ok) {
      throw new Error(`SuperJob API error: ${response.status}`);
    }
    
    return await response.json();
  }

  async deleteResume(resumeId: number): Promise<void> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в SuperJob');
    }
  
    try {
      const response = await fetch('/api/cors-proxy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          url: `${this.API_URL}/resumes/${resumeId}/`,
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
            'X-Api-App-Id': this.clientSecret
          }
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to delete resume: ${response.status}`);
      }
    } catch (error) {
      this.errorHandler.showError('Ошибка удаления резюме SuperJob', 'SuperJobAuthService');
      throw error;
    }
  }
  async waitForConfig(): Promise<void> {
    if (this.configLoaded.value) {
      return;
    }
    
    return new Promise((resolve) => {
      this.configLoaded.pipe(
        filter(loaded => loaded),
        first()
      ).subscribe(() => resolve());
    });
  }

  getAuthUrl(state: string): string {
    if (!this.clientId) {
      throw new Error('SuperJob OAuth not configured - clientId missing');
    }

    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.getRedirectUri(),
      state: state,
      response_type: 'code'
    });
    
    return `https://www.superjob.ru/authorize/?${params.toString()}`;
  }
  private getRedirectUri(): string {
    return window.location.origin + '/auth/superjob-callback';
  }

  private saveToken(tokenData: SuperJobTokenResponse): void {
    const expiryTime = Date.now() + (tokenData.expires_in * 1000);
    
    localStorage.setItem(this.SJ_TOKEN_KEY, tokenData.access_token);
    localStorage.setItem(this.SJ_REFRESH_TOKEN_KEY, tokenData.refresh_token);
    localStorage.setItem(this.SJ_TOKEN_EXPIRY_KEY, expiryTime.toString());
  }

  getStoredToken(): string | null {
    const token = localStorage.getItem(this.SJ_TOKEN_KEY);
    const expiry = localStorage.getItem(this.SJ_TOKEN_EXPIRY_KEY);

    if (!token || !expiry) {
      return null;
    }

    if (Date.now() > parseInt(expiry)) {
      this.clearTokens();
      return null;
    }

    return token;
  }

  isTokenValid(): boolean {
    return this.getStoredToken() !== null;
  }

  clearTokens(): void {
    localStorage.removeItem(this.SJ_TOKEN_KEY);
    localStorage.removeItem(this.SJ_REFRESH_TOKEN_KEY);
    localStorage.removeItem(this.SJ_TOKEN_EXPIRY_KEY);
  }

  async exchangeCodeForToken(code: string): Promise<SuperJobTokenResponse> {
    try {
      await this.waitForConfig();
      
      if (!this.clientId || !this.clientSecret) {
        console.error('SuperJob config missing in exchangeCodeForToken:', {
          clientId: this.clientId,
          clientSecret: this.clientSecret
        });
        throw new Error('SuperJob OAuth not configured');
      }
  
      console.log('Making token exchange request to server endpoint');
      
      const response = await fetch('/api/superjob/token', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          code: code,
          redirect_uri: this.getRedirectUri(),
          client_id: this.clientId,
          client_secret: this.clientSecret
        })
      });
  
      const responseText = await response.text();
      console.log('Server response status:', response.status);
      
      if (!response.ok) {
        let errorDetails;
        try {
          errorDetails = JSON.parse(responseText);
        } catch {
          errorDetails = responseText;
        }
        
        throw new Error(`Token exchange failed: ${response.status} - ${JSON.stringify(errorDetails)}`);
      }
  
      const tokenData: SuperJobTokenResponse = JSON.parse(responseText);
      this.saveToken(tokenData);
      
      console.log('Token exchange successful');
      return tokenData;
      
    } catch (error) {
      this.errorHandler.showError('Ошибка обновления токена SuperJob', 'SuperJobAuthService');
      throw error;
    }
  }

  async refreshToken(): Promise<string | null> {
    const refreshToken = localStorage.getItem(this.SJ_REFRESH_TOKEN_KEY);
    
    if (!refreshToken) {
      return null;
    }
  
    try {
      const response = await fetch('/api/superjob/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          refresh_token: refreshToken
        })
      });
  
      if (!response.ok) {
        throw new Error('Token refresh failed');
      }
  
      const tokenData: SuperJobTokenResponse = await response.json();
      this.saveToken(tokenData);
      
      return tokenData.access_token;
    } catch (error) {
      console.error('SuperJob token refresh error:', error);
      this.clearTokens();
      return null;
    }
  }

  async getValidToken(): Promise<string | null> {
    let token = this.getStoredToken();
    
    if (!token) {
      token = await this.refreshToken();
    }

    return token;
  }

  async getResumes(): Promise<SuperJobResume[]> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в SuperJob');
    }

    const response = await fetch(`${this.API_URL}/resumes/`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'X-Api-App-Id': this.clientSecret
      }
    });
    
    if (!response.ok) {
      throw new Error(`SuperJob API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.objects || [];
  }

  async publishResume(resumeData: any): Promise<any> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в SuperJob');
    }

    const response = await fetch(`${this.API_URL}/resumes/`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'X-Api-App-Id': this.clientSecret,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(resumeData)
    });
    
    if (!response.ok) {
      throw new Error(`SuperJob API error: ${response.status}`);
    }
    
    return await response.json();
  }
 
  async sendApplication(vacancyId: number, resumeId: number, message: string): Promise<any> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в SuperJob');
    }

    const response = await fetch(`${this.API_URL}/send/`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'X-Api-App-Id': this.clientSecret,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        id_vacancy: vacancyId,
        id_resume: resumeId,
        message: message
      })
    });
    
    if (!response.ok) {
      throw new Error(`SuperJob API error: ${response.status}`);
    }
    
    return await response.json();
  }

  async getUserResumes(): Promise<SuperJobResume[]> {
    const token = await this.getValidToken();
    
    if (!token) {
      throw new Error('Требуется авторизация в SuperJob');
    }

    try {
      const response = await fetch('/api/cors-proxy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          url: `${this.API_URL}/user_cvs/`,
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'X-Api-App-Id': this.clientSecret
          }
        })
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('SuperJob API error response:', errorText);
        throw new Error(`SuperJob API error: ${response.status} - ${errorText}`);
      }
      
      const data = await response.json();
      console.log('SuperJob user resumes response:', data);
      
      if (data.objects && Array.isArray(data.objects)) {
        return data.objects.map((resume: any) => this.mapUserCvData(resume));
      }
      
      console.warn('Unexpected SuperJob resumes response structure:', data);
      return [];
      
    } catch (error) {
      console.error('Error loading SuperJob user resumes:', error);
      this.errorHandler.showError('Ошибка загрузки резюме SuperJob', 'SuperJobAuthService');
      return [];
    }
  }

  private mapUserCvData(resumeData: any): SuperJobResume {
    return {
      id: resumeData.id || 0,
      title: resumeData.profession || 'Резюме без названия',
      profession: resumeData.profession || '',
      created: resumeData.date_published || Date.now() / 1000,
      modified: resumeData.date_published || Date.now() / 1000,
      status: this.mapCvStatus(resumeData.published),
      skills: '',
      education: [],
      experience: [],
      platform: 'superjob',
      payment: resumeData.payment,
      currency: resumeData.currency,
      name: resumeData.name,
      photo: resumeData.photo,
      published: resumeData.published
    };
  }

  private mapCvStatus(publishedStatus: number): number {
    switch (publishedStatus) {
      case 1: // открытый доступ
      case 10: // выборочный доступ
        return 1; // активен
      case 0: // закрытый доступ
      case 4: // отказано в публикации
      case 100: // черновик
      default:
        return 0; // неактивен
    }
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\notifications\admin-notification.service.ts ---

import { Injectable } from '@angular/core';
import { SupabaseService } from '../db/supabase.service';
import { NotificationType } from './notification.models';
import { ErrorHandlerService } from '../error-handler.service';

@Injectable({ providedIn: 'root' })
export class AdminNotificationService {

  constructor(
    private supabase: SupabaseService,
    private errorHandler: ErrorHandlerService
  ) {}

  // Уведомление для всех пользователей
  async broadcastToAllUsers(
    title: string,
    message: string,
    type: NotificationType = NotificationType.SYSTEM,
    important: boolean = false
  ): Promise<void> {
    try {
      // Получаем всех пользователей
      const { data: users, error } = await this.supabase.client
        .from('user_profiles')
        .select('id');

      if (error) throw error;

      const userIds = users.map(user => user.id);
      await this.sendBulkNotification(userIds, type, title, message, {}, important);
    } catch (error) {
      this.errorHandler.showError('Ошибка рассылки уведомлений', 'AdminNotificationService');
    }
  }

  // Уведомление для пользователей конкретного тарифа
  async broadcastToPlanUsers(
    planId: string,
    title: string,
    message: string,
    type: NotificationType = NotificationType.BILLING,
    important: boolean = true
  ): Promise<void> {
    try {
      const { data: subscriptions, error } = await this.supabase.client
        .from('user_subscriptions')
        .select('user_id')
        .eq('plan_id', planId)
        .eq('status', 'active');

      if (error) throw error;

      const userIds = subscriptions.map(sub => sub.user_id);
      await this.sendBulkNotification(userIds, type, title, message, { planId }, important);
    } catch (error) {
      this.errorHandler.showError('Ошибка рассылки уведомлений по тарифу', 'AdminNotificationService');
    }
  }

  // Уведомление об изменении условий подписки
  async sendSubscriptionChangeNotification(
    planId: string,
    changes: string,
    effectiveDate: Date
  ): Promise<void> {
    const title = 'Изменения в условиях подписки';
    const message = `В вашем тарифе произошли изменения: ${changes}. Изменения вступят в силу с ${effectiveDate.toLocaleDateString('ru-RU')}.`;
    
    await this.broadcastToPlanUsers(planId, title, message, NotificationType.BILLING, true);
  }

  // Уведомление об окончании пробного периода
  async sendTrialEndingNotification(daysLeft: number): Promise<void> {
    const title = 'Пробный период заканчивается';
    const message = `Ваш пробный период закончится через ${daysLeft} ${this.pluralizeDays(daysLeft)}. Рассмотрите переход на платный тариф для продолжения использования всех функций.`;
    
    await this.broadcastToPlanUsers('free', title, message, NotificationType.BILLING, true);
  }

  // Уведомление о новых функциях
  async sendNewFeatureNotification(
    featureName: string,
    featureDescription: string,
    userSegment: 'all' | 'basic' | 'pro' = 'all'
  ): Promise<void> {
    const title = `Новая функция: ${featureName}`;
    const message = featureDescription;
    
    if (userSegment === 'all') {
      await this.broadcastToAllUsers(title, message, NotificationType.FEATURE, false);
    } else {
      await this.broadcastToPlanUsers(userSegment, title, message, NotificationType.FEATURE, false);
    }
  }

  private async sendBulkNotification(
    userIds: string[],
    type: NotificationType,
    title: string,
    message: string,
    data: any,
    important: boolean
  ): Promise<void> {
    if (userIds.length === 0) return;

    const notifications = userIds.map(userId => ({
      user_id: userId,
      type,
      title,
      message,
      data,
      read: false,
      important,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }));

    const { error } = await this.supabase.client
      .from('user_notifications')
      .insert(notifications);

    if (error) throw error;
  }

  private pluralizeDays(count: number): string {
    if (count % 10 === 1 && count % 100 !== 11) return 'день';
    if (count % 10 >= 2 && count % 10 <= 4 && (count % 100 < 10 || count % 100 >= 20)) return 'дня';
    return 'дней';
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\notifications\notification.models.ts ---

export interface AppNotification {
    id: string;
    userId: string;
    type: NotificationType;
    title: string;
    message: string;
    data?: any;
    read: boolean;
    important: boolean;
    expiresAt?: Date;
    createdAt: Date;
    updatedAt: Date;
  }
  
  export enum NotificationType {
    SYSTEM = 'system',
    BILLING = 'billing',
    FEATURE = 'feature',
    SECURITY = 'security',
    PROMOTIONAL = 'promotional'
  }
  
  export interface NotificationPreferences {
    userId: string;
    email: boolean;
    push: boolean;
    inApp: boolean;
    types: {
      [key in NotificationType]: boolean;
    };
    quietHours?: {
      enabled: boolean;
      start: string; // HH:mm
      end: string; // HH:mm
    };
  }

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\notifications\notification.service.ts ---

import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, map } from 'rxjs';
import { SupabaseService } from '../db/supabase.service';
import { AppNotification, NotificationType, NotificationPreferences } from './notification.models';
import { ErrorHandlerService } from '../error-handler.service';

@Injectable({ providedIn: 'root' })
export class NotificationService {
  private notificationsSubject = new BehaviorSubject<AppNotification[]>([]);
  private unreadCountSubject = new BehaviorSubject<number>(0);
  
  public notifications$ = this.notificationsSubject.asObservable();
  public unreadCount$ = this.unreadCountSubject.asObservable();

  constructor(
    private supabase: SupabaseService,
    private errorHandler: ErrorHandlerService
  ) {
    this.loadNotifications();
  }

  async loadNotifications(): Promise<void> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) return;

      const { data, error } = await this.supabase.client
        .from('user_notifications')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(50);

      if (error) throw error;

      const notifications = data.map(this.mapDbNotificationToModel);
      this.notificationsSubject.next(notifications);
      this.updateUnreadCount(notifications);
    } catch (error) {
      this.errorHandler.showError('Ошибка загрузки уведомлений', 'NotificationService');
    }
  }

  async getNotifications(page = 1, limit = 20): Promise<AppNotification[]> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) return [];

      const from = (page - 1) * limit;
      const to = from + limit - 1;

      const { data, error } = await this.supabase.client
        .from('user_notifications')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .range(from, to);

      if (error) throw error;

      return data.map(this.mapDbNotificationToModel);
    } catch (error) {
      this.errorHandler.showError('Ошибка получения уведомлений', 'NotificationService');
      return [];
    }
  }

  async createNotification(notification: Omit<AppNotification, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    try {
      const { data, error } = await this.supabase.client
        .from('user_notifications')
        .insert({
          user_id: notification.userId,
          type: notification.type,
          title: notification.title,
          message: notification.message,
          data: notification.data,
          read: notification.read,
          important: notification.important,
          expires_at: notification.expiresAt?.toISOString(),
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select('id')
        .single();

      if (error) throw error;

      await this.loadNotifications(); // Reload notifications
      return data.id;
    } catch (error) {
      this.errorHandler.showError('Ошибка создания уведомления', 'NotificationService');
      throw error;
    }
  }

  async markAsRead(notificationId: string): Promise<void> {
    try {
      const { error } = await this.supabase.client
        .from('user_notifications')
        .update({ 
          read: true,
          updated_at: new Date().toISOString()
        })
        .eq('id', notificationId);

      if (error) throw error;

      await this.loadNotifications(); // Reload notifications
    } catch (error) {
      this.errorHandler.showError('Ошибка обновления уведомления', 'NotificationService');
    }
  }

  async markAllAsRead(): Promise<void> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) return;

      const { error } = await this.supabase.client
        .from('user_notifications')
        .update({ 
          read: true,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', userId)
        .eq('read', false);

      if (error) throw error;

      await this.loadNotifications(); // Reload notifications
    } catch (error) {
      this.errorHandler.showError('Ошибка обновления уведомлений', 'NotificationService');
    }
  }

  async deleteNotification(notificationId: string): Promise<void> {
    try {
      const { error } = await this.supabase.client
        .from('user_notifications')
        .delete()
        .eq('id', notificationId);

      if (error) throw error;

      await this.loadNotifications(); // Reload notifications
    } catch (error) {
      this.errorHandler.showError('Ошибка удаления уведомления', 'NotificationService');
    }
  }

  async deleteAllRead(): Promise<void> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) return;

      const { error } = await this.supabase.client
        .from('user_notifications')
        .delete()
        .eq('user_id', userId)
        .eq('read', true);

      if (error) throw error;

      await this.loadNotifications(); // Reload notifications
    } catch (error) {
      this.errorHandler.showError('Ошибка удаления уведомлений', 'NotificationService');
    }
  }

  async getNotificationPreferences(): Promise<NotificationPreferences | null> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) return null;

      const { data, error } = await this.supabase.client
        .from('user_notification_preferences')
        .select('*')
        .eq('user_id', userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          // Create default preferences
          return await this.createDefaultPreferences(userId);
        }
        throw error;
      }

      return this.mapDbPreferencesToModel(data);
    } catch (error) {
      this.errorHandler.showError('Ошибка получения настроек уведомлений', 'NotificationService');
      return null;
    }
  }

  async updateNotificationPreferences(preferences: Partial<NotificationPreferences>): Promise<void> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) return;

      const { error } = await this.supabase.client
        .from('user_notification_preferences')
        .upsert({
          user_id: userId,
          email: preferences.email,
          push: preferences.push,
          in_app: preferences.inApp,
          types: preferences.types,
          quiet_hours: preferences.quietHours,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        });

      if (error) throw error;
    } catch (error) {
      this.errorHandler.showError('Ошибка обновления настроек уведомлений', 'NotificationService');
    }
  }

  // Системные методы для административных уведомлений
  async sendBulkNotification(
    userIds: string[],
    type: NotificationType,
    title: string,
    message: string,
    data?: any,
    important: boolean = false
  ): Promise<void> {
    try {
      const notifications = userIds.map(userId => ({
        user_id: userId,
        type,
        title,
        message,
        data,
        read: false,
        important,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }));

      const { error } = await this.supabase.client
        .from('user_notifications')
        .insert(notifications);

      if (error) throw error;
    } catch (error) {
      this.errorHandler.showError('Ошибка отправки массовых уведомлений', 'NotificationService');
    }
  }

  async sendSystemNotification(
    title: string,
    message: string,
    type: NotificationType = NotificationType.SYSTEM,
    important: boolean = false
  ): Promise<void> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) return;

      await this.createNotification({
        userId,
        type,
        title,
        message,
        read: false,
        important
      });
    } catch (error) {
      this.errorHandler.showError('Ошибка отправки системного уведомления', 'NotificationService');
    }
  }

  // Уведомления о изменениях в подписках
  async sendSubscriptionNotification(
    title: string,
    message: string,
    subscriptionData?: any
  ): Promise<void> {
    await this.sendSystemNotification(
      title,
      message,
      NotificationType.BILLING,
      true
    );
  }

  private mapDbNotificationToModel(dbData: any): AppNotification {
    return {
      id: dbData.id,
      userId: dbData.user_id,
      type: dbData.type as NotificationType,
      title: dbData.title,
      message: dbData.message,
      data: dbData.data,
      read: dbData.read,
      important: dbData.important,
      expiresAt: dbData.expires_at ? new Date(dbData.expires_at) : undefined,
      createdAt: new Date(dbData.created_at),
      updatedAt: new Date(dbData.updated_at)
    };
  }

  private mapDbPreferencesToModel(dbData: any): NotificationPreferences {
    return {
      userId: dbData.user_id,
      email: dbData.email,
      push: dbData.push,
      inApp: dbData.in_app,
      types: dbData.types || this.getDefaultNotificationTypes(),
      quietHours: dbData.quiet_hours
    };
  }

  private async createDefaultPreferences(userId: string): Promise<NotificationPreferences> {
    const defaultPreferences: NotificationPreferences = {
      userId,
      email: true,
      push: true,
      inApp: true,
      types: this.getDefaultNotificationTypes()
    };

    await this.updateNotificationPreferences(defaultPreferences);
    return defaultPreferences;
  }

  private getDefaultNotificationTypes(): { [key in NotificationType]: boolean } {
    return {
      [NotificationType.SYSTEM]: true,
      [NotificationType.BILLING]: true,
      [NotificationType.FEATURE]: true,
      [NotificationType.SECURITY]: true,
      [NotificationType.PROMOTIONAL]: false
    };
  }

  private updateUnreadCount(notifications: AppNotification[]): void {
    const unreadCount = notifications.filter(n => !n.read).length;
    this.unreadCountSubject.next(unreadCount);
  }

  getUnreadNotifications(): Observable<AppNotification[]> {
    return this.notifications$.pipe(
      map(notifications => notifications.filter(n => !n.read))
    );
  }

  getImportantNotifications(): Observable<AppNotification[]> {
    return this.notifications$.pipe(
      map(notifications => notifications.filter(n => n.important && !n.read))
    );
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\pipes\vacancy-id.pipe.ts ---

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'vacancyId',
  standalone: true
})
export class VacancyIdPipe implements PipeTransform {
  transform(value: string): string {
    if (!value) return '';
    
    const urlMatch = value.match(/hh\.ru\/vacancy\/(\d+)/);
    if (urlMatch) {
      return urlMatch[1];
    }
    
    return value;
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\profile\profile.service.ts ---

import { Injectable } from '@angular/core';
import { SupabaseService } from '../db/supabase.service';
import { HttpClient } from '@angular/common/http';
import { Observable, from, switchMap, of, forkJoin, catchError, map } from 'rxjs';
import * as yaml from 'js-yaml';
import { personSchema, type Person, type Experience, type Education, type Skill, type Language } from '../../person-schema';
import { format, parseISO } from 'date-fns';
import { environment } from '../../../environments/environment.prod';
import { ErrorToastComponent } from '../../components/Helpers/error-toast/error-toast.component';
import { ErrorHandlerService } from '../error-handler.service';

@Injectable({ providedIn: 'root' })
export class ProfileService {
  constructor(
    private supabase: SupabaseService,
    private http: HttpClient,
    private errorHandler: ErrorHandlerService
  ) {}

  transformSupabaseProfileToPerson(profileData: any): Person {
    if (!profileData) {
      return this.createEmptyProfile();
    }

    return {
      name: profileData.full_name || '',
      gender: profileData.gender || 'unknown',
      desiredPositions: profileData.profile_data?.desiredPositions || [],
      contact: {
        phone: profileData.phone || '',
        email: profileData.email || '',
        linkedin: profileData.profile_data?.contact?.['linkedin'] || '',
        github: profileData.profile_data?.contact?.['github'] || ''
      },
      location: {
        country: profileData.profile_data?.location?.country || '',
        city: profileData.profile_data?.location?.city || '',
        relocation: profileData.profile_data?.location?.relocation || false,
        remote: profileData.profile_data?.location?.remote || false,
        business_trips: profileData.profile_data?.location?.business_trips || false
      },
      languages: profileData.profile_data?.languages || [],
      skills: profileData.profile_data?.skills || [],
      education: profileData.profile_data?.education || [],
      experience: profileData.profile_data?.experience || [],
      hobby: profileData.profile_data?.hobby || [],
      literature: profileData.profile_data?.literature || []
    };
  }

  loadProfile(): Observable<Person | null> {
    return from(this.supabase.getFullProfile()).pipe(
      map((profileData: any) => {
        if (!profileData) return null;
        return this.transformSupabaseProfileToPerson(profileData);
      }),
      catchError(error => {
        this.errorHandler.showError('Ошибка загрузки профиля', 'ProfileService');
        return of(null);
      })
    );
  }
  saveProfile(person: Person): Observable<boolean> {
    const validation = personSchema.safeParse({ person });
    if (!validation.success) {
      console.error('Validation error:', validation.error);
      return of(false);
    }

    return from(this.supabase.saveFullProfile(person)).pipe(
      map(result => !result.error),
      catchError(error => {
        this.errorHandler.showError('Ошибка сохранения профиля', 'ProfileService');
        return of(false);
      })
    );
  }

  private transformToPerson(profileData: any): Person {
    if (!profileData) {
      return this.createEmptyProfile();
    }
  
    return {
      name: profileData.full_name || '',
      gender: profileData.gender || 'unknown',
      desiredPositions: profileData.profile_data?.desiredPositions || [],
      contact: {
        phone: profileData.phone || '',
        email: profileData.email || '',
        linkedin: profileData.profile_data?.contact?.['linkedin'] || '',
        github: profileData.profile_data?.contact?.['github'] || ''
      },
      location: {
        country: profileData.profile_data?.location?.country || '',
        city: profileData.profile_data?.location?.city || '',
        relocation: profileData.profile_data?.location?.relocation || false,
        remote: profileData.profile_data?.location?.remote || false,
        business_trips: profileData.profile_data?.location?.business_trips || false
      },
      languages: profileData.profile_data?.languages || [],
      skills: profileData.profile_data?.skills || [],
      education: profileData.profile_data?.education || [],
      experience: profileData.profile_data?.experience || [],
      hobby: profileData.profile_data?.hobby || [],
      literature: profileData.profile_data?.literature || []
    };
  }
  
  private createEmptyProfile(): Person {
    return {
      name: '',
      gender: 'unknown',
      desiredPositions: [],
      contact: {
        phone: '',
        email: '',
        linkedin: '',
        github: ''
      },
      location: {
        country: '',
        city: '',
        relocation: false,
        remote: false,
        business_trips: false
      },
      languages: [],
      skills: [],
      education: [],
      experience: [],
      hobby: [],
      literature: []
    };
  }
  exportToYaml(person: Person): string {
    return yaml.dump({ person }, { skipInvalid: true });
  }

  exportToTxt(person: Person): string {
    let txt = `=== Personal Information ===\n`;
    txt += `Name: ${person.name}\n`;
    txt += `Gender: ${person.gender}\n`;
    txt += `Desired Positions: ${person.desiredPositions?.join(', ') || 'Not specified'}\n\n`;

    txt += `=== Contact Information ===\n`;
    txt += `Email: ${person.contact.email}\n`;
    txt += `Phone: ${person.contact.phone || 'Not specified'}\n`;
    txt += `LinkedIn: ${person.contact['linkedin'] || 'Not specified'}\n`;
    txt += `GitHub: ${person.contact['github'] || 'Not specified'}\n\n`;

    txt += `=== Location ===\n`;
    txt += `Country: ${person.location.country || 'Not specified'}\n`;
    txt += `City: ${person.location.city}\n`;
    txt += `Relocation: ${person.location.relocation ? 'Yes' : 'No'}\n`;
    txt += `Remote work: ${person.location.remote ? 'Yes' : 'No'}\n`;
    txt += `Business trips: ${person.location.business_trips ? 'Yes' : 'No'}\n\n`;

    if (person.languages?.length) {
      txt += `=== Languages ===\n`;
      person.languages.forEach(lang => {
        txt += `- ${lang.language}: ${lang.level}\n`;
      });
      txt += `\n`;
    }

    if (person.skills?.length) {
      txt += `=== Skills ===\n`;
      person.skills.forEach(skill => {
        txt += `- ${skill.area}: ${skill.name} (${skill.level}/10)\n`;
      });
      txt += `\n`;
    }

    if (person.education?.length) {
      txt += `=== Education ===\n`;
      person.education.forEach(edu => {
        txt += `- ${edu.institution} (${edu.year}): ${edu.degree} in ${edu.specialty}\n`;
      });
      txt += `\n`;
    }

    if (person.experience?.length) {
      txt += `=== Work Experience ===\n`;
      person.experience.forEach(exp => {
        txt += `- ${exp.company} (${format(parseISO(exp.startDate), 'MMM yyyy')} - ${exp.endDate ? format(parseISO(exp.endDate), 'MMM yyyy') : 'Present'}\n`;
        txt += `  Position: ${exp.position}\n`;
        txt += `  Technologies: ${exp.stack.join(', ')}\n`;
        txt += `  Responsibilities:\n`;
        exp.tasks.forEach(task => txt += `    - ${task}\n`);
        
        if (exp.achievements?.length) {
          txt += `  Achievements:\n`;
          exp.achievements.forEach(ach => {
            txt += `    - ${ach.name}: ${ach.initial_value} → ${ach.final_value} ${ach.uom || ''} (${ach.type})\n`;
          });
        }
      });
    }

    if (person.hobby?.length) {
      txt += `\n=== Hobbies ===\n`;
      txt += person.hobby.map(h => `- ${h}`).join('\n');
    }

    if (person.literature?.length) {
      txt += `\n=== Favorite Literature ===\n`;
      txt += person.literature.map(l => `- ${l}`).join('\n');
    }

    return txt;
  }

  importFromYaml(yamlStr: string): Observable<Person | null> {
    try {
      console.log('Starting YAML import...');
      
      const cleanYamlStr = yamlStr.trim();
      
      const data = yaml.load(cleanYamlStr) as { person: Person };
      console.log('Parsed YAML data:', data);
      
      if (!data || !data.person) {
        throw new Error('Invalid YAML structure: missing "person" root element');
      }
  
      const validation = personSchema.safeParse(data);
      
      if (validation.success) {
        console.log('YAML validation successful');
        return of(validation.data.person);
      } else {
        console.error('YAML validation error:', validation.error);
        
        const fallbackProfile = this.createPartialProfile(data.person);
        return of(fallbackProfile);
      }
    } catch (e) {
      this.errorHandler.showError('Ошибка парсинга YAML', 'ProfileService');
      return of(null);
    }
  }
  
  private createPartialProfile(partialData: any): Person {
    return {
      name: partialData.name || '',
      gender: (partialData.gender || 'unknown') as 'unknown' | 'male' | 'female',
      desiredPositions: Array.isArray(partialData.desiredPositions) ? partialData.desiredPositions : [],
      contact: {
        phone: partialData.contact?.phone || '',
        email: partialData.contact?.email || '',
        linkedin: partialData.contact?.['linkedin'] || '',
        github: partialData.contact?.['github'] || ''
      },
      location: {
        country: partialData.location?.country || '',
        city: partialData.location?.city || '',
        relocation: Boolean(partialData.location?.relocation),
        remote: Boolean(partialData.location?.remote),
        business_trips: Boolean(partialData.location?.business_trips)
      },
      languages: Array.isArray(partialData.languages) ? partialData.languages : [],
      skills: Array.isArray(partialData.skills) ? partialData.skills : [],
      education: Array.isArray(partialData.education) ? partialData.education : [],
      experience: Array.isArray(partialData.experience) ? partialData.experience : [],
      hobby: Array.isArray(partialData.hobby) ? partialData.hobby : [],
      literature: Array.isArray(partialData.literature) ? partialData.literature : []
    };
  }

  private async saveProfileToSupabase(person: Person): Promise<boolean> {
    try {
      const userId = this.supabase.currentUser?.id;
      if (!userId) return false;
  
      const profileData = {
        id: userId,
        email: person.contact.email,
        full_name: person.name,
        phone: person.contact.phone,
        gender: person.gender,
        profile_data: {
          desiredPositions: person.desiredPositions,
          contact: {
            linkedin: person.contact['linkedin'],
            github: person.contact['github']
          },
          location: person.location,
          languages: person.languages,
          skills: person.skills,
          education: person.education,
          experience: person.experience,
          hobby: person.hobby,
          literature: person.literature
        },
        updated_at: new Date().toISOString()
      };
  
      if (!environment.production) {
        localStorage.setItem('sb-local-profile', JSON.stringify(profileData));
        return true;
      }
  
      const { error } = await this.supabase.client
        .from('user_profiles')
        .upsert(profileData, { 
          onConflict: 'id',
        });
  
      if (error) {
        console.error('Supabase error:', error);
        localStorage.setItem('sb-local-profile', JSON.stringify(profileData));
      }
  
      return true;
      
    } catch (error) {
      this.errorHandler.showError('Ошибка сохранения профиля', 'ProfileService');
      return false;
    }
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\resume\resume-generation.service.spec.ts ---

import { TestBed } from '@angular/core/testing';

import { ResumeGenerationService } from './resume-generation.service';

describe('ProfileGenerationService', () => {
  let service: ResumeGenerationService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ResumeGenerationService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\resume\resume-generation.service.ts ---

import { Injectable } from '@angular/core';
import { AIService } from '../ai/ai.service';
import { ProfileService } from '../profile/profile.service';
import { Observable, catchError, map, of, switchMap, from } from 'rxjs';
import { Person } from '../../person-schema';
import { HHVacancyService } from '../job-platforms/hh/hh-vacancy.service';
import { ErrorHandlerService } from '../error-handler.service';
import { UsageService } from '../billing/usage.service';
import { MessageService } from 'primeng/api';

@Injectable({ providedIn: 'root' })
export class ResumeGenerationService {
  private readonly RESUME_KEY = 'generatedResume';
  private readonly COVER_LETTER_KEY = 'coverLetter';
  currentVacancy: any = null;

  constructor(
    private aiService: AIService,
    private profileService: ProfileService,
    private vacancyService: HHVacancyService,
    private errorHandler: ErrorHandlerService,
    private usageService: UsageService,
    private messageService: MessageService
  ) {}

  generateResume(coverLetterContent?: string): Observable<string> {
    return from(this.usageService.checkLimit('resumeGenerations')).pipe(
      switchMap(limitCheck => {
        if (!limitCheck.allowed) {
          const errorMsg = `Достигнут дневной лимит генерации резюме. Доступно: ${limitCheck.remaining} из ${limitCheck.limit}. Обновите тариф для увеличения лимитов.`;
          this.messageService.add({
            severity: 'warn',
            summary: 'Лимит исчерпан',
            detail: errorMsg,
            life: 5000
          });
          throw new Error(errorMsg);
        }
  
        return this.profileService.loadProfile().pipe(
          switchMap(profile => {
            if (!profile) {
              return of('Ошибка: Профиль пользователя не найден. Пожалуйста, заполните профиль сначала.');
            }
  
            // Валидация критически важных данных
            const validationErrors = this.validateProfileForResume(profile);
            if (validationErrors.length > 0) {
              const errorMsg = `Для генерации качественного резюме необходимо заполнить: ${validationErrors.join(', ')}`;
              this.messageService.add({
                severity: 'warn',
                summary: 'Недостаточно данных',
                detail: errorMsg,
                life: 7000
              });
              return of(this.createFallbackResume(profile));
            }
  
            const prompt = this.buildResumePrompt(profile, coverLetterContent);
            
            console.log('🚀 Generating resume with prompt length:', prompt.length);
            console.log('📊 Profile data used:', {
              name: profile.name,
              experience: profile.experience?.length,
              skills: profile.skills?.length,
              education: profile.education?.length
            });
  
            const request = {
              model: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free',
              prompt: prompt,
              max_tokens: 3000, // Увеличил для более детальных резюме
              temperature: 0.6, // Баланс между креативностью и консистентностью
              top_p: 0.8,
              top_k: 50,
              repetition_penalty: 1.1,
              stop: ['<|im_end|>', '<|im_start|>'],
              stream: false
            };
  
            return this.aiService.generateText(request).pipe(
              map(resume => this.cleanResumeContent(resume)),
              switchMap(resume => {
                // Логируем успешную генерацию
                console.log('✅ Resume generated successfully, length:', resume.length);
                return from(this.usageService.incrementUsage('resumeGenerations')).pipe(
                  map(() => resume)
                );
              }),
              catchError(error => {
                console.error('❌ Resume generation error:', error);
                this.errorHandler.showError('Ошибка генерации резюме', 'ResumeGenerationService');
                return of(this.createFallbackResume(profile));
              })
            );
          }),
          catchError(error => {
            console.error('❌ Profile loading error:', error);
            this.errorHandler.showError('Ошибка загрузки профиля', 'ResumeGenerationService');
            return of('Ошибка загрузки профиля. Пожалуйста, проверьте заполнение профиля.');
          })
        );
      }),
      catchError(error => {
        return of(error.message);
      })
    );
  }
  
  private validateProfileForResume(profile: Person): string[] {
    const errors: string[] = [];
    
    if (!profile.name || profile.name.trim().length < 2) {
      errors.push('ФИО');
    }
    
    if (!profile.contact?.email) {
      errors.push('email');
    }
    
    if (!profile.experience || profile.experience.length === 0) {
      errors.push('опыт работы');
    }
    
    if (!profile.skills || profile.skills.length === 0) {
      errors.push('навыки');
    }
    
    if (!profile.education || profile.education.length === 0) {
      errors.push('образование');
    }
    
    return errors;
  }

  private buildResumePrompt(profile: Person, coverLetter?: string): string {
    const userName = profile.name || 'Кандидат';
    const userEmail = profile.contact.email;
    const userPhone = profile.contact.phone || '';
    const userLinkedIn = profile.contact['linkedin'] || '';
    const userGitHub = profile.contact['github'] || '';
    const userTelegram = profile.contact['telegram'] || '';
    
    const desiredPositions = profile.desiredPositions?.join(', ') || 'Не указаны';
    const desiredSalary = 'Не указана'; 
    
    const experienceText = profile.experience?.map((exp, index) => {
      const duration = this.calculateExperienceDuration(exp.startDate, exp.endDate || undefined);
      const achievements = exp.achievements?.map(ach => 
        `✓ ${ach.name}${ach.initial_value ? `: ${ach.initial_value} → ${ach.final_value}${ach.uom ? ` ${ach.uom}` : ''}` : ''}`
      ).join('\n       ') || 'Достижения не указаны'
      
      return `### ${exp.position}
  **Компания:** ${exp.company}
  **Период:** ${exp.startDate} - ${exp.endDate || 'по настоящее время'} (${duration})
  **Обязанности:** ${exp.tasks?.join('; ') || 'Не указаны'}
  **Технологии:** ${exp.stack?.join(', ') || 'Не указаны'}
  **Достижения:**
  ${achievements}`;
    }).join('\n\n') || 'Опыт работы не указан';
  
    const skillsByArea = this.groupSkillsByPriority(profile.skills || []);

    const educationText = profile.education?.map(edu => 
      `### ${edu.institution}
  **Специальность:** ${edu.specialty}
  **Степень:** ${edu.degree || 'Не указана'}
  **Год окончания:** ${edu.year || 'Не указан'}`
    ).join('\n\n') || 'Образование не указано';
  
    // Языки с уровнями
    const languagesText = profile.languages?.map(lang => 
      `- ${lang.language}: ${this.getLanguageLevel(lang.level)}`
    ).join('\n') || 'Языки не указаны';
  
    // Контекст вакансии
    const vacancyContext = this.currentVacancy ? `
  ## 🎯 КОНТЕКСТ ВАКАНСИИ
  
  **Должность:** ${this.currentVacancy.name}
  **Компания:** ${this.currentVacancy.employer?.name}
  **Зарплата:** ${this.currentVacancy.salary ? this.formatSalary(this.currentVacancy.salary) : 'Не указана'}
  **Требуемый опыт:** ${this.currentVacancy.experience?.name || 'Не указан'}
  **Ключевые требования:**
  ${this.vacancyService.extractKeySkills(this.currentVacancy).map(skill => `- ${skill}`).join('\n')}
  
  **Описание вакансии:**
  ${this.currentVacancy.description?.substring(0, 800) || 'Описание не указано'}...
  ` : '';
  
    // Анализ соответствия вакансии
    const vacancyMatchAnalysis = this.currentVacancy ? this.analyzeVacancyMatch(profile, this.currentVacancy) : '';
  
    const promptText = `# ЗАДАЧА: Сгенерировать профессиональное резюме мирового уровня
  
  Ты - эксперт по карьере и HR-специалист с 15-летним опытом. Создай ИДЕАЛЬНОЕ резюме на основе предоставленных данных.
  
  ## 📋 КРИТИЧЕСКИ ВАЖНЫЕ ТРЕБОВАНИЯ:
  
  ### СТРУКТУРА (обязательная):
  1. **Контактная информация** (имя, телефон, email, LinkedIn, локация)
  2. **Цель/Краткое описание** (3-4 предложения, хук для рекрутера)
  3. **Ключевые навыки** (сгруппированные по категориям)
  4. **Опыт работы** (в обратном хронологическом порядке)
  5. **Образование**
  6. **Сертификаты и курсы**
  7. **Языки**
  8. **Проекты** (если есть)
  9. **Дополнительная информация**
  
  ### СТИЛЬ И ФОРМАТ:
  - **Профессиональный деловой стиль**
  - **Использование action verbs** (разработал, оптимизировал, внедрил, увеличил)
  - **Конкретные цифры и метрики** везде где возможно
  - **Длина:** 1.5-2 страницы (800-1200 слов)
  - **Формат:** Markdown с четкой структуру
  - **Акцент на достижениях**, а не на обязанностях
  - **Релевантность** к желаемой позиции
  
  ### КОНКРЕТНЫЕ УКАЗАНИЯ:
  - Преобразуй обычные обязанности в impactful достижения
  - Используй формулу: "Что сделал + Как + Результат"
  - Подчеркивай бизнес-ценность каждого достижения
  - Группируй навыки логически (Technical, Soft Skills, Tools etc.)
  - Создай compelling summary в начале
  
  ${vacancyContext}
  
  ${vacancyMatchAnalysis}
  
  ## 👤 ДАННЫЕ КАНДИДАТА:
  
  ### ОСНОВНАЯ ИНФОРМАЦИЯ
  **ФИО:** ${userName}
  **Целевые позиции:** ${desiredPositions}
  **Желаемая зарплата:** ${desiredSalary}
  
  ### КОНТАКТЫ
  - **Email:** ${userEmail}
  - **Телефон:** ${userPhone || 'Не указан'}
  - **LinkedIn:** ${userLinkedIn || 'Не указан'}
  - **GitHub:** ${userGitHub || 'Не указан'}
  - **Telegram:** ${userTelegram || 'Не указан'}
  
  ### ЛОКАЦИЯ
  - **Город:** ${profile.location.city}
  - **Страна:** ${profile.location.country || 'Россия'}
  - **Переезд:** ${profile.location.relocation ? 'Готов' : 'Не готов'}
  - **Удаленная работа:** ${profile.location.remote ? 'Доступна' : 'Не доступна'}
  - **Командировки:** ${profile.location.business_trips ? 'Возможны' : 'Не возможны'}
  
  ${coverLetter ? `### ДОПОЛНИТЕЛЬНЫЙ КОНТЕКСТ ИЗ СОПРОВОДИТЕЛЬНОГО ПИСЬМА:
  ${coverLetter.substring(0, 1000)}...
  ` : ''}
  
  ## 💼 ОПЫТ РАБОТЫ
  ${experienceText}
  
  ## 🎓 ОБРАЗОВАНИЕ
  ${educationText}
  
  ## 🌐 ЯЗЫКИ
  ${languagesText}
  
  ## 🎯 НАВЫКИ
  ${Object.entries(skillsByArea).map(([area, skills]) => 
    `### ${area}\n${skills.map(s => `- ${s.name}${s.level ? ` (${s.level}/10)` : ''}`).join('\n')}`
  ).join('\n\n')}
  
  ## 🎨 ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ
  - **Хобби:** ${profile.hobby?.join(', ') || 'Не указаны'}
  - **Литература:** ${profile.literature?.join(', ') || 'Не указана'}
  
  ---
  
  **СГЕНЕРИРУЙ ПРОФЕССИОНАЛЬНОЕ РЕЗЮМЕ, КОТОРОЕ:**
  1. Выделит кандидата среди сотен других
  2. Покажет измеримую бизнес-ценность
  3. Будет идеально соответствовать целевым позициям
  4. Использует лучшие практики современных HR-трендов
  5. Содержит конкретные достижения с цифрами
  6. Имеет четкую логическую структуру
  7. Легко читается и сканируется за 30 секунд
  
  Начни резюме сразу с контактной информации, без вступлений.`;
    
    return promptText;
  }
  
  // Исправление 3: Добавьте метод pluralize в класс
  private pluralize(count: number, forms: string[]): string {
    const cases = [2, 0, 1, 1, 1, 2];
    return forms[
      count % 100 > 4 && count % 100 < 20 ? 2 : cases[Math.min(count % 10, 5)]
    ];
  }

  private calculateExperienceDuration(startDate: string, endDate?: string): string {
    try {
      const start = new Date(startDate);
      const end = endDate ? new Date(endDate) : new Date();
      
      const months = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      const years = Math.floor(months / 12);
      const remainingMonths = months % 12;
      
      if (years === 0) {
        return `${remainingMonths} ${this.pluralize(remainingMonths, ['месяц', 'месяца', 'месяцев'])}`;
      } else if (remainingMonths === 0) {
        return `${years} ${this.pluralize(years, ['год', 'года', 'лет'])}`;
      } else {
        return `${years} ${this.pluralize(years, ['год', 'года', 'лет'])} ${remainingMonths} ${this.pluralize(remainingMonths, ['месяц', 'месяца', 'месяцев'])}`;
      }
    } catch {
      return 'Период не указан';
    }
  }
  
  private groupSkillsByPriority(skills: any[]): { [key: string]: any[] } {
    const areaPriority: { [key: string]: number } = {
      'Технические навыки': 1,
      'Программирование': 2,
      'Фреймворки': 3,
      'Базы данных': 4,
      'Инструменты': 5,
      'Методологии': 6,
      'Soft Skills': 7,
      'Языки': 8,
      'Другие навыки': 9
    };
  
    const groups = skills.reduce((acc: { [key: string]: any[] }, skill) => {
      const area = skill.area || 'Другие навыки';
      if (!acc[area]) {
        acc[area] = [];
      }
      
      // Сортируем навыки внутри группы по уровню
      acc[area].push(skill);
      acc[area].sort((a, b) => (b.level || 0) - (a.level || 0));
      
      return acc;
    }, {});
  
    // Сортируем группы по приоритету
    return Object.keys(groups)
      .sort((a, b) => (areaPriority[a] || 10) - (areaPriority[b] || 10))
      .reduce((acc, key) => {
        acc[key] = groups[key];
        return acc;
      }, {} as { [key: string]: any[] });
  }
  
  private getLanguageLevel(level: string): string {
    const levelMap: { [key: string]: string } = {
      'beginner': 'Начальный',
      'elementary': 'Элементарный',
      'intermediate': 'Средний',
      'upper-intermediate': 'Выше среднего',
      'advanced': 'Продвинутый',
      'proficient': 'Свободный',
      'native': 'Родной',
      'a1': 'Начальный (A1)',
      'a2': 'Элементарный (A2)',
      'b1': 'Средний (B1)',
      'b2': 'Выше среднего (B2)',
      'c1': 'Продвинутый (C1)',
      'c2': 'В совершенстве (C2)'
    };
    
    return levelMap[level.toLowerCase()] || level;
  }
  
  private analyzeVacancyMatch(profile: Person, vacancy: any): string {
    const vacancySkills = this.vacancyService.extractKeySkills(vacancy);
    const profileSkills = profile.skills?.map(s => s.name.toLowerCase()) || [];
    
    const matchingSkills = vacancySkills.filter(skill => 
      profileSkills.some(profileSkill => 
        profileSkill.includes(skill.toLowerCase()) || skill.toLowerCase().includes(profileSkill)
      )
    );
    
    const matchPercentage = vacancySkills.length > 0 
      ? Math.round((matchingSkills.length / vacancySkills.length) * 100) 
      : 0;
    
    const missingSkills = vacancySkills.filter(skill => 
      !profileSkills.some(profileSkill => 
        profileSkill.includes(skill.toLowerCase()) || skill.toLowerCase().includes(profileSkill)
      )
    );
    
    return `
  ## 📊 АНАЛИЗ СООТВЕТСТВИЯ ВАКАНСИИ
  
  **Совпадение навыков:** ${matchPercentage}%
  **Найденные соответствия:** ${matchingSkills.length} из ${vacancySkills.length}
  
  ${matchingSkills.length > 0 ? `✅ **Сильные стороны:**
  ${matchingSkills.map(skill => `- ${skill}`).join('\n')}` : ''}
  
  ${missingSkills.length > 0 ? `⚠️ **Рекомендуется развить:**
  ${missingSkills.map(skill => `- ${skill}`).join('\n')}` : ''}
  
  **Рекомендация:** ${this.getMatchRecommendation(matchPercentage)}
  `;
  }
  
  private getMatchRecommendation(percentage: number): string {
    if (percentage >= 80) return 'Идеальное соответствие! Сделай акцент на точном совпадении навыков.';
    if (percentage >= 60) return 'Хорошее соответствие. Подчеркни ключевые совпадающие навыки.';
    if (percentage >= 40) return 'Умеренное соответствие. Выдели transferable skills и готовность к обучению.';
    return 'Низкое соответствие. Сделай акцент на быстрой обучаемости и смежных навыках.';
  }
  
  private formatSalary(salary: any): string {
    if (!salary) return '';
    
    if (salary.from && salary.to) {
      return `${salary.from} - ${salary.to} ${salary.currency}`;
    } else if (salary.from) {
      return `от ${salary.from} ${salary.currency}`;
    } else if (salary.to) {
      return `до ${salary.to} ${salary.currency}`;
    }
    return '';
  } 

  private cleanResumeContent(text: string): string {
    if (!text) return this.createFallbackResume(null);
    
    let cleaned = text
      .replace(/```(?:json|html|markdown)?/g, '')
      .replace(/^#+\s*ЗАДАЧА:.*$/gm, '')
      .replace(/^#+\s*КРИТИЧЕСКИ.*$/gm, '')
      .replace(/^#+\s*СТРУКТУРА.*$/gm, '')
      .replace(/^#+\s*СТИЛЬ И ФОРМАТ.*$/gm, '')
      .replace(/^#+\s*КОНКРЕТНЫЕ УКАЗАНИЯ.*$/gm, '')
      .replace(/^#+\s*ДАННЫЕ КАНДИДАТА.*$/gm, '')
      .replace(/^#+\s*СГЕНЕРИРУЙ ПРОФЕССИОНАЛЬНОЕ РЕЗЮМЕ.*$/gm, '')
      .replace(/\*{2,}/g, '*')
      .replace(/\n{3,}/g, '\n\n')
      .trim();
  
    if (!cleaned.startsWith('#')) {
      cleaned = `# Резюме\n\n${cleaned}`;
    }
  
    return cleaned;
  }

  private createFallbackResume(profile: Person | null): string {
    if (!profile) {
      return `# Резюме

## Контактная информация
- Email: example@email.com
- Телефон: +7 XXX XXX XX XX

## О себе
Опытный специалист с доказанными навыками в своей области.

## Навыки
- Профессиональные навыки
- Работа в команде
- Решение проблем

## Опыт работы
Ответственный сотрудник с опытом достижения результатов.

## Образование
Высшее образование по соответствующей специальности.

Примечание: Заполните профиль для генерации персонализированного резюме.`;
    }

    return `# Резюме - ${profile.name}

## Контактная информация
- Email: ${profile.contact.email}
- Телефон: ${profile.contact.phone || 'Не указан'}
- Город: ${profile.location.city}

## О себе
Профессионал с опытом работы в ${profile.experience?.length || 0} компаниях.

## Навыки
${profile.skills?.slice(0, 5).map(s => `- ${s.name}`).join('\n') || '- Навыки не указаны'}

## Опыт работы
${profile.experience?.slice(0, 3).map(exp => 
  `- ${exp.company}: ${exp.position}`
).join('\n') || '- Опыт не указан'}

## Образование
${profile.education?.map(edu => 
  `- ${edu.institution}: ${edu.specialty}`
).join('\n') || '- Образование не указано'}`;
  }

  generateResumeSection(promptText: string): Observable<string> {
    const prompt = `Сгенерируй качественный текст для раздела резюме на русском языке.
Требования:
- Профессиональный деловой стиль
- Конкретные достижения с цифрами
- Без воды, только факты
- Максимально информативно

Задание: ${promptText}`;

    const request = {
      model: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free',
      prompt: prompt,
      max_tokens: 800,
      temperature: 0.7,
      top_p: 0.7,
      top_k: 50,
      repetition_penalty: 1.1,
      stop: ['<|im_end|>', '<|im_start|>'],
      stream: false
    };

    return this.aiService.generateText(request).pipe(
      catchError(error => {
        console.error('Resume section generation error:', error);
        return of(this.createFallbackSection(promptText));
      })
    );
  }

  private createFallbackSection(prompt: string): string {
    if (prompt.includes('О себе') || prompt.includes('описание')) {
      return 'Опытный специалист с сильными профессиональными навыками и стремлением к развитию.';
    }
    if (prompt.includes('опыт') || prompt.includes('работа')) {
      return 'Ответственный сотрудник с доказанным опытом достижения результатов.';
    }
    return 'Профессионал с качественным опытом работы.';
  }

  saveResume(resume: string): void {
    localStorage.setItem(this.RESUME_KEY, resume);
  }

  saveCoverLetter(coverLetter: string): void {
    localStorage.setItem(this.COVER_LETTER_KEY, coverLetter);
  }

  getCoverLetter(): string | null {
    return localStorage.getItem(this.COVER_LETTER_KEY);
  }

  deleteResume(): void {
    localStorage.removeItem(this.RESUME_KEY);
  }

  deleteCoverLetter(): void {
    localStorage.removeItem(this.COVER_LETTER_KEY);
  }

  getResume(): string | null {
    return localStorage.getItem(this.RESUME_KEY);
  }

  hasSavedResume(): boolean {
    return localStorage.getItem(this.RESUME_KEY) !== null;
  }

  hasCoverLetter(): boolean {
    return localStorage.getItem(this.COVER_LETTER_KEY) !== null;
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\state\app-state.service.ts ---

import { Injectable } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { filter } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class AppStateService {
  private readonly STATE_KEY = 'app_state';

  constructor(private router: Router) {
    this.setupRouterListener();
  }

  private setupRouterListener(): void {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe((event: NavigationEnd) => {
      this.saveState({
        ...this.getState(),
        currentUrl: event.url
      });
    });
  }

  saveState(state: any): void {
    try {
      localStorage.setItem(this.STATE_KEY, JSON.stringify(state));
    } catch (error) {
      console.error('Error saving app state:', error);
    }
  }

  getState(): any {
    try {
      const state = localStorage.getItem(this.STATE_KEY);
      return state ? JSON.parse(state) : {};
    } catch (error) {
      console.error('Error loading app state:', error);
      return {};
    }
  }

  clearState(): void {
    try {
      localStorage.removeItem(this.STATE_KEY);
    } catch (error) {
      console.error('Error clearing app state:', error);
    }
  }

  getLastUrl(): string | null {
    const state = this.getState();
    return state.currentUrl || null;
  }

  saveComponentState(componentId: string, state: any): void {
    const appState = this.getState();
    appState.components = appState.components || {};
    appState.components[componentId] = state;
    this.saveState(appState);
  }

  getComponentState(componentId: string): any {
    const appState = this.getState();
    return appState.components?.[componentId] || null;
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\utils\file-processor.service.ts ---

import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class FileProcessorService {
  
    async extractTextFromFile(file: File): Promise<string> {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          
          reader.onload = async (e) => {
            try {
              if (file.type === 'application/pdf') {
                const arrayBuffer = e.target?.result as ArrayBuffer;
                resolve(await this.extractTextFromPDF(arrayBuffer));
              } else if (file.type.includes('word') || file.name.endsWith('.doc') || file.name.endsWith('.docx')) {
                const arrayBuffer = e.target?.result as ArrayBuffer;
                resolve(await this.extractTextFromWord(arrayBuffer));
              } else {
                const content = e.target?.result as string;
                resolve(content);
              }
            } catch (error) {
              reject(error);
            }
          };
          
          reader.onerror = reject;
          
          if (file.type === 'application/pdf' || file.type.includes('word')) {
            reader.readAsArrayBuffer(file);
          } else {
            reader.readAsText(file, 'UTF-8');
          }
        });
      }
      
    private async extractTextFromWord(arrayBuffer: ArrayBuffer): Promise<string> {
    return "Текст из Word документа (требуется установка mammoth.js)";
    }
  private async extractTextFromPDF(arrayBuffer: ArrayBuffer): Promise<string> {
    return "Текст из PDF файла (требуется установка pdf.js)";
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\utils\language.service.ts ---

import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class LanguageService {
  private readonly STORAGE_KEY = 'selectedLanguage';
  private readonly supportedLanguages = ['ru', 'en'];
  private languageSubject = new BehaviorSubject<string>(this.getLanguage());

  getLanguage(): string {
    const savedLang = localStorage.getItem(this.STORAGE_KEY);
    if (savedLang && this.supportedLanguages.includes(savedLang)) {
      return savedLang;
    }

    const browserLang = this.getBrowserLanguage();
    if (browserLang && this.supportedLanguages.includes(browserLang)) {
      return browserLang;
    }

    if (this.isLikelyRussianUser()) {
      return 'ru';
    }

    return 'en';
  }

  setLanguage(lang: string): void {
    if (this.supportedLanguages.includes(lang)) {
      localStorage.setItem(this.STORAGE_KEY, lang);
      this.languageSubject.next(lang);
    }
  }

  private getBrowserLanguage(): string | null {
    const browserLang = navigator.language || (navigator as any).userLanguage;
    
    if (!browserLang) return null;
    
    const baseLang = browserLang.split('-')[0].toLowerCase();
    
    return this.supportedLanguages.includes(baseLang) ? baseLang : null;
  }

  private isLikelyRussianUser(): boolean {
    try {
      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const russianTimezones = [
        'Europe/Kaliningrad', 'Europe/Moscow', 'Europe/Samara', 
        'Europe/Volgograd', 'Asia/Yekaterinburg', 'Asia/Omsk',
        'Asia/Krasnoyarsk', 'Asia/Irkutsk', 'Asia/Yakutsk',
        'Asia/Vladivostok', 'Asia/Magadan', 'Asia/Kamchatka'
      ];
      
      if (russianTimezones.includes(timezone)) {
        return true;
      }

      return false;
    } catch (e) {
      return false;
    }
  }


  get languageChanges$(): Observable<string> {
    return this.languageSubject.asObservable();
  }

  getCurrentLanguage(): string {
    return this.languageSubject.value;
  }
  getSupportedLanguages(): { code: string; name: string }[] {
    return [
      { code: 'en', name: 'English' },
      { code: 'ru', name: 'Русский' }
    ];
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\utils\supabase-error-handler.ts ---

import { PostgrestError } from '@supabase/supabase-js';

export function handleSupabaseError(error: PostgrestError): string {
  switch (error.code) {
    case 'PGRST116':
      return 'Запись не найдена';
    case '23505':
      return 'Дублирующаяся запись';
    case '42501':
      return 'Ошибка прав доступа';
    default:
      return error.message || 'Неизвестная ошибка';
  }
}

--- Файл: C:\Users\Serezhka\Documents\CollectiveProjects\resume\frontend\src\app\shared\vacancy\vacancy.service.ts ---

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, forkJoin, from, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { Vacancy } from '../../vacancy-schema';
import { ErrorHandlerService } from '../error-handler.service';

export interface VacancySearchParams {
  text?: string;
  area?: string;
  experience?: string;
  employment?: string;
  schedule?: string;
  salary?: number;
  currency?: string;
  only_with_salary?: boolean;
  period?: number;
  per_page?: number;
  page?: number;
  [key: string]: any;
}

@Injectable({ providedIn: 'root' })
export class VacancyService {
  private vacancyCache = new Map<string, any>();
  
  constructor(
    private http: HttpClient,
    private errorHandler: ErrorHandlerService
  ) {}

  getVacancy(identifier: string): Observable<Vacancy> {
    const platform = this.detectPlatform(identifier);
    
    if (platform === 'hh') {
      const vacancyId = this.extractHHVacancyId(identifier);
      return this.getHHVacancy(vacancyId || identifier);
    } else if (platform === 'superjob') {
      const vacancyId = this.extractSuperJobVacancyId(identifier);
      return this.getSuperJobVacancy(vacancyId || identifier);
    } else {
      return this.tryAllPlatforms(identifier);
    }
  }

  async getVacancyWithCache(identifier: string): Promise<Vacancy> {
    const cacheKey = identifier;
    
    if (this.vacancyCache.has(cacheKey)) {
      return this.vacancyCache.get(cacheKey);
    }
    
    try {
      const vacancy = await this.getVacancy(identifier).toPromise();
      if (vacancy) {
        this.vacancyCache.set(cacheKey, vacancy);
      }
      return vacancy!;
    } catch (error) {
      this.errorHandler.showError('Ошибка получения вакансии', 'VacancyService');
      throw error;
    }
  }

  searchVacancies(params: VacancySearchParams): Observable<{ platform: string; results: any }[]> {
    const searches = [
      this.searchHHVacancies(params).pipe(
        map(results => ({ platform: 'hh.ru', results })),
        catchError(error => of({ platform: 'hh.ru', results: { error: error.message } }))
      ),
      this.searchSuperJobVacancies(params).pipe(
        map(results => ({ platform: 'superjob.ru', results })),
        catchError(error => of({ platform: 'superjob.ru', results: { error: error.message } }))
      )
    ];

    return forkJoin(searches);
  }

  private getHHVacancy(id: string): Observable<Vacancy> {
    return this.http.get<any>(`https://api.hh.ru/vacancies/${id}`, {
      headers: {
        'User-Agent': 'RezulutionApp/1.0',
        'HH-User-Agent': 'RezulutionApp/1.0'
      }
    }).pipe(
      map(response => this.mapHHVacancyToCommon(response)),
      catchError(error => {
        throw new Error(`Ошибка получения вакансии HH.ru: ${error.message}`);
      })
    );
  }

  private searchHHVacancies(params: VacancySearchParams): Observable<any> {
    const queryParams = new URLSearchParams();
    Object.keys(params).forEach(key => {
      const value = params[key];
      if (value !== undefined && value !== null && value !== '') {
        queryParams.append(key, value.toString());
      }
    });

    return this.http.get<any>(`https://api.hh.ru/vacancies?${queryParams}`, {
      headers: {
        'User-Agent': 'RezulutionApp/1.0',
        'HH-User-Agent': 'RezulutionApp/1.0'
      }
    });
  }

  detectPlatformFromUrl(url: string): string {
    if (url.includes('hh.ru') || url.includes('hh.') || /\/vacancy\//.test(url)) {
      return 'hh.ru';
    } else if (url.includes('superjob.ru')) {
      return 'superjob.ru';
    }
    return 'unknown';
  }
  
  getPlatformLabel(platform: string): string {
    const platformLabels: { [key: string]: string } = {
      'hh.ru': 'HH.ru',
      'superjob.ru': 'SuperJob',
      'hh': 'HH.ru', 
      'superjob': 'SuperJob'
    };
    return platformLabels[platform] || platform;
  }

  private getSuperJobVacancy(id: string): Observable<Vacancy> {
    console.log('Fetching SuperJob vacancy with ID:', id);
    
    return this.http.post<any>('/api/cors-proxy', {
      url: `https://api.superjob.ru/2.0/vacancies/${id}/`,
      method: 'GET'
    }).pipe(
      map(response => {
        console.log('Raw SuperJob API response:', response);
        
        if (response.error) {
          throw new Error(`SuperJob API error: ${response.error}`);
        }
        
        const mappedVacancy = this.mapSuperJobVacancyToCommon(response);
        console.log('Mapped SuperJob vacancy:', mappedVacancy);
        return mappedVacancy;
      }),
      catchError(error => {
        console.error('SuperJob vacancy fetch error:', error);
        throw new Error(`Ошибка получения вакансии SuperJob: ${error.message}`);
      })
    );
  }

  private searchSuperJobVacancies(params: VacancySearchParams): Observable<any> {
    const queryParams = new URLSearchParams();
    Object.keys(params).forEach(key => {
      const value = params[key];
      if (value !== undefined && value !== null && value !== '') {
        queryParams.append(key, value.toString());
      }
    });

    return this.http.post<any>('/api/cors-proxy', {
      url: `https://api.superjob.ru/2.0/vacancies/?${queryParams}`,
      method: 'GET'
    });
  }

  private detectPlatform(url: string): string | null {
    if (url.includes('hh.ru') || url.includes('hh.') || /\/vacancy\//.test(url)) {
      return 'hh';
    } else if (url.includes('superjob.ru')) {
      return 'superjob';
    }
    return null;
  }

  private extractHHVacancyId(url: string): string | null {
    const patterns = [
      /\/vacancy\/(\d+)/,
      /vacancy=(\d+)/,
      /hh\.ru\/vacancy\/(\d+)/,
      /(\d{5,10})/
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }
    return null;
  }

  private extractSuperJobVacancyId(url: string): string | null {
    const patterns = [
      /superjob\.ru\/vakansii\/(\d+)\.html/,
      /superjob\.ru\/vacancy\/(\d+)\.html/,
      /superjob\.ru\/resume\/(\d+)\.html/,
      /\/vacancy\/(\d+)\/?/,
      /(\d{5,9})/
    ];
  
    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match && match[1]) {
        console.log('Extracted SuperJob ID:', match[1], 'from URL:', url);
        return match[1];
      }
    }
    
    console.warn('Could not extract SuperJob ID from URL:', url);
    return null;
  }

  private tryAllPlatforms(identifier: string): Observable<Vacancy> {
    return this.getHHVacancy(identifier).pipe(
      catchError(() => {
        return this.getSuperJobVacancy(identifier).pipe(
          catchError(error => {
            throw new Error(`Не удалось найти вакансию на поддерживаемых платформах: ${error.message}`);
          })
        );
      })
    );
  }

  extractKeySkills(vacancy: any): string[] {
    return vacancy.key_skills?.map((skill: any) => skill.name) || [];
  }
  
  extractRequirements(vacancy: any): string {
    return this.cleanHtml(vacancy.snippet?.requirement || '');
  }

  private cleanHtml(text: string): string {
    if (!text) return '';
    return text
      .replace(/<[^>]*>/g, '')
      .replace(/&nbsp;/g, ' ')
      .replace(/&amp;/g, '&')
      .replace(/\s+/g, ' ')
      .trim();
  }

  exportVacancy(vacancy: Vacancy, format: 'txt' | 'json' = 'txt'): string {
    if (format === 'json') {
      return JSON.stringify(vacancy, null, 2);
    }

    let text = `=== ИНФОРМАЦИЯ О ВАКАНСИИ ===\n\n`;
    text += `Платформа: ${vacancy.platform || 'Неизвестно'}\n`;
    text += `Вакансия: ${vacancy.name}\n`;
    text += `Компания: ${vacancy.employer?.name || 'Не указана'}\n`;
    
    if (vacancy.salary) {
      text += `Зарплата: `;
      if (vacancy.salary.from) text += `от ${vacancy.salary.from} `;
      if (vacancy.salary.to) text += `до ${vacancy.salary.to} `;
      text += `${vacancy.salary.currency || ''}\n`;
    }
    
    if (vacancy.address?.city) {
      text += `Город: ${vacancy.address.city}\n`;
    }
    
    if (vacancy.description) {
      text += `Описание: ${this.cleanHtml(vacancy.description.substring(0, 500))}...\n`;
    }
    
    if (vacancy.key_skills && vacancy.key_skills.length > 0) {
      text += `Навыки: ${vacancy.key_skills.map(s => s.name).join(', ')}\n`;
    }
    
    text += `Ссылка: ${vacancy.alternate_url || 'Не указана'}\n`;
    
    return text;
  }

  private mapHHVacancyToCommon(vacancy: any): Vacancy {
    return {
      id: vacancy.id,
      name: vacancy.name,
      description: vacancy.description || '',
      key_skills: vacancy.key_skills?.map((skill: any) => ({ name: skill.name })) || [],
      employer: {
        name: vacancy.employer?.name,
        logo_urls: { original: vacancy.employer?.logo_urls?.original }
      },
      salary: vacancy.salary ? {
        from: vacancy.salary.from,
        to: vacancy.salary.to,
        currency: vacancy.salary.currency
      } : null,
      address: vacancy.address ? {
        city: vacancy.address.city,
        street: vacancy.address.street,
        building: vacancy.address.building
      } : null,
      experience: vacancy.experience ? { name: vacancy.experience.name } : undefined,
      employment: vacancy.employment ? { name: vacancy.employment.name } : undefined,
      alternate_url: vacancy.alternate_url,
      published_at: vacancy.published_at,
      snippet: vacancy.snippet ? {
        requirement: vacancy.snippet.requirement,
        responsibility: vacancy.snippet.responsibility
      } : undefined,
      platform: 'hh.ru'
    };
  }
  
  private mapSuperJobVacancyToCommon(vacancy: any): Vacancy {
    return {
      id: vacancy.id.toString(),
      name: vacancy.profession,
      description: vacancy.vacancyRichText || '',
      key_skills: vacancy.catalogues?.map((c: any) => ({ name: c.title })) || [],
      employer: {
        name: vacancy.firm_name,
        logo_urls: { original: '' }
      },
      salary: (vacancy.payment_from || vacancy.payment_to) ? {
        from: vacancy.payment_from,
        to: vacancy.payment_to,
        currency: vacancy.currency || 'RUR'
      } : null,
      address: vacancy.town ? { city: vacancy.town.title } : null,
      experience: vacancy.experience ? { name: vacancy.experience.title } : undefined,
      employment: vacancy.type_of_work ? { name: vacancy.type_of_work.title } : undefined,
      alternate_url: vacancy.link || `https://www.superjob.ru/vacancy/${vacancy.id}.html`,
      published_at: vacancy.date_published ? new Date(vacancy.date_published * 1000).toISOString() : undefined,
      platform: 'superjob.ru'
    };
  }
  
  getVacancyPlatform(vacancy: any): string {
    return vacancy.platform || 'unknown';
  }

}

